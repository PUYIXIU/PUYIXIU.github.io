[{"title":"Stellar使用指南","path":"/2025/02/21/hello-world/","content":"随便写点什么吧 Stellar-每个人的独立博客https://xaoxuu.com/blog/20221029/ 文档 | Hexohttps://hexo.io/zh-cn/docs/ 1️⃣ 基本使用💭 表达类标签emoji 表情包 % emoji 蛋糕 %% emoji twemoji 1f634 %% emoji qq 咖啡 %% emoji tieba 礼物 height:2em %% emoji blobcat blobcatheartpride height:3em % blobcat 表情库 icon 图标标签可以在任意位置插入图标： 可以在任意位置插入图标：% icon octopus:32 %% icon octopus:32 color:red %% icon octopus:32 color:orange %% icon octopus:32 color:yellow %% icon octopus:32 color:green %% icon octopus:32 color:cyan %% icon octopus:32 color:blue %% icon octopus:32 color:purple % 自定义图标可以在 source/_data/icons.yml 中配置 mark 标记默认 红 橙 黄 绿 青 蓝 紫 亮 暗 警告 错误 % mark 默认 %% mark 红 color:red %% mark 橙 color:orange %% mark 黄 color:yellow %% mark 绿 color:green %% mark 青 color:cyan %% mark 蓝 color:blue %% mark 紫 color:purple %% mark 亮 color:light %% mark 暗 color:dark %% mark 警告 color:warning %% mark 错误 color:error % hashtag 标签Stellar Hexo GitHub % hashtag Stellar https://xaoxuu.com/wiki/stellar/ %% hashtag Hexo https://hexo.io/ color:blue %% hashtag GitHub https://github.com/xaoxuu/ color:dark % image 图片标签% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] [fancybox:bool/string] % 参数说明src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: #ffffff # 图片区域背景颜色，16进制fancybox: href # fancybox 放大地址，设置此值后会调用该链接放大，如果放大地址为图片地址，可以设置为 true 横向铺满图片猫猫镇楼 % image /images/base/test.jpg 猫猫镇楼 download:true fancybox:true % 竖图（小图）优化猫猫镇楼 % image /images/base/test2.jpg 猫猫镇楼 width:300px padding:10px bg:var(--card) download:true fancybox:true % blockquote 段落引用这是使用 blockquote 标签的例子 % blockquote %这是使用 blockquote 标签的例子% endblockquote % quote 引用居中引用 % quot 居中引用 % 自定义icon配置在_config.stellar.yml的quot下配置 自定义配置 % quot 自定义配置 icon:coffee % 也可以指定任意图标 % quot 也可以指定任意图标 prefix:cat-head:64 suffix:dog-head:64 % 特别引用 % quot 特别引用 el:h4 icon:talk % poetry 诗词黑客也是创造者，与画家、建筑师、作家一样保罗·格雷厄姆黑客搞懂 “计算理论”（theory of computation）的必要性，与画家搞懂颜料化学成分的必要性差不多大。《黑客与画家》节选 % poetry 黑客也是创造者，与画家、建筑师、作家一样 author:保罗·格雷厄姆 footer:《黑客与画家》节选 %黑客搞懂 **“计算理论”**（theory of computation）的必要性，与画家搞懂颜料化学成分的必要性差不多大。% endpoetry % paper 纸张标签《忏悔录》节选第二章这话不是根据我自己的经验，而是根据我的观察，因为我知道自己的经验是完全不适于别人的。第三章可是我无论怎样用功，进步还是很小。说起来真是奇怪，我虽然也有相当的理解能力，我却从来不能从老师那里——父亲和朗拜尔西埃先生是例外——学到什么东西。我另外的一些知识，都是我自学来的，这个以后就会清楚的。我那不能忍受任何束缚的思想不肯服从时间的限制；担心学不会的心情妨碍着我专心听讲：生怕由于自己不懂而让教我的人着急的心情促使我装懂，教的人一直往下教，我却什么也不懂。我想按自己的步调行动，不愿顺从别人的步调。卢梭《忏悔录》第二、三章节选 % paper style:underline title:《忏悔录》节选 author:卢梭 date:《忏悔录》 footer:第二、三章节选 %!-- line left --第二章!-- paragraph --这话不是根据我自己的经验，而是根据我的观察，因为我知道自己的经验是完全不适于别人的。!-- line right --第三章!-- paragraph --可是我无论怎样用功，进步还是很小。说起来真是奇怪，我虽然也有相当的理解能力，我却从来不能从老师那里——父亲和朗拜尔西埃先生是例外——学到什么东西。我另外的一些知识，都是我自学来的，这个以后就会清楚的。我那不能忍受任何束缚的思想不肯服从时间的限制；担心学不会的心情妨碍着我专心听讲：生怕由于自己不懂而让教我的人着急的心情促使我装懂，教的人一直往下教，我却什么也不懂。**我想按自己的步调行动，不愿顺从别人的步调。**% endpaper % style：underline | 无，是否带下划线 title：标题 author：作者 date：日期 footer：页脚 正文可设置段落格式!-- section 小节标题 --小节标题，居中显示!-- paragraph --段落，首行缩进两个字符!-- line left --段落左对齐!-- line right --段落右对齐 reel 卷轴标签南陵别儿童入京李白白酒新熟山中归，黄鸡啄黍秋正肥。呼童烹鸡酌白酒，儿女嬉笑牵人衣。高歌取醉欲自慰，起舞落日争光辉。游说万乘苦不早，著鞭跨马涉远道。会稽愚妇轻买臣，余亦辞家西入秦。仰天大笑出门去，我辈岂是蓬蒿人。全唐诗节选 % reel 南陵别儿童入京 author:李白 date:全唐诗 footer:节选 %白酒新熟山中归，黄鸡啄黍秋正肥。呼童烹鸡酌白酒，儿女嬉笑牵人衣。高歌取醉欲自慰，起舞落日争光辉。游说万乘苦不早，著鞭跨马涉远道。会稽愚妇轻买臣，余亦辞家西入秦。仰天大笑出门去，我辈岂是蓬蒿人。% endreel % note 备注块备注标题备注内容 - color: red、orange、amber、yellow、green、cyan、blue、purple、light、dark、warning、error % note 备注标题 备注内容 [color:color] % link 链接卡片Stellar-每个人的独立博客https://xaoxuu.com/blog/20221029/ % link href [title] [icon:src] [desc:true/false] % button 按钮文档 探索 - size: 默认 | xs（最小号） % button text url [icon:key/src] [color:color] [size:xs] % % button 文档 /wiki icon:solar:notebook-bookmark-bold-duotone % % button 探索 /explore icon:solar:planet-bold-duotone size:xs % okr 目标管理 okr：Objectives and Key Results O1 2025 年小目标：全球旅行 ✈️ 从家门口的小公园开始吧 正常 0% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 正常 1% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 0% KR3 完成前置准备工作 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -0% KR-4 开发、测试和发布 风险 0% copy 复制行 $ % copy curl -s https://sh.xaox.cc/install | sh prefix:$ %% copy git:https xaoxuu.com/hexo-theme-stellar %% copy git:ssh xaoxuu.com/hexo-theme-stellar %% copy git:gh xaoxuu.com/hexo-theme-stellar % radio 单选没有勾选的单选框 已勾选的单选框 没有勾选的单选框 已勾选的单选框 % radio 没有勾选的单选框 %% radio checked:true 已勾选的单选框 % checked：true | false color：颜色 checkbox 复选普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 % checkbox 普通的没有勾选的复选框 %% checkbox checked:true 普通的已勾选的复选框 %% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 % checked：true | false symbol： plus | minus | times color：颜色 audio 音频标签 支持音乐外链和网易云音乐 Your browser does not support the audio tag. % audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %% audio netease:4919517 %% audio type:2 netease:4919517 autoplay:0 % type 2 表示歌曲 0 表示歌单 netease: 歌曲歌单 id，在网易云分享链接中能找到 autoplay 1 表示自动播放 0 表示手动播放 video 视频标签 % video bilibili:BV1x44y1K7ho %% video youtube:FDUk0Kcte9A %- width: 500px # 单位 80% 20em 100mm- autoplay: 1/0 # 1：自动播放 0：手动播放 navbar 导航栏文章项目留言GitHub - 由链接组成的导航栏 % navbar active:/wiki/ [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) % frame 设备框架 % frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top % 文本修饰标签集 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D - 这是 % psw 密码 % 标签- 这是 % u 下划线 % 标签- 这是 % emp 着重号 % 标签- 这是 % wavy 波浪线 % 标签- 这是 % del 删除线 % 标签- 这是 % sup 上角标 color:red % 标签- 这是 % sub 下角标 % 标签- 这是 % kbd 键盘样式 % 标签，试一试：% kbd ⌘ % + % kbd D % 🔢 数据类标签timeline 时间线2025 年 2 月 25 日今天科三考试最后熄火，还好我平时练车熄火太多所以很熟，回空挡打火换一档完成靠边停车，贴着及格线过了，激动的心颤抖的手2025 年 2 月 24 日下午科目三模拟 3 把连挂，教练差点气撅过去 % timeline %!-- node 2025 年 2 月 25 日 --今天科三考试最后熄火，还好我平时练车熄火太多所以很熟，回空挡打火换一档完成靠边停车，贴着及格线过了，激动的心颤抖的手% image /images/meme/idrive.jpg width:300px %!-- node 2025 年 2 月 24 日 --下午科目三模拟 3 把连挂，教练差点气撅过去% image /images/meme/acat.jpg width:200px %% endtimeline % 动态时间线参考 friends 友链明眸如初斑斑reuixiy /source/_data/links/exm_blogs.yml- title: 明眸如初 url: https://www.zywvvd.com/ cover: icon: https://www.zywvvd.com/image/avatar.png description: Hexo-Butterfly搭建，访问统计的3d模型非常炫酷 % friends exm_blogs % sites 网站卡片unsplash高质量图片分享平台 /source/_data/links/sites_design.yml- title: unsplash url: https://unsplash.com/ cover: /images/site/unsplash.png icon: https://unsplash.com/favicon.ico description: 高质量图片分享平台 % sites sites_design % ghcard 卡片GitHub Card APIhttps://github.com/anuraghazra/github-readme-stats % ghcard puyixiu theme:dark %% ghcard PUYIXIU/ashihachi-stellar-blog theme:dark % 📦 容器类标签box 盒子容器% box [title] [color:color] [child:codeblock/tabs] %% endbox % 参数说明title: 标题color: red/orange/yellow/green/cyan/blue/purple/light/darkchild: codeblock | tabs folding 折叠容器展开详情 % folding title [codeblock:bool] [open:bool] [color:color] %content% endfolding % 参数说明codeblock: true | falseopen: true | falsecolor: red/orange/yellow/green/cyan/blue/purple/light/dark folders 聚合折叠容器抽屉A 这个抽屉是空的抽屉B 这个抽屉是空的抽屉C 找到了一把手电筒 % folders %!-- folder 抽屉A --这个抽屉是空的!-- folder 抽屉B --这个抽屉是空的!-- folder 抽屉C --找到了一把手电筒% endfolders % tabs 分栏容器图片代码块表格let x = 123;console.log(Hello World); a b c a1 b1 c1 a2 b2 c2 % tabs active:2 align:center %!-- tab 图片 --% image /images/base/test.jpg width:300px %!-- tab 代码块 --content!-- tab 表格 --| a | b | c || --- | --- | --- || a1 | b1 | c1 || a2 | b2 | c2 |% endtabs % 参数配置align: centeractive: 激活标签 grid 网格分区动态列数 默认布局1列: 240px - 480px2列: 480px - 720px3列: 720px 龟山汉墓崖洞墓是在石山中开凿墓室的一种墓葬形制，地下空间的布置虽然比较自由，但都最大限度象征和模仿了地上生活的内容。目前所知的汉代诸侯王崖洞墓分布在江苏徐州、河北满城等地，共有三十多座。主要集中于黄淮之间的东部地区。徐州北洞山汉墓和狮子山汉墓就是西汉前期的两座大型楚王崖洞墓。刘注墓原棺室的室顶正好对着山的最高处，真不知道在山里作业的工匠是怎么确定的位置。不过后来因为顶上裂开了，才把棺椁移到现在的墓室里。 % grid %!-- cell --content left!-- cell --content right% endgrid % 参数配置w: 一列的宽度c: 固定列数bg: box | cardgap: 每列之间的间距，默认16pxbr: 圆角半径 固定列数 % grid c:2 %...% endgrid % 背景样式 cell 1 cell 2 cell 3 cell 4 cell 1 cell 2 cell 3 cell 4 gallery 图库类似效果 albums 专辑容器posters 海报容器 @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen % gallery %![@tianhao_wang](https://images.unsplash.com/photo-1688142202243-e218ad203952?w=800auto=formatfit=cropq=60ixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDYzfEZ6bzN6dU9ITjZ3fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1700994630045-f7a20df6d92e?w=800auto=formatfit=cropq=60ixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8MjN8fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1533274221104-015a584a1005?w=800auto=formatfit=cropq=60ixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDE4fGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1539604214100-ab860d9082e0?w=800auto=formatfit=cropq=60ixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDIxfGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1698843848092-588f9c1bb0bd?w=800auto=formatfit=cropq=60ixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8Mzh8fHxlbnwwfHx8fHw%3D)![@vklemen](https://images.unsplash.com/photo-1516571748831-5d81767b788d?q=80w=2574auto=formatfit=cropixlib=rb-4.0.3ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)% endgallery % banner 横幅容器参数配置bg: 背景avatar: 头像link: 跳转链接 独立页面 随记收藏随记 % banner 随记 bg:/images/covers/coffee1.jpg %% navbar active:/notes/ [随记](/notes/) [收藏](/bookmark/) %% endbanner % 用户资料页 足八桑八条腿各有想法 % banner 足八桑 八条腿各有想法 bg:/images/covers/pixel_universe.png avatar:/images/base/avatar.png %% endbanner % swiper 轮播容器 % swiper effect:cards %![](https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8auto=formatfit=cropw=774q=80)![](https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8auto=formatfit=cropw=774q=80)![](https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8auto=formatfit=cropw=774q=80)![](https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8auto=formatfit=cropw=774q=80)% endswiper % 参数配置effect: cards | coverflowwidth: min | max 2️⃣ 进阶用法自定义小组件组件库在 _data/widgets.yml 中创建 组件库toc 目录树效果可以参考当前页面右侧的 本文目录 _data/widgets.ymltoc:layout: toclist_number: false # 是否显示序号min_depth: 2 # 建议不要低于 2 即从 H2 标签开始解析（H1 标签用于文章大标题）max_depth: 5 # 5 代表最多解析到 H5 标签fallback: recent # Use a backup widget when toc does not exist.collapse: false # true / false / auto (始终折叠/不折叠/自动折叠) recent 近期文章_data/widgets.ymlrecent:layout: recentrss: # /atom.xml # npm i hexo-generator-feedlimit: 5 # Count of posts related 相关文章展示有相同 tag 的其它项目 _data/widgets.ymlrelated:layout: related linkList 链接列表展示一组链接列表 _data/widgets.ymllinklist:layout: linklist# columns:1 列表显示# columns:2 每 2 个按钮放一行columns: 1items:#- icon: svg.../svg # 或者 icons.yml 中设置的 icon 名称- icon: github:logo # 或者 icons.yml 中设置的 icon 名称 title: 关于 url: /about/ markdown 文本内容_data/widgets.ymlwelcome:layout: markdowntitle: 欢迎欢迎#linklist: # 与 linklist 组件写法相同 # columns: 1 # items: # - icon: # title: # url:content: |欢迎来到 **赛博珊瑚礁 🪸**我是这间陋室的守门人 **Ashly**家里那位八腕目正在 **赛博云游中**请问要来杯 **海盐风味的咖啡 ☕** 吗？div style=display:flex;justify-content:centerimg src=/images/base/TaiFi.gif //divsrc: # 可以设置外部 md 文件链接 tagcloud 标签云_data/widgets.ymltagcloud:layout: tagcloudtitle: 标签云# 标签云配置min_font: 12max_font: 24amount: 100orderby: nameorder: 1 # 1, sac 升序；-1, desc 降序color: false # 使用颜色start_color: # 开始的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。end_color: # 结束的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。show_count: false # 显示每个标签的文章总数 ghuser github 用户面板_data/widgets.ymlghuser:layout: ghuserusername: github # your github login usernameavatar: true # show avatar or notmenu: true # show menu or not ghrepo github 项目面板_data/widgets.ymlghrepo:layout: ghrepo _posts/xxx.mdrepo: xaoxuu/hexo-theme-stellar _data/wiki/projects.ymlname: Stellartitle: Stellarsubtitle: 每个人的独立博客 | Designed by xaoxuurepo: xaoxuu/hexo-theme-stellar timeline 时间线_data/widgets.ymltimeline:layout: timelinetitle: 近期动态api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues # 若你想限制数量，在 api 链接后面加上?per_page=1 指限制为 1 条user: # 是否过滤只显示某个人发布的内容，如果要筛选多人，用英文逗号隔开hide: # title,footer # 隐藏标题或底部 # 此功能需要 Stellar v1.13.0 灵活用法指定的页面如果希望对组件的某个属性进行覆写时： _post/xxx.md---title: 某一篇文章leftbar: - welcome # 只写一个字符串代表引用对应的通用组件 - override: my_timeline_lite api: https://xxx---","tags":["hexo"]},{"title":"cocos游戏开发记录：🎁 Name Your Gift","path":"/2024/12/24/NameYourGift/","content":"🎁 前言🎁🎁🎁 第一次从头到尾开发一款完整的h5小游戏，从策划、开发到上架一共花费了16天左右的时间，笔者从来没有接触过游戏行业，对游戏开发也处于摸索的初期，这篇文章的写作目的，是记录我遇到的问题，和解决问题的思路。今天是2024年12月24日平安夜🎄，祝大家圣诞节快乐，开开心心迎接2025🎉🎉🎉！ 🎅 游戏介绍 *圣诞节前夕，圣诞老人🎅正在准备送给孩子们的礼盒，收集散落在房间各处的材料打包成礼盒🎁，找到合适的送礼对象，按照他们的喜好进行包装。* 👉itch.io完整版游戏地址👉游戏全流程展示 游戏名称： Name Your Gift 中文名： 求礼必应 支持语言： 中文、英文 游玩时间： 5-10min 平台： PC 游玩设备： 鼠标、键盘 运行平台： 浏览器 游戏类型： 2d平台跳跃、像素风格 ✂️ 游戏截图 🎮 操作规则❄️使用ADW或者**←→↑**进行移动和跳跃⛄️E键举起物品，X键与NPC或样式台进行交互，Space键跳过对话🎁阅读孩子们寄来的信件，找到适合他们的礼物，按照他们的喜好进行包装🛷将确认包装好的礼盒丢到雪橇车中 💻 开发过程📘 第一步：策划这里主要用几个问题作为切入点：1. 为什么要做这款游戏？2. 这款游戏的核心玩法是什么？3. 这款游戏希望达成的目标是什么？ 问题1：为什么要做这款游戏？ 答： 纯主观答案。因为笔者平时比较喜欢打游戏，比较关注独立游戏与独游开发者，希望能加入这个行列，笔者本职是Web前端工程师，只能靠下班后零碎时间学习游戏相关知识，但无论怎么学，总觉得摸不到门路，于是希望利用现在学到的东西，完完整整的做一款游戏，亲自实践一下，总结经验，为下一步的学习找到方向。 问题2：这款游戏的核心玩法是什么？ 答： 这款游戏实际上更像是一次临摹。玩法上并没怎么设计，最初的想法是：能利用现在学习到的东西，从头到脚制作出一款和圣诞节相关的游戏就行。临摹的对象是itch.io上的创作者williambilliam的游戏作品festive-frenzy，2023年itch.io Christmas Game Jam的参赛获奖游戏。试玩之后觉得非常适合游戏开发上手。这款游戏的玩法就是： 收集制作礼盒需要的3样必备材料：彩纸、礼花、礼物，这些材料散落在地图的各处，把它们带到合成砧，合成为一个礼盒，然后丢到雪橇车内。将所有的礼盒都丢进雪橇内，即算游戏胜利。游戏玩法非常契合2023年Christmas Game Jam的特殊物品要求：砧。但如果仅限于此，玩法似乎过于单调，与此同时我又玩了另一款小游戏：itch.io上创作者duzda的游戏作品santa-says。这款游戏的核心玩法是： 每隔一段时间玩家头顶会掉下一个有着不同彩纸、彩带、尺寸、纹理的礼盒，四周有4个传送带指向4个舱门，每个舱门上都有一个指示牌，上面画着一个礼盒，旁边写着一个关键字（彩纸彩带尺寸纹理），你需要根据这个指示，将礼盒送到匹配指示牌上礼盒的关键字部位的舱门。我认为这个游戏作为一个游戏原型而言相当有趣，于是就借鉴了其中对礼盒样式进行筛选的玩法。NameYourGift在festive-frenzy的游戏基础之上，加入了santa-says的部分要素，设计了最终的玩法：收集制作礼盒的道具——彩纸、礼花、礼物，将它们带到合成砧，合成为礼盒。这回不仅仅要考虑礼盒的制作，还要考虑送礼对象，你要根据孩子们寄来的信件，来判断他们对应的礼物：孩子们的信件包含如下信息：他们的想法、希望或者烦恼，孩子们不会直接向你说明他们想要的礼物，但你需要根据他们的描述来推测他们可能需要的礼物。他们喜欢的彩纸、彩带、纹理，你需要将礼盒定制为他们喜欢的样子。玩家需要带着礼盒，与小精灵进行对话，对话内容会透露与礼物相关的信息，玩家可以根据对话信息进一步判断与礼物匹配的孩子。玩家将制定好样式的礼盒丢到雪橇车中，如果匹配正确，则系统判断礼物打包成功为所有孩子打包好礼物，游戏胜利。 问题3：这款游戏希望达成的目标是什么？ 答： 为了利用自己目前所学，完完整整做一款游戏。这个目标也算是达到了，作为初心者希望能多做一些完整度比较高的小Demo，要笔者自己说，NameYourGift跟【好玩】可差得远了，美术风格也没有什么出众的，是一款没有任何特色的小Demo，但在制作中，笔者自己能在枯燥的学习过程中体验到游戏开发的乐趣，这点就足够了。当然，在玩法设计、玩家调研、概念设计、游戏理念、技术选型、美术设计、游戏测试、游戏发行、市场推广等等方面，我全都知之甚少，但凡事总是要有个开始。还有个很重要的目的，就是用这款游戏来庆祝2024年圣诞节 （乐就完了） 📖 第二步：开发🛠 开发工具准备工作 游戏编辑器：Cocos Creator 2.4.10代码编辑器：VSCode像素画绘制：Aseprite v1.3.10.1精灵图处理：TexturePacker图片处理：Photoshop 2019操作系统：Windows 10进度记录工具： Notion素材整理工具：Eagle关于cocos的学习，主要是通过2个课程进行：CocosCreator入门教程之2D游戏开发【持续更新—第23集】【Cocos教程-游戏开发】2D横板角色移动-攻击-跳跃-冲刺-闪避 ⚙️ 实现过程开发结束后review了代码，有些地方的实现都相当粗糙，像角色移动、物体交互这种功能，一定有更成熟稳定的脚本实现方式，因此这里介绍的各种实现方式，都不是最好的实现方法，有进一步优化的空间。 🗺️ 地图场景搭建推荐2个b站视频：【无废话教程】在Tiled中制作动画瓦片图并导入Cocos Creator引擎【Cocos教程】如何实现人物与墙壁间的碰撞？笔者最初摸索cocos引擎时，知道有TileMap这个东西，学习Unity的时候用过TileMap编辑器，但是到了cocos这里，关于TileMap的介绍很少，看官网文档介绍，需要引入Tiled编辑器导出的.tmx的文件。当时非常摸不着头脑，摸索了一下Tiled编辑器，感觉比较复杂，不是一下就能走通的，于是就不愿意用TileMap继续进行地图编辑了。于是选择了最麻烦的一种方法：直接上手用瓦片一砖一瓦把地图垒起来，然后手动编辑地图包围盒 （自己看到都无语的程度） 。也亏是地图小，一开始叫我垒成功了，因为这个奇葩操作，导致后面很多莫名其妙的问题，比如：我利用玩家与地面碰撞的法向量y值是否等于-1来判断玩家跳跃是否站立在地面上，但效果总是不好，后来发现是因为我自定义的地面包围盒不完全是水平地面的原因（存在斜度）之后看了这两篇教程，一篇介绍如何将Tiled中制作的动画瓦片图导入Cocos Creator，一篇介绍如何使用代码方式给TileMap添加碰撞盒，但跟Unity的TileMap Collider2D比起来，感觉cocos还是麻烦很多。 🚶🏻‍♂️ 角色水平移动 角色水平移动 根据AD键的输入，判断Player的朝向，并给Player的RigidBody一个线性速度：@ccclassexport default class PlayerMove extends cc.Component // 走路速度 walkSpeed: number = 0; // 初始走路速度 initWalkSpeed: number = 0; // 最快走路速度 maxWalkSpeed: number = 350; // 朝向 dir: number = 1; // 刚体 rbBody: cc.RigidBody = null; onLoad() this.rbBody = this.node.getComponent(cc.RigidBody); start() cc.systemEvent.on( cc.SystemEvent.EventType.KEY_DOWN, (event: cc.Event.EventKeyboard) = switch(event.keyCode) case cc.macro.KEY.a: case cc.macro.KEY.left: // 向左移动 this.setFaceDir(-1); this.move(); break; case cc.macro.KEY.d: case cc.macro.KEY.right: // 向右移动 this.setFaceDir(1); this.move(); break; ) move(dir) let v = this.rbBody.linearVelocity; // 逐渐加大加速度，直到最大值200 if(this.walkSpeed 200) this.walkSpeed += 2; // 存在一个速度最大值 if (Math.abs(v.x + this.walkSpeed * this.dir) this.maxWalkSpeed) v.x += this.walkSpeed * this.dir; else v.x = this.maxWalkSpeed * this.dir; this.rbBody.linearVelocity = v; // 设置朝向 setFaceDir(dir) // 转向 if (this.dir !== dir) this.dir = dir; // 转向时加速度变为初始值 this.walkSpeed = this.initWalkSpeed; if (this.dir == 1) // 向右 this.node.scaleX = 1; else // 向左 this.node.scaleX = -1; 此时，Player的移动依旧是存在问题的，因为移动事件是在KEY_DOWN中触发并被调用的，如果长按AD键，KEY_DOWN仅会被调用一次，角色也就仅会移动一小下，但我希望看到的是长按时角色加速移动。因此这里就要配合KEY_UP事件和按键记录哈希表进行实现：参考帖子：cocos creator 组合键怎么用？具体思路就是在KEY_DOWN监听到按键按下时，在哈希表中将这个按键的状态置为激活，在KEY_UP监听到按键被松开时，再将按键重置。在update中对哈希表的属性值进行轮询，发现有处于激活状态的按键就调用对应的按键方法：// 当前按下的键pressKeys = []; onLoad() this.pressKeys = []start() cc.systemEvent.on( cc.SystemEvent.EventType.KEY_UP, (event: cc.Event.EventKeyboard) = // 按键重置 this.pressKeys[event.keyCode] = false; ); cc.systemEvent.on( cc.SystemEvent.EventType.KEY_DOWN, (event: cc.Event.EventKeyboard) = // 按键被激活 this.pressKeys[event.keyCode] = true; );update(dt) // 检查pressKeys按键表 this.checkKeyboard() // 检查按键checkKeyboard() for (let [key, value] of Object.entries(this.pressKeys)) if (value == false) continue; let keyCode = Number(key); switch (keyCode) case cc.macro.KEY.a: case cc.macro.KEY.left: // 向左移动 this.setFaceDir(-1); this.move(); break; case cc.macro.KEY.d: case cc.macro.KEY.right: // 向左移动 this.setFaceDir(1); this.move(); break; case cc.macro.KEY.w: case cc.macro.KEY.up: // 跳跃 this.jump(); break; 📷 角色跳跃与相机跟随 角色跳跃与相机跟随 角色跳跃中最好实现的就是跳跃动作本身，给Player的RigidBody一个沿y轴朝上的linearVelocity线性速度即可：// 是否可以跳跃jumpEnable: boolean = true// 跳起的线性速度jumpSpeed: number = 800;// 跳跃jump() if(!this.jumpEnable) return let v = this.rbBody.linearVelocity v.y = this.jumpSpeed this.rbBody.linearVelocity = v this.jumpEnable = false;但是需要注意的是，如何判断Player现在是否可以跳跃，因为Player只有在确认双脚在地上时才能进行下次跳跃，要不就左脚踩右脚原地飞升了。判断的方法是检测碰撞的法向量的y值是否小于0，小于0说明此时地面在低于Player的方向：// 检测与地面之间的碰撞onBeginContact(contact, self, other) // 当前接触到地面，可以跳起 let group = other.node.group if(other.tag == CollisionTags.ground self.tag == playerCollistionTags.move) // 从上至下落下 let normal = contact.getWorldManifold().normal if(normal.y 0) this.jumpEnable = true // 检测玩家双脚离地onEndContact(contact, self, other) // 离开地面，无法跳起 if(other.tag == CollisionTags.ground self.tag == playerCollistionTags.move) // 离开脚下的物体 let normal = contact.getWorldManifold().normal if(normal.y 0) this.jumpEnable = false 相机跟随这里进行了高度控制：以半个屏幕的高度（也就是Canavs的原点高度）为高度跟随节点P，划分整个场景角色在P点以下位置，相机不跟随高度角色在P点以上位置，相机跟随高度相机缓动跟随// 目标相机位置 cameraTarget = x:0, y:0, cameraStep = 8 // 控制缓动平滑度 // 增加一个缓动效果 updateCamera() if(window.game.camera.x !== this.cameraTarget.x) window.game.camera.x += (this.cameraTarget.x - window.game.camera.x)/this.cameraStep if(window.game.camera.y !== this.cameraTarget.y) window.game.camera.y += (this.cameraTarget.y - window.game.camera.y)/this.cameraStep // 相机跟随 cameraFollow() // 跟随x坐标 this.cameraTarget.x = this.node.x if(this.node.y = 0) // 节点在Canvas中心以下，则以Canavs为中心 this.cameraTarget.y = 0 else // 节点高于Canavs中心，开始跟随 this.cameraTarget.y = this.node.y + scrollHeight; 📦️ 物体抬举与抛出 物体抬举与抛出 物体中存在几种可抬举的物品，这里使用Gourp对这些物品的Node进行标识。Player需要一个数组，用于存放当前附近可抬举的物品，这个数组在碰撞检测中进行刷新,当可抬举物品被Player触碰到时，就被纳入数组之中，当碰撞结束时，再被从数组中清除：// 碰撞盒检测onBeginContact(contact, self, other) // 判断是否是可交互物品，是否是交互探测碰撞盒检测到的碰撞 if(pickableList.includes(other.node.group) self.tag == playerCollistionTags.pick) // 检测是否已经存在这个物品 if(this.pickItemList.findIndex(item=item.uuid == other.node.uuid) 0) // 推入该物品 this.pickItemList.push(other.node) onEndContact(contact, self, other) if(pickableList.includes(other.node.group) self.tag == playerCollistionTags.pick) // 从数组中过滤掉 this.pickItemList = this.pickItemList.filter(item=other.node.uuid !== item.uuid) 当Player监听到抬举命令时，首先判断手中有没有物品，如果有，下一步动作则是将物品抛出去，如果没有，则会从可抬举物品队列中挑出队首物品举起。这里需要给抬举抛出动作一个CD间隔，让它无法被连续触发，因为这样会导致Player将刚刚从手中抛出的物品又抬举回来的动作：// 物品收集的CDpickingCD = 0// 是否可以捡起pickable:boolean = false// 被捡起来的物品pickItemList:cc.Node[] = []// 捡起物品pickup() if(this.pickingCD0) return this.pickingCD = 20 // 如果手中有物品，丢出去 if(this.pickingItem) this.throwOut() return if(this.pickItemList.length 0) // 抬举物品 this.pickingItem = this.pickItemList.shift() this.lift() update() // CD冷却 if(this.pickingCD 0) this.pickingCD -- 举起物品和抛出物品是两种截然相反的动作：举起物品：切换举起贴图，被举起物的RigidBody失效，物品坐标定位到Player的头顶位置抛出物品：切换正常贴图，恢复物品RigidBody，并给它一个和玩家朝向相同的linearVelocity线性速度作为抛出力// 丢出物品throwOut() // 切换贴图 this.toggleSprite(normal) // 检查当前玩家的朝向，向指定朝向丢出物品 const pm = this.node.getComponent(PlayerMove) const dir = pm.dir // 此处顺序不能颠倒，否则受力失败 const pickRb = this.pickingItem.getComponent(cc.RigidBody) pickRb.enabled = true this.pickingItem.getComponent(cc.PhysicsPolygonCollider).enabled = true let v = pickRb.linearVelocity pickRb.gravityScale = 1 v.x = 300* dir v.y = 300 pickRb.linearVelocity = v this.pickingItem = null// 举起物品lift() // 切换贴图 this.toggleSprite(pick) let pickRb = this.pickingItem.getComponent(cc.RigidBody) // 将线性速度、角速度控制为0 // 即便是把刚体撤离之后，物体依旧会按照原本的角速度运动 pickRb.linearVelocity.x = 0 pickRb.linearVelocity.y = 0 pickRb.angularVelocity = 0 pickRb.gravityScale = 0 pickRb.enabled = false this.pickingItem.getComponent(cc.PhysicsPolygonCollider).enabled = false // 坐标定到头顶位置 this.pickingItem.x = this.node.x this.pickingItem.y = this.node.y + this.pickingItem.height 🧰 礼物合成 礼物合成 合成一个礼盒，一共需要三种原料，并且每种原料仅仅需要一种。因此合成台就有三个空位，分别留给彩纸、彩带、礼物类型的节点，如果监听到有节点进入了它的检测圈，并且是可以用于合成的材料类型，合成台就会继续检测材料对应的合成席位有没有被占用，如果没有，则就将目标材料纳入席位，如果有，则目标材料作为备用材料进入待合成材料队列中。合成台吸入碰撞检测：// 存放当前包围圈里可以被使用的材料contactMats = [];// 碰撞监听onBeginContact(contact, self, other) // 不是合成包围盒监听到的碰撞 // 不是原材料的，返回 if (self.tag != 1 || !materialGroupList.includes(other.node.group)) return; // contactMat中已经存在的，返回 if (this.contactMats.find((item) = item.uuid == other.node.uuid)) return; // 装载的材料中已经存在的，返回 if (Object.values(this.mat).find((item) = item?.uuid == other.node.uuid)) return; this.contactMats.push(other.node);onEndContact(contact, self, other) // 已经装载的材料，不用再判断了 if (Object.values(this.mat).find((item) = item?.uuid == other.node.uuid)) return; // 剔除 this.contactMats = this.contactMats.filter( (item) = item.uuid != other.node.uuid );有了一个存放可合成物的数组之后，就可以在update中进行装填了，也就是做材料物匹配：// 初始材料席位initMaterial = // 礼物 gift: undefined, // 纸张 papper: undefined, // 丝带 ribbon: undefined, // 材料集齐总数 count: 0,;// 材料席位mat = ...initMaterial; // 对号入座 preload() let cm = [...this.contactMats] for (let material of cm) let load = false switch (material.group) case Gift: if (!this.mat.gift) this.mat.gift = material; load = true break; case Papper: if(!this.mat.papper) this.mat.papper = material; load = true break; case Ribbon: if(!this.mat.ribbon) this.mat.ribbon = material load = true break; // 有新材料被填入 if(load) this.mat.count++ // 将已填入的材料从预备列表中提出 this.contactMats = this.contactMats.filter(item=item.uuid != material.uuid) // 纳入席位的材料重力变为0 let matRb = material.getComponent(cc.RigidBody) matRb.gravityScale = 0 let v = matRb.linearVelocity v.x = 0 v.y = 0 matRb.linearVelocity = v let matCol = material.getComponent(cc.PhysicsPolygonCollider) matCol.enabled = false matRb.enabled = false // 三个席位全满，结束预装填 if(this.mat.count=3) break; 被纳入席位的材料会围绕着工作台上方的合成点进行旋转：// 合并阶段的旋转速度mergingSpinSpeed = 2;// 合并/被吸入的速度mergeSpeed = 0.5;// 旋转spin() let spinItems = Object.values(this.mat).filter(item= return item item instanceof cc.Node ) spinItems.forEach(item= // 计算材料相对合成点（圆心）的坐标 let diffX = item.x - this.center.x let diffY = item.y - this.center.y let distance = Math.sqrt(diffX ** 2 + diffY ** 2) // 计算弧度 let radian = Math.atan(diffY / diffX) // 弧度转角度 let angle = radian * 180 / Math.PI if(diffX 0) angle+=180 if(angle 0) angle += 360 angle += this.spinSpeed radian = angle * Math.PI / 180 distance -= this.mergeSpeed let r = distance this.spinRadius? distance: this.spinRadius item.x = this.center.x + r * Math.cos(radian) item.y = this.center.y + r * Math.sin(radian) )当三个席位都有对应的材料时，开始合并，此时材料的旋转半径开始逐渐减小，材料被卷入合成点，直到超过最小半径阈值时，判定合成结束，生成礼盒：// 合并状态：集齐3个材料，材料们开始向内被吸入，旋转速度加速isMerge = false;// 最小的旋转半径（小于这个值判断为合成结束）minRadius = 5;// 合并/被吸入的速度mergeSpeed = 0.5;// 开始合并merge() // 收缩 this.spinRadius -= this.mergeSpeed // 缩到最小数值 if(this.spinRadius this.minRadius) this.mergeEnd() // 合并结束mergeEnd() // 此处应该生成一个新的礼物 this.generateGift(this.mat.gift) this.mat.gift.active = false this.mat.papper.active = false this.mat.ribbon.active = false // this.mat = JSON.parse(JSON.stringify(initMaterial)) this.mat = ...initMaterial this.spinRadius = initSpinRadius this.spinSpeed = initSpinSpeed this.isMerge = false// 生成礼物generateGift(gift) // 根据礼物的尺寸获取礼物盒，此处关于礼物prefab略 const giftPrefab = this.giftBoxPrefab[gift.getComponent(Gift).size] const newGiftBox = cc.instantiate(giftPrefab) let giftBoxCom = newGiftBox.getComponent(GiftBox) giftBoxCom.setGift(gift) newGiftBox.x = this.center.x newGiftBox.y = this.center.y newGiftBox.setParent(this.giftBoxGroup)从预装材料到合并，需要在update中进行检测：update() this.spinSpeed = initSpinSpeed if (this.mat.count 3) this.preload(); // 预装 else this.spinSpeed = this.mergingSpinSpeed this.merge() // 合并 if(this.mat.count0) this.spin() // 旋转 🎁 礼盒定制 礼盒定制 礼盒定制的主要问题就是，所有搭配的礼盒样式，都要有它对应的资源图片，按照某种规则命名：尺寸-彩纸颜色-彩带颜色-纹理在样式编辑菜单结束后，生成礼盒样式对应的图片资源的名称，然后使用cc.resources.load进行动态加载：// 重新加载贴图resetSprite() /** * 贴图命名模版 * 盒子尺寸-盒子颜色-丝带颜色-盒子纹理 * 大-蓝-白-纯色 */ let name = [ SizeType[this.size], ColorType[this.color], RibbonColorType[this.ribbonColor], PatternType[this.pattern] ].join(-) cc.resources.load(`imgs/boxes/$name`,cc.SpriteFrame, (error:Error, assets:cc.SpriteFrame)= if(error) console.log(error) return this.node.getComponent(cc.Sprite).spriteFrame = assets this.isMerge this.playChange() ) 🛷 礼盒匹配检测当礼物盒检测到与雪橇的碰撞时，会检测孩子数据库中是否存在与该礼物盒匹配的数据，如果存在，则判定礼物包装成功，不存在则判定失败，并添加一个反弹的力：// 开始碰撞 onBeginContact(contact, self, other) if(!this.isMerge) return if(this.done) return // 检测是否是雪橇车的礼物检测碰撞盒 if(other.tag == 3 other.node.name == SnowCar) let success = false // debugger // 对礼物组合进行判定 let data = window.game.childList.json.data for(let i = 0; i data.length; i++) let child = data[i] // 已经包装完毕 if(child.isDone) continue ; let giftList = window.game.globalDict.json.gift let wish = giftList.find(item=item.value == child.gift) // 礼物不一致 if(wish.name !== this.gift.name) continue; if( child.papper == this.color child.ribbon == this.ribbonColor child.pattern == this.pattern ) // 判定礼物分配结束 child.done = true success = true this.node.group = default break; if(success) this.done = true let collider = this.node.getComponent(cc.PhysicsPolygonCollider) collider.density = 1000 collider.friction = 1000 else // 施加一个向外的力 const rb = this.node.getComponent(cc.RigidBody) let v = rb.linearVelocity v.x = -300 v.y = 300 rb.linearVelocity = v 检测成功效果：检测失败效果： 💬 对话系统 对话系统 对话交互的整个实现流程：触发角色对话切换对话中UI根据当前游戏状态判断载入的游戏脚本绑定对话时键盘事件模拟打字字幕效果当前语句结束，加载下一句话所有对话加载完，对话结束第一步：触发与NPC之间的对话，切换对话UI：// 和NPC说话talk() // 游戏暂停 window.game.Pause() // 切换对话中UI this.ToggleTalkUI(true).then(res= // UI切换好之后进入对话 this.startLoadTalk() )第二步：载入当前对话// 加载对话startLoadTalk() // 下面一系列分支用于判断当前应该进行的对话内容 if(!this.hasInitTalked) // 如果没有经过开场对话，加载开场对话脚本 this.curScript = this.initScript this.hasInitTalked = true else if(this.isGameEndTalk) // 此时游戏已经结束，加载结束对话 this.curScript = this.gameEndTalk else // 正在捡起的物品 let pickingItem = this.pickComp.pickingItem let group = pickingItem?.group // 如果是手上拿着礼物或者是礼物盒，加载礼物对应的脚本 if(group == Gift) // 是礼物，直接加载脚本 this.curScript = pickingItem.getComponent(Gift).script.json else if(group == GiftBox) let gift = pickingItem.getComponent(GiftBox).gift this.curScript = gift.getComponent(Gift).script.json else // 如果是其它情况，则加载随机对话 this.curScript = this.randomTalkScript[this.randomTalkIndex] this.randomTalkIndex = (this.randomTalkIndex + 1) % this.randomTalkScript.length // 重置对话内容 this.loadNextWord(null) // 绑定对话键盘事件 cc.systemEvent.on( cc.SystemEvent.EventType.KEY_UP, this.loadNextWord, this ) 第三步：对话中的键盘事件、模拟打字与对话结束此处的关键点在于：对话结束后，一定要对此次对话开始时绑定的键盘事件进行解绑定，因为如果不解绑，就会在下次对话事件被触发时再次绑定一次对话事件，相当于同一个键盘操作对应2个已经被绑定的键盘事件，当触发【下一句话】的操作时，实际会执行2次【载入下一句话】操作，就会出现跳句现象。loadNextWord(event:cc.Event.EventKeyboard) const talkEnd = ()= this.curScript = null // 一定要对已经绑定的对话事件解绑 cc.systemEvent.off( cc.SystemEvent.EventType.KEY_UP, this.loadNextWord, this ) // 结束对话 this.stopTalk() // 输入的是空格，跳过对话 if(event event.keyCode == cc.macro.KEY.space) talkEnd() this.typingLocation = 0 this.targetContent = return if(event event.keyCode !== cc.macro.KEY.e) return // 字还没有打完，按E直接显示全部对话 if(this.tCLabelCp.string.length !== this.targetContent.length) this.typingLocation = this.targetContent.length this.tCLabelCp.string = this.targetContent // 此处清空的是模拟打字中用到的延时器 clearTimeout(this.typingTimer) return this.typingLocation = 0 this.targetContent = // 代表一句话已经加载完 if(this.curTalkIndex = this.curScript.data.length) this.curScript = null talkEnd() return // 加载下一句话 let wordData = this.curScript.data[this.curTalkIndex] // 获取说话者信息 let talker = this.curScript.chara.find(item=item.id == wordData.talker) // 将说话者名字载入名字Node中 this.tNameLabelCp.string = talker.name[window.globalData.lang] this.talkerNameLabel.color = new cc.Color(...talker.color) // 说话人音效 this.talkerSound = talker.sound // 此处插入一个打字特效 this.targetContent = wordData.content[window.globalData.lang] this.tCLabelCp.string = // 模拟打字效果 this.simTyping() this.curTalkIndex ++ // 打字速度typingSpeed:number = 100// 打字位置记录typingLocation:number = 0// 目标打字内容targetContent:string = typingTimer = null// 模拟打字simTyping() window.globalData.playSound(this.talkerSound) this.tCLabelCp.string += (this.targetContent[this.typingLocation] || ) this.typingLocation ++ if(this.typingLocation this.targetContent.length) this.typingTimer = setTimeout(()= this.simTyping() ,this.typingSpeed) // 停止说话，谈话结束stopTalk() // 退出对话UI this.ToggleTalkUI(false).then(res= // 游戏继续 window.game.Continue() this.curTalkIndex = 0 this.tNameLabelCp.string = this.tCLabelCp.string = this.targetContent = ) 🔎 其他问题🧩 全局状态管理单一场景内多个节点的共享的状态，使用一个单一场景脚本类Game进行控制，将Game挂载到Canvas节点上，然后存放到浏览器的window中、多个场景共享的状态， 存放在入口场景中的globalData节点中，将该节点通过cc.game.addPersistRootNode进行保存，可以在多个场景内访问到，用于存放一些游戏总状态、总设置参数。 🌲 场景切换问题如果需要从A场景切换到B场景，需要销毁A场景中绑定的全局事件，否则之前绑定的事件依然会被正常调用：// 如果不销毁绑定的事件，切换场景调用的是被销毁节点上的脚本onDestroy(): void cc.systemEvent.removeAll(cc.SystemEvent.EventType.KEY_DOWN) cc.systemEvent.removeAll(cc.SystemEvent.EventType.KEY_UP) ⌨️ 事件绑定问题参考博客：游戏开发-cocos creator踩坑-bind(this)导致的事件监听off不掉在绑定对话键盘事件时，最初使用的是bind绑定事件的this：cc.systemEvent.on( cc.SystemEvent.EventType.KEY_UP, this.loadNextWord.bind(this))但是通过bind绑定的每次都是新的事件，无法正常进行解绑。需要用另一种方式来对全局事件进行绑定和解绑定：// 事件绑定cc.systemEvent.on( cc.SystemEvent.EventType.KEY_UP, this.loadNextWord, this)// 事件绑定cc.systemEvent.off( cc.SystemEvent.EventType.KEY_UP, this.loadNextWord, this) 🖱️ 防止Click事件穿透上层菜单弹出后，被遮住的按钮依旧能正常触发，需要给不希望被穿透的节点添加BlockInputEvents组件 📅 完整版开发日志 🏁 第三步：上架参考：如何上传你的游戏到itch.io？(含上传页面的翻译)最后上架游戏到itch.io,官方推荐的封面图是630*500，如果是h5游戏，上传包内的文件数量不允许超过1000个，所以在上传之前最好清理一下项目文件夹 🔚 项目总结最深刻的总结就是：一定要针对每个功能，设计单元测试！不然到了游戏后期，所有流程已经串起来之后，再想改一个游戏中的一个部分会非常痛苦这部分还在摸索中…在全局数据规划和控制方面比较混乱这仅是一个只有一个主场景的小游戏，实际上没有涉及任何复杂的设计。根据玩家的实际反馈，游戏在引导方面做的不好， 玩家的游戏体验没有预想的流畅。 💐 游戏资源游戏素材来源 游戏中使用到的都是开源社区创作者们分享的素材资源：美术资源：大部分来自于WilliamBilliam的开源美术资源包festive-frenzy-sprite-sheet，并在此基础上进行了部分扩展。图标资源来自于itch.io上的创作者PiiiXL的开源美术资源包1-bit-icons-part-2操作说明的键盘图标资源来自于itch.io上的创作者xPheRe的开源美术资源包pixel-keyboard-layout麋鹿动画来自于lapizwcg的开源美术资源包the-minifolks-forest-animals-deer-doe-free-32x32-mod-by-lapizwcg字体资源： Uranus-Pixel音效资源： 音乐和音效来自于FreeSound上的创作者rhodesmas和创作者AudioCoffee的开源分享。项目github源码","tags":["GameDev"],"categories":["GameDev"]},{"title":"Node-Express后台应用开发过程记录","path":"/2024/11/21/Express/","content":"快速部署express项目（简单版）主要参考博客 程序版本 操作系统 CentOS7mysql 5.7.44nvm 0.38.0node v22.11.0 Express服务器搭建快速搭建Express服务器-参考博客使用Express应用程序生成器快速创建应用骨架：npx express-generator安装依赖：npm install安装nodemon支持热加载：npm i -g nodemon修改package.json中的scripts的start脚本： scripts: start: nodemon ./bin/www nodemon通过监听项目根目录下的文件变动，自动重启项目修改服务的默认端口（3000）：// app.jsprocess.env.PORT = 8090 // 自定义端口express连接mysql数据库在根目录下创建dataBase文件夹：dataBase api.js 查询数据库接口config.js 数据库配置文件db.js 数据库连接文件config.jsdb.jsapi.jsmodule.exports = db: host: 127.0.0.1, port: 3306, user: root, password: 123456, database: test_db, connectTimeout:10000, useConnectionPool: true, // 连接数据库const mysql = require(mysql)const config = require(./config.js).db// 连接数据库module.exports = mysql.createConnection(config)const connection = require(./db)// 数据库查询const getService = () = return new Promise((resolve, reject) = connection.query(select * from Server, (err,data) = if(err) reject(err) else resolve(data) ) )module.exports = getService 服务器配置MySqlCentOS环境安装Mysql-参考博客常用命令：# 开启mysql服务systemctl start mysqld.service# 进入mysql命令台mysql -u root -p# 配置my.cnfvim /etc/my.cnf还没有账号和密码时，可以在my.cnf中配置跳过密码：#...skip-grant-tables修改过my.cnf文件之后，需要重启mysql服务：service mysqld restart修改Mysql密码参考博客：在CentOs上修改Mysql密码修改默认密码时报【已经设置了跳过密码】的错误需要使用mysql命令行进行修改，进入mysql数据库：use mysql;查询表修改密码：alter user root@localhost identified by NewPassword;最后一定要刷新一下mysql：flush privileges; 服务器配置git参考博客：服务器搭建安装gitGitee每次pull都要输入用户名和密码安装git命令：yum -y install git设置git全局用户名、邮箱地址、密码：git config --global user.name xxxgit config --global user.email xxxgit config --global user.password xxxexpress服务建库提交，考虑到国内网络，选用的是gitee仓库，遇到问题：每次git pull都需要我重新输入用户名和密码，使用命令存储认证信息：git config --global credential.helper store 服务器配置NVM到了坑最多的一步安装参考安装nvm：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.35.3/install.sh | bash安装指定版本的node：nvm install v22.11.0node运行报错问题参考博客：升级gccCentOS7升级GCC版本，解决version GLIBCXX_3.4.21‘ not found解决nvm升级node v18.14.0时lib64libm.so.6: version ‘GLIBC_2.27’ not found (required by node)问题查看node版本：node -v这时出现报错：-bash-4.2# node -vnode: /lib64/libm.so.6: version `GLIBC_2.27 not found (required by node)node: /lib64/libc.so.6: version `GLIBC_2.25 not found (required by node)node: /lib64/libc.so.6: version `GLIBC_2.28 not found (required by node)node: /lib64/libstdc++.so.6: version `CXXABI_1.3.9 not found (required by node)node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20 not found (required by node)node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21 not found (required by node)大概意思就是缺少对应版本的几个lib64下的文件，需要手动安装一下，主要解决方案见参考博客（花很长时间解决好烦） Nginx托管服务主要参考博客 运行Node项目 把代码库拉下来，npm i安装依赖之后，使用pm2进行服务托管：# 全局安装pm2npm i -g pm2# pm2启动应用程序pm2 start npm --name your-server-name# 查看pm2启动服务列表pm2 list在服务器上开放对应的服务端口 Nginx代理配置 server listen 80; server_name cocos-test.e-duck.xyz; location / # 允许跨域 add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods GET, POST, OPTIONS; proxy_set_header X-Real-IP $remote_addr; # 获取用户IP proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection ; # 服务开启的地址 proxy_pass http://127.0.0.1:8090; 其它Express获取请求IP地址需要借助库：IP2Regionnpm i ip2region引入并使用ip2region：const IP2Region = require(ip2region).default;router.get(/welcome,(req,res)= // 需要配合nginx的配置，在x-forwarded-for中提取用户ip let ip = req.headers[x-forwarded-for] || req.ip // 建立新的查询 const query = new IP2Region() // 获取ip地址 /** * * country:中国, * province:XX省, * city:XX市, * isp:移动, * */ const ipAddress = query.search(ip) res.send( code:200, data:ipAddress ))nginx需要修改header配置：server listen 80; server_name xxxxxx; location / # ... proxy_set_header X-Forwarded-For $remote-addr; Nodejs连接数据库频繁掉线问题描述 使用Nodejs连接Mysql时频繁掉线，报错：PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR 解决方法 Node连接Mysql遇到的坑以及踩坑总结"},{"title":"NextJs","path":"/2024/09/24/NextJs/","content":"B站Up：全栈码叔源教程地址 什么是NextJSNextJs Doc中文文档NextJs基于React，reactjs框架的功能比较单一，主要是将html和javascript两者结合使用，NextJs在此之外引入额外的框架功能：CLI运行时文件结构路由静态生成器static generationISRSSRAPIStyleVercel静态托管平台还有另外2个和NextJs比较相似的框架：GatsbyJs：生成静态页面，数据从本机抓取数据整合，通过GraphQL查询服务提供数据NestJS：更加偏向后端，继承了Controller、Service等层级，偏向MVC结构 NextJs框架目录创建项目：npx create-next-app@latestpackage.json脚本命令dev 开发模式启动build 构建生产环境应用start 启动生产环境服务器export 构建静态网站站点原本的next export命令用于构建静态网站站点，现在需要直接在next.config.mjs中配置output：const nextConfig = output:export,;export default nextConfig;这样，在运行npm run build的时候，就会自动生成out目录，下面存放的就是静态资源.next文件.next文件是next项目生产环境下运行的文件，在dev模式下也生成.next文件 静态路由index路由在文件根目录下创建pages文件，在pages文件下创建的子文件可以通过路由进行导航：pagesaboutindex.tsx访问方式：localhost:3000about嵌套路由pagesnewshot.tsx访问方式：localhost:3000newshot 动态路由动态路由 动态路由使用方括号包裹参数pagesnews[newId].tsx在访问路径的时候加入路由：localhost:3000news1通过useRouter路由钩子获取到路由参数：const router = useRouter();const id = router.query.newId动态父级路径作为路径的目录名也可以用动态参数的方式命名，表示父级路径pagesnews[newsId]index.tsxcomment.tsx（访问目标）在访问路径的时候加入路由：localhost:3000news1comment动态嵌套路由路由中不仅仅可以嵌入1个动态参数，可以嵌入多个pagesnews[newsId]index.tsxcommentindex.tsx[commentId].tsx（访问目标）在访问路径的时候加入路由：localhost:3000news1comment1动态params路由动态参数还能包含更多信息：pagesabout[…params].tsx访问路径：localhost:3000about123参数获取方式（数组格式返回）：const router = useRouter();const params = router.query.params // [1,2,3] 运行时动态获取数据模拟后台接口获取数据export default function Recipe() const [data, setData] = useStateany[]([]) // 抓取数据 const fetchData = () = fetch(https://dummyjson.com/recipes) .then(res=res.json()) .then(reply= console.log(reply) setData(reply.recipes) ) useEffect(()= fetchData() ,[]) return ( main ul data.map(item=li key=item.iditem.name/li) /ul /main ) 构建时获取数据预生成静态页面（SSG）页面预构建 SSG SSR和CSR的区别：html诞生之时，就是作为一种从服务器端获取的资源（SSR），但是随着html对灵活性的需求变得越来越大，越来越多的交互逻辑都被放在了浏览器端执行，于是就衍生出了CSR的模式，类似于一家餐厅（服务器）贩卖招牌菜（网页），一开始外卖员（浏览器）来领餐，厨师把菜老老实实做好交到外卖员手里（SSR）后来发现外卖员的料理水平甚至比厨师还强（浏览器专门负责js的运行和渲染），于是厨师干脆就只把料理的食材和食谱（jshtmlcss等其它原料）交给外卖员，叫它现场制作就行了SSR和SSG的区别SSR：服务器端渲染，动态生成html文件返回给用户SSG：服务器端构建，提前生成静态html文件，用户请求时返回爬虫和SEO由于SSR模式下的html文件都是由服务器端生成返回的，爬虫就能直接爬取到其内容中的信息，在SEO优化方面也有更大的优势，这是CSR应用不具有的优势，CSR类似于美食记者（爬虫）想要来这家餐厅用招牌菜（网页）取材， 却只收到食材和一张食谱，完全不知道成品是什么样子服务器端渲染页面，需要在页面中多添加2个异步方法：getStaticPaths用于动态路由页面中，判断哪些路由需要进行与渲染getStaticProps请求预渲染参数props使用props渲染组件，生成html页面 getStaticProps 页面组件接收一个采纳数props，而这个参数由getStaticProps传入export default function Recipe(props:any) // dev模式下，在服务端运行一遍，在客户端运行一遍 console.log(Recipe, props.data) return ( main ul props.data.map((item:any)= li key=item.iditem.name/li) /ul /main )在getStaticProps中获取动态数据，传入组件内，调用组件函数进行渲染：export async function getStaticProps() // 在服务器端运行 console.log(static props) const response = await fetch(https://dummyjson.com/recipes) const reply = await response.json() return ( props: data:reply.recipes, ) getStaticPaths 对于动态路由页面，无法直接在getStaticProps函数中，通过useRouter直接获取到路由参数，因此需要用getStaticPaths，定义静态页面生成的范围，并将路由参信息通过context传入getStaticProps中：getStaticPaths → getStaticProps → CompFunctiongetStaticPaths：export async function getStaticPaths() return paths:[ params:recipeId:1, params:recipeId:2, ], fallback:true, // fallback设置路由参数未匹配上之后的行为 getStaticProps：// getStaticProps函数名称固定export async function getStaticProps(context:any) // 通过getStaticPaths获取到的路由参数 const recipeId = context.params.recipeId const response = await fetch(`https://dummyjson.com/recipes/$recipeId`) const reply = await response.json() console.log(reply) return props: data:reply 构建结果 next build 构建结果构建生成文件 路由跳转 数据预取路由跳转 LinkuseRouterexport default function RouterButton() const router = useRouter() return ( div Link href=/HomeHome/Link button onClick=()=router.back()Back/button button onClick=()=router.push(/login)Login/button /div ) prefetch Linknext提供的Link标签，提供prefetch标签，即预获取目标页面，即根据当前页面中的链接预获取数据，可以根据视口滚动鼠标悬停触发 客户请求时按需生成静态页面服务端按需生成 SSG 动态路由可以进行全量构建：export async function getStaticPaths() // 动态生成url参数 const response = await fetch(https://dummyjson.com/posts) const reply = await response.json() return paths:reply.posts.map((post:any)=( params:postId:post.id.toString() )), fallback: true, 也可以按需生成，配置getStaticPaths返回fallback为true：export async function getStaticPaths() return paths:[], fallback: true, fallback可以有几个值：block 访问未生成静态页面的动态路由时，返回404true 按需生成静态页面 增量更新内容静态生成页面revalidate getStaticProps返回的revalidate，用于控制静态页面刷新周期，export async function getStaticProps() const dt = new Date().toString() const response = await fetch(https://dummyjson.com/posts) const reply = await response.json() return props: data:reply.posts, dt , revalidate:30 // 静态页面缓存周期 设置revalidate之后，静态文件的html请求头中就会多出一个参数,代表缓存时长控制cache-control: s-maxage=30, stale-while-revalidate 服务端渲染 SSRSSR Next中在组件内使用异步方法getServerSideProps，来表示需要服务器端渲染的页面和getStaticProps的不同之处在于，getServerSideProps的router参数context更类似http请求头的格式，包括req、res、params、query等参数，并且可以对res进行自定义响应头配置：export async function getServerSideProps(context:any) const res, query, params = context // 对静态页面的请求头自定义配置 res.setHeader(Set-Cookie, token=xxxxxxx) return ( props: data: [], dt ) 路由传参 和SSG不同，SSR支持通过路由传入任何参数，传参的方式可以是通过路由传入参数，也可以是通过动态路由传参，无论是哪一种，在getServerSideProps中都可以通过context获取到路由参数传参路由文件： products.tsxurl：products?typephonebrandvivo获取到的参数context.query： type: phone, brand: vivo 动态路由传参双方括号，表示就算不传params，也会映射到该文件中路由文件：[[…params]].tsxurl：productsphonevivo获取到的参数context.query： params: [ phone, vivo ] 创建后端API接口API 在pages下创建api目录，下面存放路由映射接口，pagesapiapi目录下创建接口路径：apiproducts.tsimport NextApiRequest, NextApiResponse from next;type Data = dt: string, products: any[]// handler中配置返回值export default async function handler( req: NextApiRequest, res: NextApiResponseData) const dt = new Date().toString() // console.log(dt, method: req.method, query: req.query) const response = await fetch(https://dummyjson.com/products) const reply = await response.json() res.status(200).json( dt, products:reply.products ) 增删改查 handler中，根据字段req.method对请求类型进行判断：export default async function handler( req: NextApiRequest, res: NextApiResponseData) const dt = new Date().toString() console.log(dt, method: req.method, query: req.query) switch(req.method) case POST: productsList.push(req.body) break; case PUT: const index = productsList.findIndex((product:any)=product.id==req.body.id) if(index=0) productsList.splice(index, 1, req.body) break; case DELETE: const index = productsList.findIndex((product:any)=product.id==req.body.id) if(index=0) productsList.splice(index, 1) break; default: break; res.status(200).json( total: productsList.length, products: productsList ) 页面全局页面布局设置pages layoutsNext.js v13推出了App Router作为新的路由解决方案：- app - template.tsx - layout.tsx - page.tsx - news - template.tsx - layout.tsx - page.tsx其中template和layout都提供了公共的布局方法，不同点在于：layout，相当于多个子页面共享一个父布局template，相当于为多个子页面创建相同的布局 页面辅助信息设置 在page或者layout中设置metadata变量，作为对header头的补充或者覆盖设置，常用来优化SEO搜索引擎import Metadata from next export const metadata: Metadata = title: Next.js, export default function Page() return ... use client Next默认app下的所有pages都是由服务器端渲染的，因此一些React的Hook无法使用，需要在页面的第一行加上注释：use client 发布到第三方托管平台部署 Vercel将静态文件托管在Vercel平台的方法虽然很简单，但是国内基本是无法访问到Vercle托管的站点的官网部署指导 部署问题报错：服务端无法调用客户端api ReferenceError: document is not defined官方解决方法github issue解决方法页面使用dynamicssr引入组件动态引入组件，可以根据ssr的配置判断是否在服务器端引入组件使用use client声明为客户端组件Page 页面Component 子组件import dynamic from next/dynamicconst Component = dynamic(()=import(./Component),ssr:false)export function Page() return ( Component// )use clientexport function Component() return (div子组件/div) NextJs开发文档目录结构Next.js Project Structure 官方文档 API参考函数FunctiongenerateMetadata参考文章：generateMetadata官方文档Next.js 为什么使用metadata取代了Head组件？generateViewport官方文档next定义静态页面的metadata：// metadata 头部元数据设置export const metadata: Metadata = title: Next Lab, description: Next + Three Lab,;// viewport 视口设置export const viewport: Viewport = themeColor:black, width:320.1, initialScale:1, minimumScale:1, maximumScale:1, userScalable:false,export default function RootLayout( children, : Readonly children: React.ReactNode;) return ( html lang=en meta name=theme-color content=#000/ body className=`$geistSans.variable $geistMono.variable` children /body /html );","tags":["Web"]},{"title":"前端项目工程化配置指南","path":"/2024/09/19/FrontDevEnv/","content":"Webpack5 + React18 + Ts 开发和打包环境图源自原博客作者 参考博客 webpack loader介绍 初始化项目初始化package.json初始化package.json文件 创建新项目的空目录文件webpack-react-ts，在目录文件下打开cmd控制台，执行初始化命令：npm init -ynpm init命令介绍 初始化目录结构手动创建目录结构 ├── build | ├── webpack.base.js # 公共配置| ├── webpack.dev.js # 开发环境配置| └── webpack.prod.js # 打包环境配置├── public│ └── index.html # html模板├── src| ├── App.tsx # 根组件│ └── index.tsx # react应用入口页面├── tsconfig.json # ts配置└── package.json 安装依赖安装依赖 webpack依赖npm i webpack webpack-cli -Dreact依赖npm i react react-dom -Sreact类型依赖npm i @types/react @types/react-dom -D 添加网页根html模版添加网页根html模版 publicindex.html !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titlewebpack-react-ts/title/headbody !-- 容器节点 -- div id=root/div/body/html 配置tsconfig.json文件配置tsconfig.json文件 配置指南 compilerOptions: target: ESNext, lib: [DOM, DOM.Iterable, ESNext], allowJs: false, skipLibCheck: false, esModuleInterop: false, allowSyntheticDefaultImports: true, strict: true, forceConsistentCasingInFileNames: true, module: ESNext, moduleResolution: Node, resolveJsonModule: true, isolatedModules: true, noEmit: true, jsx: react , include: [./src] 初始化srcApp.tsx和srcindex.tsx内容初始化srcApp.tsx和srcindex.tsx内容 srcindex.tsx是入口文件import React from reactimport createRoot from react-dom/clientimport App from ./Appconst root = document.getElementById(root)if(root) createRoot(root).render(App/)srcApp.tsx是根组件import React from react;function App() return h2Webpack React Ts/h2export default App 配置基础版React+ts环境webpack公共环境buildwebpack.base.js 配置入口文件 entry配置出口文件 output配置loader解析ts和jsx，需要安装依赖：babel-loader@babelcore@babelpreset-react jsx解析器@babelpreset-typescript ts解析器npm i babel-loader @babel/core @babel/preset-react @babel/preset-typescript -D配置文件后缀 resolve将静态资源引入html文件，需要安装依赖html-webpack-pluginnpm i html-webpack-plugin -Dconst path = require(path)const HtmlWebpackPlugin = require(html-webpack-plugin);module.exports = // 1. 入口文件 entry: path.join(__dirname,../src/index.tsx), // 2. 打包文件出口 output: filename: static/js/[name].js, // 每个输出js的名称 path: path.join(__dirname, ../dist), // 打包结果 clean: true, publicPath: /, // 打包后文件的公共前缀路径 , // 3. loader解析ts和jsx module: rules:[ test: /.(ts|tsx)$/, // 匹配ts、tsx文件 use: loader: babel-loader, options: // 预设执行从右向左 presets:[ @babel/preset-react, @babel/preset-typescript ] ] , // 4. 文件引用后缀配置 resolve: extensions: [.js, .tsx, ,ts] , // 5. 添加html插件 plugins: [ new HtmlWebpackPlugin( template:path.resolve(__dirname, ../public/index.html), // 设置模版 inject:true, // 是否自动注入 ), ] webpack开发环境配置buildwebpack.dev.js 配置开发环境需要额外安装2个库：webpack-dev-server 开发环境中启动服务器webpack-merge 合并webpack.base.js基本配置npm i webpack-dev-server webpack-merge -D修改webpack.dev.js文件：const path = require(path);const merge = require(webpack-merge)const baseConfig = require(./webpack.base)// 合并公共配置，添加开发环境配置module.exports = merge(baseConfig, mode: development, // 开发模式，加速打包 devtool: eval-cheap-module-source-map, // 源码调试结构 devServer: // 服务器配置 port: 3000, // 服务端口号 compress: false, // gzip压缩 hot: true, // 开启热更新 historyApiFallback: true, // static: directory: path.join(__dirname, ../public) // 托管静态资源public文件夹 )在package.json中添加dev脚本： scripts: dev: webpack-dev-server -c build/webpack.dev.js 控制台执行dev启动命令：npm run dev webpack打包环境配置buildwebpack.prod.js 修改webpack.prod.js配置文件：const merge = require(webpack-merge)const baseConfig = require(./webpack.base)module.exports = merge(baseConfig, mode:production,// 开启生产环境)添加build脚本： scripts: build: webpack -c build/webpack.prod.js 执行打包命令npm run build可以通过serve启动打包好的项目：npm i serve -gserve -s dist 基础功能配置配置环境变量环境变量分类 按照模式开发环境生产环境区分方式：process.env.NODE_ENV按照项目业务环境开发环境测试环境预测环境正式环境 区分项目接口环境方式 设置一个环境变量 process.env.BASE_ENV设置方式：cross-env 兼容各系统设置环境变量的包webpack.DefinePlugin webpack内置，为业务代码注入环境变量安装cross-env：npm i cross-env -D修改package.json里的脚本： scripts: dev:dev: cross-env NODE_ENV=development BASE_ENV=development webpack-dev-server -c build/webpack.dev.js, dev:test: cross-env NODE_ENV=development BASE_ENV=test webpack-dev-server -c build/webpack.dev.js, dev:pre: cross-env NODE_ENV=development BASE_ENV=pre webpack-dev-server -c build/webpack.dev.js, dev:prod: cross-env NODE_ENV=development BASE_ENV=production webpack-dev-server -c build/webpack.dev.js, build:dev: cross-env NODE_ENV=production BASE_ENV=development webpack -c build/webpack.prod.js, build:test: cross-env NODE_ENV=production BASE_ENV=test webpack -c build/webpack.prod.js, build:pre: cross-env NODE_ENV=production BASE_ENV=pre webpack -c build/webpack.prod.js, build:prod: cross-env NODE_ENV=production BASE_ENV=production webpack -c build/webpack.prod.js 在执行脚本时，会将用于判断环境的参数传入webpack的配置文件中，webpack可以根据参数进行不同的配置：process.env.NODE_ENV // 模式参数process.env.BASE_ENV // 业务参数直到这一步，传入的参数只能在webpack配置文件中获取到，要想在业务代码中用到参数，需要使用webpack.DefinePlugin，将参数注入到业务代码中去：const webpack = require(webpack);module.exports = plugins:[ new webpack.DefinePlugin( process.env.BASE_ENV:JSON.stringify(progress.env.BASE_ENV) ) ] cssless配置如何解析css 对css的解析需要用到loader：style-loader 把解析后的css代码抽离放到头部的style标签css-loader 解析css文件npm i style-loader css-loader -D将loader配置到webpack.base.js中：module.exports = module: rules:[ // 配置css文件 test: /\\.css$/, use:[style-loader, css-loader] ] 注意，loader会从右向左引入，这里的顺序不能改变，因为需要先编译css代码，再将css部分嵌入到style里 less 需要用到2个包：less-loader 把less编译为css less 核心npm i less less-loader -D把less-loader加入到之前的css配置部分：module.exports = module: rules:[ // 配置css/less文件 test: /\\.(css|less)$/, use:[style-loader, css-loader,less-loader] ] 处理css3前缀兼容性在css3还没有普及的时候，各家浏览器通过“实验属性”的方式对特性进行实现，并在自家实现的属性前挂上浏览器的标识，导致为了实现同一个属性，要写好几个版本postcss就是为了解决这个问题而实现的，虽然现在大部分的主流浏览器都没有这个问题，但还是存在需要兼容低版本浏览器的情况存在，这里就可以使用postcss-loader，需要引入2个库：postcss-loader 处理css的前缀autoprefixer 决定需要兼容哪些浏览器npm i postcss-loader autoprefixer -D可以将postcss单独放到根目录里配置：在根目录中添加postcss.config.js文件module.exports = plugins: [autoprefixer]再添加autoprefixer配置文件.browserslistrcIE 9 # 兼容IE 9chrome 35 # 兼容chrome 35然后将postcss-loader配置到webpack中module.exports = module: rules:[ // 配置css/less文件 test: /\\.(css|less)$/, use:[style-loader, css-loader, postcss-loader, less-loader] ] babel处理js兼容babel可以用来转换js的版本，也能将不标准的js转换为标准的js，需要安装下面的库：babel-loader 使用babel加载最新js并转换为ES5@babelcorebabel编译的核心包@babelpreset-env编译预设，转换目前最新的js标准语法core-js使用低版本js语法模拟高版本的库，垫片npm i babel-loader @babel/core @babel/preset-env core-js -D在根目录添加babel.config.js，进行配置：module.exports = // 处理顺序： // 1. 处理ts // 2. 处理jsx // 3. babel转换 presets:[ [ @babel/preset-env, //设置浏览器版本，优先使用.browserslistrc， // targets: // ie: 9, // chrome: 35, // , useBuiltIns: usage, // 按需添加 corejs: 3 // 版本 ], @babel/preset-react, @babel/preset-typescript ]将babel添加到webpack配置中：module.exports = module: rules:[ test: /.(ts|tsx)$/, // 匹配ts、tsx文件 use:babel-loader ] 复制public文件夹public文件夹下一般放一些静态资源，比如图片、全局css等，在dev模式下，可以通过托管配置，直接通过绝对路径访问到public文件下的资源：module.exports = merge(baseConfig, devServer: static: directory: path.join(__dirname, ../public) )但在build模式下，需要将public文件内容直接复制到构建出口文件夹中需要用到copy-webpack-plugin插件：npm i copy-webpack-plugin -D在webpack.prod.js中进行文件源、复制目标、过滤器等配置：const path = require(path);const merge = require(webpack-merge)const baseConfig = require(./webpack.base)const CopyPlugin = require(copy-webpack-plugin)module.exports = merge(baseConfig, mode:production,// 开启生产环境 plugins:[ // 复制文件插件 new CopyPlugin( patterns:[ from: path.resolve(__dirname, ../public), to: path.resolve(__dirname, ../dist/public), filter: source = return !source.includes(index.html) ] ) ]) 处理图片文件使用asset-module进行处理，在webpack.base.js中进行配置：module.exports = module: rules:[ // 配置图片文件 test: /.(png|jpg|jpeg|gif|svg)$/, type: asset, parser: dataUrlCondition: // 小于10kb，转base64位 maxSize: 10 * 1024, , generator: filename:static/images/[name][ext] // 文件输出目录和命名 ] 字体和媒体文件字体和媒体文件与图片的配置基本相似：module.exports = module: rules:[ test:/.(woff2?|eot|ttf|otf)$/, type:asset, parser: dataUrlCondition: maxSize: 10 * 1024, , generator: filename:static/fonts/[name][ext], , test:/.(mp4|webm|ogg|mp3|wav|flac|aac)$/, type:asset, parser: dataUrlCondition: maxSize: 10 * 1024, , generator: filename:static/media/[name][ext], , ] react热更新使用webpack中，devServer.hot开启的热更新方式是直接刷新浏览器，因此会导致数据状态的丢失，要想不刷新浏览器，进行模块热更新，可以借助插件：@pmmmwhreact-refresh-webpack-pluginreact-refreshnpm i @pmmmwh/react-refresh-webpack-plugin react-refresh -D在webpack.dev.js中配置热更新插件：const ReactRefreshWebpackPlugin = require(@pmmmwh/react-refresh-webpack-plugin)module.exports = merge(baseConfig, plugins:[ new ReactRefreshWebpackPlugin(), // 添加热更新插件 ])需要在babel.config.js中更新插件，并且需要对环境进行判断，尽在开发环境下开启：const isDEV = process.env.NODE_ENV === development;module.exports = plugins:[ isDEV require.resolve(react-refresh/babel), ].filter(Boolean), // 过滤空值 优化构建速度构件耗时分析需要借助到一个插件：npm i speed-measure-webpack-plugin -D构建分析配置文件webpack.analy.js：const prodConfig = require(./webpack.prod)const SpeedMeasurePlugin = require(speed-measure-webpack-plugin)const smp = new SpeedMeasurePlugin() // 实例化分析插件const merge = require(webpack-merge)// 加入生产环境配置，和分析配置module.exports = smp.wrap(merge(prodConfig,))添加package.json脚本并执行： scripts: build:analy: cross-env NODE_ENV=production BASE_ENV=production webpack -c build/webpack.analy.js 控制台输出结果：PS D:\\webpack-react-ts npm run build:analyActive code page: 65001 webpack-react-ts@1.0.0 build:analy cross-env NODE_ENV=production BASE_ENV=production webpack -c build/webpack.analy.js(node:6120) [DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK] DeprecationWarning: Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader(Use `node --trace-deprecation ...` to show where the warning was created) SMP ⏱ # 总运行时间General output time took 6.063 secs SMP ⏱ Plugins # 插件运行时间HtmlWebpackPlugin took 0.259 secsCopyPlugin took 0.189 secsDefinePlugin took 0.007 secs SMP ⏱ Loaders # 解析器运行时间babel-loader took 1.52 secs module count = 2css-loader, andpostcss-loader, andless-loader took 1.27 secs module count = 1modules with no loaders took 0.885 secs module count = 156html-webpack-plugin took 0.014 secs module count = 1style-loader, andcss-loader, andpostcss-loader, andless-loader took 0.012 secs module count = 1assets by path static/ 195 KiB asset static/js/main.js 177 KiB [emitted] [minimized] (name: main) 1 related asset asset static/images/toby_dog.jpg 18.5 KiB [compared for emit] [from: src/assets/imgs/toby_dog.jpg] (auxiliary name: main)asset public/toby_dog.jpg 18.5 KiB [compared for emit] [from: public/toby_dog.jpg] [copied]asset index.html 314 bytes [compared for emit]runtime modules 1000 bytes 6 modulesorphan modules 5.59 KiB [orphan] 3 modulesmodules by path ./node_modules/core-js/internals/*.js 80.4 KiB 121 modulesmodules by path ./node_modules/core-js/modules/*.js 30 KiB 17 modulesmodules by path ./node_modules/style-loader/dist/runtime/*.js 5.84 KiB 6 modulesmodules by path ./src/ 6.37 KiB (javascript) 18.5 KiB (asset) 3 modulesmodules by path ./node_modules/react-dom/ 131 KiB 3 modulesmodules by path ./node_modules/react/ 6.95 KiB 2 modulesmodules by path ./node_modules/scheduler/ 4.33 KiB ./node_modules/scheduler/index.js 198 bytes [built] [code generated] ./node_modules/scheduler/cjs/scheduler.production.min.js 4.14 KiB [built] [code generated]modules by path ./node_modules/css-loader/dist/runtime/*.js 2.31 KiB ./node_modules/css-loader/dist/runtime/noSourceMaps.js 64 bytes [built] [code generated] ./node_modules/css-loader/dist/runtime/api.js 2.25 KiB [built] [code generated]webpack 5.94.0 compiled successfully in 6066 ms 开启持久化存储缓存webpack4中文件缓存：使用babel-loader缓存js解析结果cache-loader缓存css等资源解析结果模块缓存插件hard-source-webpack-plugin二次打包时会对文件做哈希对比验证文件前后是否一致webpack5对缓存策略进行优化：增加了持久化缓存改进了缓存算法在webpack.base.js中配置开启缓存策略module.exports = cache: type:filesystem, // 使用文件缓存 缓存位置：node_modules.cachewebpack 开启多线程loader开启多线程loader 开启多线程loader可以借助多核cpu开启多线程loader解析，需要安装依赖：npm i thread-loader -D使用时，需要将thread-loader放置在其他loader之前，在它之后的loader会在一个独立的worker池中运行开启多线程需要启动时间，适合规模较大的项目 配置alias别名配置别名可以降低项目开发中资源引用的复杂度webpack.base.js配置：module.exports = resolve: alias: @:path.join(__dirname, ../src) tsconfig.json配置： baseUrl: ., paths: @/*: [ src/* ] 资源的路径调用：import logo from @/assets/imgs/logo.png 缩小loader作用范围includeexclude 可以通过2个属性，来对loader解析的范围进行限制：include 只解析改配置的模块exclude 不解析的模块 精确使用loaderloader会在webpack构建模块依赖关系引入新文件时执行，通过test对文件名称进行正则匹配，如果匹配到了，就从右向左依次执行use中的loader，可以更精确的根据文件的后缀，区分需要执行的loader，比如，可以将css和less拆分，以减少css收到less-loader处理的这一步：module.exports = module: rules:[ // 配置css文件 include: [path.resolve(__dirname, ../src)], test: /\\.css$/, use:[style-loader, css-loader, postcss-loader] , // 配置less文件 include: [path.resolve(__dirname, ../src)], test: /\\.less$/, use:[style-loader, css-loader, postcss-loader, less-loader] , ] 缩小模块搜索范围Node中存在3中模块：node核心模块node_modules模块自定义文件模块在项目中如果没有指定准确的路径，引入模块时，查找顺序如下：优先查询node核心模块当前目录下node_modules祖辈目录的node_modulesnode全局模块如果是追溯到了node全局模块的情况，开发环境和生产环境的node全局可能不一样，因此要避免这种情况，将查找的范围局限在项目目录下，在webpack.base.js中配置：module.exports = resolve: modules: [path.resolve(__dirname, ../node_modules)], devtool配置开发调试时需要看到源代码，生产模式下则是编译后的代码，这就需要SourceMap进行转换，devtool就是用来控制SourceMap的生成的：webpack.dev.jsmodule.exports = merge(baseConfig, devtool: eval-cheap-module-source-map, // 源码调试结构) 优化构建结果文件webpack包分析工具webpack-bundle-analyzer 需要借助库：npm install webpack-bundle-analyzer -D在webpack.analy.js中加入插件相关的配置：const BundleAnalyzerPlugin = require(webpack-bundle-analyzer)// 加入生产环境配置，和分析配置module.exports = smp.wrap(merge(prodConfig, plugins:[ new BundleAnalyzerPlugin() ])) 抽取css样式文件css文件在不同的环境下有不同的优化策略：开发环境下，使用style标签嵌入方便热更新替换生产环境下，将css文件单独打包方便缓存策略这里需要用到插件：npm i mini-css-extract-plugin -D在开发模式下使用style-loader，抽取css，webpack.base.js：const isDev = process.env.NODE_ENV === developmentconst MiniCssExtractPlugin = require(mini-css-extract-plugin);module.exports = module: rules:[ // 配置css文件 include: [path.resolve(__dirname, ../src)], test: /\\.css$/, use:[ // 开发环境使用style-loader， 打包模式抽取css isDev?style-loader:MiniCssExtractPlugin.loader, css-loader, postcss-loader ] , // 配置less文件 include: [path.resolve(__dirname, ../src)], test: /\\.less$/, use:[ isDev?style-loader:MiniCssExtractPlugin.loader, css-loader, postcss-loader, less-loader ] ] 打包时，使用MiniCssExtractPlugin进行抽离：const MiniCssExtractPlugin = require(mini-css-extract-plugin);module.exports = merge(baseConfig, mode:production,// 开启生产环境 plugins:[ // 抽离css插件 new MiniCssExtractPlugin( filename: static/css/[name].css ) ]) 压缩css文件css-minimizer-webpack-plugin 下载css压缩插件npm i css-minimizer-webpack-plugin -D在webpack.prod.js中进行配置：const CssMinimizerPlugin = require(css-minimizer-webpack-plugin)module.exports = merge(baseConfig, optimization: minimizer:[ new CssMinimizerPlugin(), // 压缩css ] ) 压缩js文件安装terser-webpack-plugin插件：npm i terser-webpack-plugin -D修改webpack.prod.js配置const TerserPlugin = require(terser-webpack-plugin)module.exports = merge(baseConfig, optimization: minimizer:[ new TerserPlugin( // 压缩js parallel: true, // 开启多线程压缩 terserOptions: compress: pure_funcs: [console.log] // 删除console.log ) ] ) 合理配置打包文件hashhash是浏览器缓存策略中重要的一部分，webpack提供三种hash：hash全部文件共用相同的hash值项目文件只要修改，项目构建的hash值就会改变chunkhash对不同的入口文件进行依赖解析，构建对应chunk，生成相应哈希值文件本身修改或者依赖文件修改，chunkhash会变化contenthash每个文件都有自己的哈希值配置hash值的格式如下：filename: [name].[chunkhash:8][ext]ext 文件后缀name 文件名path 文件相对路径folder 文件夹hash 每次构建生成的唯一hash值chunkhash 根据chunk生成hash值contenthash 根据文件内容生成hash值一般用于图片、css等资源文件的哈希值生成在webpack.base.js中对生成的文件名称进行hash映射配置：module.exports = // 出口文件 output: filename: static/js/[name].[chunkhash:8].js, // 每个输出js的名称 , module: rules:[ // 配置图片文件 test: /.(png|jpg|jpeg|gif|svg)$/, generator: filename:static/images/[name].[contenthash:8][ext] // 文件输出目录和命名 , test:/.(woff2?|eot|ttf|otf)$/, generator: filename:static/fonts/[name].[contenthash:8][ext], , test:/.(mp4|webm|ogg|mp3|wav|flac|aac)$/, generator: filename:static/media/[name].[contenthash:8][ext], , ] 在构建模式中，对被抽离出来css文件也进行hash映射：module.exports = merge(baseConfig, plugins:[ new MiniCssExtractPlugin( filename: static/css/[name].[contenthash:8].css ) ]) 代码分割第三方包和公共模块node_modules中的代码变化频率一般比较小，可以单独打包，对应的chunkhash值很少变化。同样的，还有一些公共模块，由于很少变化，也可以单独分割出来。这需要在webpack.prod.js中进行配置：module.exports = merge(baseConfig, optimization: // 分隔代码 splitChunks: cacheGroups: vendors: // 提取node_modules代码 test: /node_modules/, // 只匹配node_modules中的模块 name: vendors, // 提取文件命名为vendors, js后缀和chunkhash会自动加 minChunks: 1, // 只要使用一次就提取出来 chunks: initial, // 只提取初始化就能获取到的模块，不管异步的 minSize: 0, // 目标代码体积大于0就提取出来 priority: 1, // 提取优先级为1 , commons: // 提取页面公共代码 name: commons, // 提取文件命名为commons minChunks: 2, // 只要使用两次就提取出来 chunks: initial, // 只提取初始化就能获取到的模块，不管异步的 minSize:0, // 目标代码体积大于0就提取出来 ) tree-shaking清理未使用的jscsswebpack内置tree-shaking，在进行prod打包时将没有使用的js清除掉对于没有用到的css的清理，则需要额外安装库：purgecss-webpack-pluginglob-all 选择要检测那些文件里面的类型、id还有标签名称npm i purgecss-webpack-plugin glob-all -D在webpack.prod.js中进行配置const PurgeCSSPlugin = require(purgecss-webpack-plugin)const globAll = require(glob-all)module.exports = merge(baseConfig, plugins:[ // 清理无用css new PurgeCSSPlugin( // 检测src下所有tsx文件和public下index.html中使用到的类名、id、标签 //只打包这些文件中用到的样式 paths: globAll.sync([ `$path.join(__dirname,../src)/**/*.tsx`, path.join(__dirname,../public/index.html) ]), // 自定义白名单 safelist: standard:[/^ant-/], // 过滤以ant-开头的类名 ) ]) 资源懒加载react提供懒加载组件，webpack默认支持资源懒加载，资源在需要使用的时候进行动态加载组件的懒加载：import React, lazy, Suspense, useState from react;const LazyDemo = lazy(()=import(@/components/LazyDemo))function App() return ( Suspense fallback=nullLazyDemo//Suspense / ) 资源预加载关于link标签的ref属性：preload 资源必要，浏览器一定会加载prefetch资源可能需要，浏览器空闲时加载webpack中支持在import时，使用注释进行预获取预加载配置：// 单个目标import( /* webpackChunkName: my-chunk-name */ // 资源打包后的文件chunkname /* webpackPrefetch: true */ // 开启prefetch预获取 /* webpackPreload: true */ // 开启preload预加载 ./module ) 打包时生成gzip文件nginx可以通过配置gzip:on开启压缩，但是会消耗服务器的资源，因此可以在前端构建生产项目时，就对内容进行gzip压缩。需要用到插件：npm i compression-webpack-plugin -D在webpack.prod.js中添加配置：const CompressionPlugin = require(compression-webpack-plugin);module.exports = merge(baseCofig, plugins:[ // 打包压缩配置 new CompressionPlugin( test: /.(js|css)$/, // 只生成css、js的压缩文件 filename:[path][base].gz, // 文件命名 algorithm: gzip, // 压缩格式 threshold: 10240, // 最小压缩尺寸 minRatio: 0.8, // 压缩率 ) ]) React + Ts 项目开发代码规范参考博客 editorconfig统一编辑器配置在VSCode编辑器里，添加editorconfig需要安装EditorConfig for VSCode插件在项目根目录里添加.editorconfig配置文件：root = true # 控制配置文件 .editorconfig 是否生效的字段[**] # 匹配全部文件indent_style = space # 缩进风格，可选space｜tabindent_size = 2 # 缩进的空格数charset = utf-8 # 设置字符集trim_trailing_whitespace = true # 删除一行中的前后空格insert_final_newline = true # 设为true表示使文件以一个空白行结尾end_of_line = lf[**.md] # 匹配md文件trim_trailing_whitespace = falseeditorconfig一般用于规范项目中的缩进风格 Prettier在IDE插件中安装Prettier在项目根目录中添加.prettierrc.js配置文件，用于对代码进行格式化处理module.exports = printWidth: 100, // 一行的字符数，如果超过会进行换行 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 是否启用tab取代空格符缩进，.editorconfig设置空格缩进，所以设置为false semi: false, // 行尾是否使用分号，默认为true singleQuote: true, // 字符串是否使用单引号 trailingComma: none, // 对象或数组末尾是否添加逗号 none| es5| all jsxSingleQuote: true, // 在jsx里是否使用单引号，你看着办 bracketSpacing: true, // 对象大括号直接是否有空格，默认为true，效果： foo: bar arrowParens: avoid, // 箭头函数如果只有一个参数则省略括号在webstorm中，需要首先安装prettier包：npm install --save-dev --save-exact prettier在设置prettier中，将prettier指向本地npm包里的prettier，开启run on save，这样在保存项目时就会自动执行prettier格式化代码 eslint + lint-staged监测代码项目安装eslint依赖npm i eslint -D配置.eslintrc.js文件，使用快捷命令：npm init @eslint/config根据控制台问题的回答情况，最终会生成一个eslint.config.js文件：import globals from globals;import pluginJs from @eslint/js;import tseslint from typescript-eslint;import pluginReact from eslint-plugin-react;export default [ files: [**/*.js,mjs,cjs,ts,jsx,tsx], languageOptions: globals: globals.browser , pluginJs.configs.recommended, ...tseslint.configs.recommended, pluginReact.configs.flat.recommended,];","tags":["Web"]},{"title":"NestJs","path":"/2024/07/01/NestJs/","content":"官方基础课程（快速体验）快速创建nest项目全局安装nestnpm i -g nest快速创建nest项目nest new创建出来目录结构：main.js 主入口app.module.ts 创建的控制器会被controllers集成app.service.tsapp.controller.ts生成controllernest generate controller controllerNamenest g co controllerNamenuxt开发时热更新命令：npm run start:dev 控制器 Controller@Controller定义映射器类coffee@Controller(coffee)export class CoffeeController // 控制器的内部实现@Getcoffeeflavors@Controller(coffee)export class CoffeeController // 路径映射 @Get(flavors) findAll() return You find all coffees @Paramcoffee123456@Controller(coffee)export class CoffeeController // 带参数映射 @Get(:id) // findOne(@Param() params) // 获取所有params参数 findOne(@Param(id) id: string) // 获取指定paran参数 return `get #$id coffee` @Post@Body@HttpCodecoffeecreate@Controller(coffee)export class CoffeeController // post请求 @Post() @HttpCode(HttpStatus.BAD_GATEWAY) // 自定义状态码 // Body参数 // create(@Body() body) // 获取特定的属性 create(@Body(message) body) return body; @Rescoffeeyummy@Controller(coffee)export class CoffeeController // 直接调用express库方法 @Get(candy) yummy(@Res() response) response.status(200).send(yummy candy) @Patch更新数据coffee1234@Controller(coffee)export class CoffeeController // patch 更新 @Patch(:id) update(@Param(id) id: string, @Body() body) return message:`This action updates #$id coffee`, data:body @Delete删除数据coffee1234@Controller(coffee)export class CoffeeController @Delete(:id) remove(@Param(id) id:string) return `delete #$id` 服务 Service|Provider创建Service nest generate servicenest g sservice会被创建在src对应路径下，同时更新在app.modules.ts下的providers数组中每个Service都是一个provider，provider内可以注入依赖provider可以作为依赖被注入到controller中service负责处理数据存储、检索等工作，为controller提供数据。 entity 创建实体，作为service控制的对象：nest中将controller和service集成在同一个目录下，entity实体也创建在此目录下。srccoffeeentitiescoffee.entity.tsexport class Coffee id: number; name: string; brand: string; flavors: string[]; Controller+Service实现CRUD import Injectable from @nestjs/common;import Coffee from ./entities/coffee.entity;// @Injectable标识表示service@Injectable()export class CoffeeService private coffees: Coffee[] = [ id: 1, name: Shipwreck Roast, brand: Buddy Brew, flavors: [chocolate, vanilla], , ]; /** * 查找全部 */ findAll()return this.coffees /** * 根据id返回指定值 * @param id */ findOne(id:string) return this.coffees.find(item=item.id === +id) /** * 新建 * @param createCoffeeDto */ create(createCoffeeDto: any) this.coffees.push(createCoffeeDto); return this.coffees /** * 更新 * @param id * @param updateCoffeeDto */ update(id: string,updateCoffeeDto: any) const existingCoffee = this.findOne(id) if(existingCoffee) // update this entoty Object.assign(existingCoffee, updateCoffeeDto) return existingCoffee return cant find /** * * @param id 删除 */ remove(id:string) const coffeeIndex = this.coffees.findIndex(item=item.id == + id) if(coffeeIndex = 0) this.coffees.splice(coffeeIndex,1) 在controller中通过构造函数，注入service：@Controller(coffee)export class CoffeeController // service/provider注入 constructor(private readonly coffeeService) // 查询所有 @Get(findAll) findAll() return this.coffeeService.findAll() // 指定查询 @Get(:id) // findOne(@Param() params) // 获取所有params参数 findOne(@Param(id) id: string) return this.coffeeService.findOne(id) // 新增 @Post() create(@Body() body) return this.coffeeService.create(body); // 更新 @Patch(:id) update(@Param(id) id: string, @Body() body) return this.coffeeService.update(id,body) // 删除 @Delete(:id) remove(@Param(id) id:string) return this.coffeeService.remove(id) a hrefhttps://docs.nestjs.cn/10/exceptionfilters?id=%e5%9f%ba%e7%a1%80%e5%bc%82%e5%b8%b8%e7%b1%bb异常过滤器 @Injectable()export class CoffeeService findOne(id: string) const coffee = this.coffees.find(item = item.id === +id) if (!coffee) // 抛出对应网络异常 // throw new HttpException(`Coffee #$id not found`, HttpStatus.NOT_FOUND) throw new NotFoundException(`Coffee #$id not found`) return coffee 模块 Modulemodule 集成modulenest g module moduleName在app.modules.ts横纵的imports内会自动引入新创建的Module使用module将controllers和providers集成在一起：import Module from @nestjs/common;import CoffeeController from ./coffee.controller;import CoffeeService from ./coffee.service;@Module( controllers:[CoffeeController], providers:[CoffeeService] )export class CoffeeModule 将app.module.ts的代码清理一下，保证controller和service仅被实例化一次：import Module from @nestjs/common;import AppController from ./app.controller;import AppService from ./app.service;import CoffeeModule from ./coffee/coffee.module;@Module( imports: [CoffeeModule], controllers: [AppController], providers: [AppService],)export class AppModule DTOdata transfer object用于封装规范接口传输的数据类型生成DTOnest g class classNamenest g class coffee/dto/create-coffee.dto --no-specdto的定义：create-coffee.dto.tsexport class CreateCoffeeDto readonly name: string; readonly brand: string; readonly flavors: string[];dto的使用：coffee.controller.ts@Controller(coffee)export class CoffeeController constructor(private readonly coffeeService: CoffeeService) @Post() create(@Body() createCoffeeDto:CreateCoffeeDto) return this.coffeeService.create(createCoffeeDto) 数据验证 数据验证要用到ValidationPipe需要下载如下包：npm i class-validator class-transformer @nestjs/mapped-types在main.ts中加入pipewhitelist 白名单模式forbidNonWhitelisted 非白名单数据报错transform 将传入数据转化为指定的数据类型import NestFactory from @nestjs/core;import AppModule from ./app.module;import ValidationPipe from @nestjs/common;async function bootstrap() const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe( whitelist:true, forbidNonWhitelisted: false, transform: true, )) // 配置验证管道 await app.listen(3000);bootstrap();在DTO中加入数据验证描述符：// create-coffee.dto.tsimport IsString from class-validatorexport class CreateCoffeeDto @IsString() readonly name: string; @IsString() readonly brand: string; @IsString(each:true) readonly flavors: string[];使用mapped-types包，实现数据验证的继承与附加属性配置：import PartialType from @nestjs/mapped-typesimport CreateCoffeeDto from ../create-coffee.dto/create-coffee.dto;// PartialType用于给将每个属性变为可选值 @IsOptional()// 同时继承装饰器类型export class UpdateCoffeeDto extends PartialType(CreateCoffeeDto) Docker根目录下配置docker-compose.yml文件：version: 3services: db: image: postgres restart: always ports: - 5432:5432 environment: POSTGRES_PASSWORD: ashley122 启动镜像：docker-compose up -ddocker拉取镜像地址 registry-mirrors: [https://dockerhub.icu] ORM安装orm相关包：@nestjstypeorm typeormpg postgres相关包npm i @nestjs/typeorm typeorm pgapp.module.ts中引入TypeOrmModule：import TypeOrmModule from @nestjs/typeorm;@Module( imports: [ CoffeeModule, CakeModule, TypeOrmModule.forRoot( type: postgres, host: localhost, port: 5432, username:postgres, password:ashley122, database:postgres, autoLoadEntities:true, // 仅用于开发环境，生产环境中尽量关闭 synchronize:true, // 实体与数据库同步 ) ], controllers: [AppController], providers: [AppService],)将之前仅作为接口类型约束的entities下的实体定义文件，进行ORM模型化：import Entity, PrimaryGeneratedColumn, Column from typeorm// 实体类描述符@Entity(cake)export class Cake // 主键描述符 @PrimaryGeneratedColumn() id: number; @Column() name: string; @Column() price: number; // 可空描述 @Column(json, nullable:true) flavors: string[];在cake子模块中注册内部实现的实体：@Module( // 每个子模块为自己注册实体 imports:[TypeOrmModule.forFeature([Cake])], controllers:[CakeController], providers:[CakeService])export class CakeModule repository 创建好Entity之后，ORM模型会自动映射成为数据库表，在service中作为数据库进行关联：@Injectable()export class CakeService // 关联数据库 constructor( // 数据库注入 @InjectRepository(Cake) private readonly cakeRepository: RepositoryCake ) 将之前的CURD操作对象迁移到数据库上：查询find 查询所有findOne 查询指定/** * 查找全部 */findAll() return this.cakeRepository.find()/** * 查找指定蛋糕 */async findOne(id:number) const cake = await this.cakeRepository.findOne( where: id:id ) // let cake = this.cakes.find(item=item.id == id) if(!cake) throw new NotFoundException(`Cake #$id is not find`) return cake新增create 创建save 保存/** * 新增蛋糕 * @param cake */async create(createCakeDto: CreateCakeDto) const cake = this.cakeRepository.create(createCakeDto) return this.cakeRepository.save(cake)更新preload/** * 修改蛋糕 * @param id * @param cake */async update(id:number, updateCoffeeDto:UpdateCakeDto) // preload 更新 找不到指定id返回undefined const cake = await this.cakeRepository.preload( id:id, ...updateCoffeeDto ) if(!cake) throw new NotFoundException(`Cake #$id is not exit`) return this.cakeRepository.save(cake)删除remove/** * 删除蛋糕 * @param cake */async delete(id: number) const cake = await this.findOne(id) return this.cakeRepository.remove(cake) Relation表间关联类型：@OneToOne()@OneToMany()@ManyToOne()@ManyToMany()关联操作：创建关系创建一个新的Entity：Flavors，表示风味nest g class cake/entities/flavor.entity --no-spec 新表加入模块定义中@Module( imports:[TypeOrmModule.forFeature([Cake,Flavor])] )使用描述符对cake.flavors进行关联：@JoinTable() 标识关联属性所有者@JoinTable()@ManyToMany( type = Flavor, // 关联表类型 flavor = flavor.cakes, // 反向收集 cascade:true // 级联关系)flavors: Flavor[];在被关联表中进行关联配置：@Entity()export class Flavor @PrimaryGeneratedColumn() id: number; @Column() name: string; @ManyToMany( type = Cake, cake = cake.flavors ) cakes: Cake[]关联查询：findAll() return this.cakeRepository.find( relations: [flavors], // 配置收集flavors )async findOne(id:number) const cake = await this.cakeRepository.findOne( where: id:id , relations:[flavors] ) if(!cake) throw new NotFoundException(`Cake #$id is not find`) return cake级联插入cake作为关系拥有表，当用新的flavor创建新的cake时，新的flavor数据也会被级联创建/** * 获取/新增flavor * @param name * @returns */private async preloadFlavorByName(name: string): PromiseFlavor const existingFlavor = await this.flavorRepository.findOne( where:name:name ) if(existingFlavor) return existingFlavor return this.flavorRepository.create(name)/** * 新增蛋糕 * @param cake */async create(createCakeDto: CreateCakeDto) const flavors = await Promise.all( createCakeDto.flavors.map(name=this.preloadFlavorByName(name)) ) const cake = this.cakeRepository.create( ...createCakeDto, flavors ) return this.cakeRepository.save(cake)/** * 修改蛋糕 * @param id * @param cake */async update(id:number, updateCoffeeDto:UpdateCakeDto) const flavors = updateCoffeeDto.flavors (await Promise.all( updateCoffeeDto.flavors.map(name=this.preloadFlavorByName(name)) )) // preload 更新 找不到指定id返回undefined const cake = await this.cakeRepository.preload( id:id, ...updateCoffeeDto, flavors ) if(!cake) throw new NotFoundException(`Cake #$id is not exit`) return this.cakeRepository.save(cake) PaginationQueryDto分页查询 为分页查询参数创建dtonest g class common/dto/pagination-query.dto --no-specimport IsOptional, IsPositive from class-validator;import Type from class-transformer;export class PaginationQueryDto @IsOptional() @IsPositive() // 正数 // @Type(()=Number) // 强制转换为Number类型 limit: number; @IsOptional() @IsPositive() // @Type(()=Number) offset: number;可以在ValidationPipe中，配置强制类型转换：app.useGlobalPipes(new ValidationPipe(// ... transformOptions: enableImplicitConversion: true )) 修改controller和service中查询配置// 查询所有蛋糕@Get(getMenu)getMenu(@Query() paginationQueryDto:PaginationQueryDto) return this.cakeService.findAll(paginationQueryDto)/** * 查找全部 */findAll(paginationQueryDto: PaginationQueryDto) const limit, offset = paginationQueryDto return this.cakeRepository.find( relations: [flavors], // 配置收集flavors skip: offset, // 页数 take: limit, // 页大小 ) Transaction 事务事务：一组操作作为一个整体，要么全部执行成功，要么全部不执行使用事务控制，在service中声明typeorm.DataSource类属性：// 关联数据库constructor( //... private readonly connection: DataSource,)使用QueryRunner和trycatchfinally进行事务处理：// 推荐蛋糕async recommendCake(cake: Cake) const queryRunner = this.connection.createQueryRunner(); await queryRunner.connect(); await queryRunner.startTransaction(); try cake.recommendations++ this.cakeRepository.preload(cake) this.cakeRepository.save(cake) const recommendEvent = new Event() recommendEvent.name = recommend_cake recommendEvent.type = cake recommendEvent.payload = cakeId: cake.id await queryRunner.commitTransaction() catch(err) // 回滚事务 await queryRunner.rollbackTransaction() finally await queryRunner.release() return cake 数据库迁移迁移报错解决方法首先需要在根目录下创建ormconfig.ts文件：import DataSource from typeorm;export const connectionSource = new DataSource( // migrationsTableName: migrations, type: postgres, host: localhost, port: 5432, username: postgres, password: ashley122, database: postgres, entities: [dist/**/*.entity.js], migrations: [dist/migrations/*.js], subscribers:[src/subscriber/**/*.ts]); create 创建迁移脚本：npx typeorm migration:create ./src/migrations/CoffeeRefactor generate 生成迁移脚本npx typeorm migration:generate ./src/migrations/CoffeeRefactor -d ./dist/ormconfig.jsrun 运行迁移脚本npx typeorm migration:run -d ./dist/ormconfig.jsrevert 恢复npx typeorm migration:revert -d ./dist/ormconfig.js对要修改的表对应的ORM进行修改，再在生成的迁移文件中进行表操作：// 实体类描述符@Entity(cake)export class Cake // ... // 将name表段重命名为label @Column() label: string;import MigrationInterface, QueryRunner from typeorm;export class CakeRefactor1720149725474 implements MigrationInterface public async up(queryRunner: QueryRunner): Promisevoid await queryRunner.query( `ALERT TABLE cake RENAME COLUMN name TO label` ) public async down(queryRunner: QueryRunner): Promisevoid await queryRunner.query( `ALERT TABLE cake RENAME COLUMN label TO name` ) 依赖注入 Dependency Injection应用配置 Application ConfigurationNext其它功能模块Exception Filters 异常过滤器Exception Filters用于处理应用中可能出现的异常 Pipes 管道Pipes用于对输入的数据进行验证转换 Guards 守卫Guards用于对访问的用户进行身份验证 Interceptors 拦截器Interceptors用于在接收到请求之前进行一些特殊操作","tags":["Web"]},{"title":"HarmonyOS ArkTS 开发体验","path":"/2024/06/28/ArkTs/","content":"DevEco StudioDevEco Studio 指定编译器，JetBrains风格界面，对于WebStorm用惯的Web开发者非常熟悉。使用指南当前问题插件比较少版本混乱文档版本和SDK版本相关，官方推荐的NEXT文档主要针对API（9-11）SDK版本和DevEco版本挂钩，稳定版本的DevEco只能安装9及以下的API，高版本需要下载Beta版本模拟器版本需要和API一致，高版本模拟器现在要使用需要申请权限 项目与文件项目创建：项目创建时选SDK一定要看清楚如果没有高版本的SDK，可能是因为DevEco Studio的版本过低，需要更新文件新建ArkTs中大部分指向明确的文件结构，都能在目录结构树中找到快捷方式创建DevEco有时会把ts文件编译成js和js.map类型的文件，破坏项目目录结构，目前社区内的解决方案是用插件一键删除：ArkCompilerSupport Previewer 视图视图会显示鼠标最近一次聚焦的页面视图调试的日志，需要在Log选项卡中对日志进行筛选：Previewer视图提供可视化编辑的画页面方法视图内能对屏幕进行拉伸操作视图不仅仅显示静态页面，网络请求也会执行视图内不能显示Web标签加载页面 调试模拟器模拟器的SDK需要和项目的SDK匹配模拟器配置后能够热更新，但是热更新的范围很小，大多数情况还是使用Previewer日志Log打印日志尽量带上标识符，不然被日志刷屏时一脸懵逼 基于ArkTS的声明式开发范式ArkTS ArkTS声明式语法习惯了就还好，比较麻烦的就是没有样式复用，整体看来比较类似于Vue2的框架风格UIAbilityets下会自动生成entryabilityEntryAbility.ts文件，生成UIAbility窗口，包含App首页的加载，对整个App生命周期以及事件的挂载：UIAbility组件修饰符ArkTs使用修饰符来标明数据、方法的属性，父子组件之间值的传递与vue比较相似组件状态管理自定义组件和Vue的使用方式也很像，包括父子组件之间数值的传递。但是能够将组件逻辑直接书写在组件声明内部这一点还是相当方便的。其它组件生命周期UIAbility组件生命周期页面和自定义组件声明周期router路由比较简单，类似于uniapp控制路由的方式组件提供了很多布局的组件：Flex、Row、Column、Grid等等，很方便很多组件都提供了响应式布局的思路一些组件的自由度依旧存在限制事件样式命名风格和css基本一致，基本不会有障碍 demo 参考项目：若依移动端鸿蒙版项目地址：APP截图 登录页 首页 列表页 个人主页 兼容JS的类Web开发范式开发风格比较类似于Vue，html、js、css三部分拆分后又作为一个整体页面组件，整体感觉比较厚重，既没有原生Js的那种高度整合性，又不如ArkTS高效APP截图 登录页 注册页 首页 列表 菜单 整体流程","tags":["APP"]},{"title":"mongodb + mongoose","path":"/2024/06/17/MongoDB/","content":"MongoDB命令行新版mongoDB的bin文件中没有sh工具，需要手动下载mongoshmongo shell 基础操作MongoDB 菜鸟教程# 进入mongo命令行：mongosh# 查看所有数据库show dbs# 切换到指定数据库（创建数据库）use dbName# 删除数据库db.dropDatabase() #显示所有集合show collections# 新增集合db.createCollection(name,option)# 集合重命名db.adminCommand( renameCollection: sourceDb.sourceCollection, to: targetDb.targetCollection, dropTarget: boolean)#查询集合所有数据db.collectionName.find()#新增一条数据db.users.insertOne(name:admin,age:24,status:1) #删除一条数据db.users.deleteOne()#删除指定表db.collectionName.drop()#清空指定表数据db.collectionName.remove()#创建索引db.collectionName.ensureIndex(useranme:1)#获取集合索引db.user.getIndexes()#管道查询db.user.aggregate( [ $lookup: from: news, localField: sn, foreignField: authorSn, as: workList ] ) 备份、还原、导入、导出 数据库导入、导出操作前，确保数据库打开# 数据库导出mongodump -h dbhost -d dbname -o dbdirectory# 数据库导入mongorestore -h dbhost -d dbname path Mongoose基本操作步骤步骤1：引入mongoosenpm i --save mongooseconst mongoose = require(mongoose)步骤2：建立连接mongoose.connect(mongodb://127.0.0.1:27017/test)步骤3：定义Schema表模版：const UserSchema = mongoose.Schema( name:String, age:Number, status:Number)步骤4：定义数据库模型：// model第一个参数，首字母需要大写// mongoDB中数据库命名，单数和复数之间会默认产生联系 user-users// 也可以通过指定第三个参数建立联系const User = mongoose.model(User,UserSchema,user)步骤5：操作操作文档增 save删 deleteOne改 updateOne查 find SchemaSchema类型Schema验证器静态与动态方法 管道查询aggregate UserModel.aggregate([ $lookup: from:news, localField:sn, foreignField:authorSn, as:workList , // 筛选 $match:name:root ]).then(res= console.log(关联成功) console.log(res)).catch(err= console.log(关联失败) console.log(err)) 多管道查询 AricleModel.aggregate([ //拉取分类信息 $lookup: from:articlecate, // 目标表 localField:cid, // 本表字段 foreignField:_id, // 外表字段 as:cate, // 转换字段 , // 拉取作者信息 $lookup: from:user, localField:author_id, foreignField:_id, as:author, ])","tags":["数据库"]},{"title":"c#基础学习","path":"/2024/06/08/C-Learning/","content":"C#编程入门（Brackeys）b站搬运翻译版 .NET VSCode安装 安装.NET框架安装VSCodeVSCode安装C#插件控制台输入创建新项目命令：dotnot new启动项目命令：dotnet run自定义项目启动控制台：Ctrl+Shift+P打开VSCode控制台选择.NET:Generate Assets For Build and DebugVSCode自动生成launch.json配制文件修改control属性为externalTerminal入口程序Program.csConsole.WriteLine(Hello, World!);Console.ReadKey(); How to Program in C#在Program.cs中，体验一下C#语法的手感：Console.ForegroundColor 设置输出颜色Console.Title 设置窗口标题Console.WriteLine 输出Console.ReadLine 读取用户输入Console.ReadKey 读取用户按键一篇只用Console的Visual Novel // See https://aka.ms/new-console-template for more informationConsole.Title = 俄罗斯轮盘;// 旁白void BackVoice(string mes)Console.ForegroundColor = ConsoleColor.Green;Console.WriteLine(旁白：+ mes + );Console.ReadKey();// 恶魔void DemonVoice(string mes, Boolean stop = true)Console.ForegroundColor = ConsoleColor.Red;Console.WriteLine(恶魔：+ mes + );if(stop)Console.ReadKey();// 玩家的声音void PlayerVoice(string mes)Console.ForegroundColor = ConsoleColor.Blue;Console.WriteLine(你：+ mes + );Console.ReadKey();// 玩家的回答string PlayerRes()Console.ForegroundColor = ConsoleColor.Yellow;string res = ;Console.Write(你：);while(res.Trim()==)res = Console.ReadLine();Console.WriteLine();return res;BackVoice(你盯着面前的左轮手枪);BackVoice(冷汗直流);DemonVoice(接下来，该你了，宝贝);BackVoice(你的眼神在左轮手枪和它之间反复徘徊);BackVoice(有一瞬间，你想直接用手枪崩烂它的笑脸);BackVoice(但那样做有失风度);BackVoice(你擦了把头上的汗，骂道：);string dirtyWord = PlayerRes();DemonVoice(嘿嘿嘿......);DemonVoice(很不错的气势);BackVoice(魔鬼阴沉的发笑);BackVoice(你攥紧这把沉甸甸的手枪);BackVoice(手心湿漉漉的，有些打滑);PlayerVoice(离远点欣赏，小心血喷你一身);BackVoice(它用漆黑的目光注视着你，仿佛要将你看穿);PlayerVoice(哼);BackVoice(你用眼神蔑着它垂涎欲滴的蠢样);PlayerVoice(反正我都会活下来就是了);DemonVoice(我很欣赏你的自负..., false);BackVoice(咔哒......碰！);PlayerVoice(!!!);DemonVoice(!!!);BackVoice(未等它说完，你就叩响了扳机);BackVoice(......);BackVoice(没有子弹，你还活着，空枪);BackVoice(你吐出一口气);PlayerVoice(那么现在，履行诺言的时候到了);BackVoice(你将微微颤抖的手放下);PlayerVoice(我要你去杀一个人);DemonVoice(哼，看来你很清楚怎么和恶魔打交道。);DemonVoice(告诉我那个人的名字。);BackVoice(你紧握着手中的枪);BackVoice(居于黑暗中的双眼冷静的凝视着远处昏暗的灯光);BackVoice(缓缓张口，说出了那个人的名字......);string name = PlayerRes();DemonVoice(...... + name + ?);DemonVoice(嘿嘿......);DemonVoice(你的眼光很不错);DemonVoice(挑了个折磨起来很有趣的灵魂);BackVoice(魔鬼的脸上露出阴险的笑容);BackVoice(它站起身，缓缓后退);DemonVoice(三天后，一切如你所愿);BackVoice(它丑陋的身影渐渐与身后的黑暗消融在一起);DemonVoice(嘿嘿嘿......);BackVoice(它那古怪而低沉的笑声，也随之变得模糊);DemonVoice(可怜的羔羊......);DemonVoice(也许有一天你会后悔这笔交易);DemonVoice(但至少，你现在根本不知道自己都做了些什么。);BackVoice(它的身影彻底消失在黑暗之中);BackVoice(只留下你一人);BackVoice(还有那回荡在黑暗之中的笑声);Console.ReadKey(); 《C#语言入门详解》——刘铁猛1. C#语言介绍编程学习路径：纵向： 语言 → 类库 → 框架横向： 命令行 → 桌面程序 → 设备（平板手机）程序 → Web程序 → 游戏 → …Visual Studio文档C#文档WPF程序初体验主窗口代码：title:MainWindow.xamlWindow Grid Grid.ColumnDefinitions/Grid.ColumnDefinitions Grid.Background/Grid.Background TextBox x:Name=textBox/TextBox Button Click=Button_Click/Button /Grid/Window对Button的Click事件进行监听：title:MainWidnow.xaml.csnamespace HelloWPF public partial class MainWindow : Window // 主窗口程序 public MainWindow() InitializeComponent(); // 文本框输入框文本变化事件 private void TextBox_TextChanged(object sender, TextChangedEventArgs e) // 按钮点击事件 private void Button_Click(object sender, RoutedEventArgs e) this.textBox1.Text = Hello World; 2. C#应用程序介绍Solution和Project Solution：针对客户需求的解决方案用户需要制作一个管理系统Project： 解决具体问题采取的方案数据存储？数据库项目数据读取表单处理？服务器项目网站操作？客户浏览器应用项目手机操作？手机端应用项目平板操作？平板应用项目… 各类C#编写的应用程序 ConsoleConsole App 控制台程序 Console.WriteLine(Hello World); Windows Forms(Old)WinFormsApp 旧版本桌面应用程序 namespace HelloWinFormsApp public partial class Form1 : Form public Form1() InitializeComponent(); private void HelloButton_Click(object sender, EventArgs e) this.HelloTextBox.Text = Hello World; color:darkWPF（Windows Presentation Foundation）WPF 新版桌面应用程序 ASP.NET Web Forms(Old) 网站应用ASP.NET MVC(Model-View-Controller) 网站应用Windows Store Application 平板应用Windows Phone Application 手机应用Cloud（Windows Azure） 云计算平台WF（Workflow Foundation）工作流WCF 纯网络服务 3. 类与名称空间class namespace c#中，程序作为类实现，因此需要将入口函数包在类中命名空间方便实现类间的依赖关系防止命名冲突 类库引用 DLL（Dynamic Link Library 动态链接库类库）引用黑盒引用，无源代码 NuGet，自动化维护类依赖关系项目引用白盒引用，有源代码项目引用下面是一个类库（.NET Framework）的主代码title:Calculator类using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Tools public class Calculator // 加法 public static double Add(double a, double b) return a + b; // 减法 public static double Sub(double a, double b) return a - b; // 乘法 public static double Mul(double a, double b) return a * b; // 除法 public static double Div(double a, double b) if (b == 0) return Double.PositiveInfinity; else return a / b; 在需要引用该类的主项目所在的Solution中，将类库项目添加进去，引入类库依赖，之后再主项目中使用该类：title:Program.csusing Tools;namespace ConsoleApp internal class Program static void Main(string[] args) double result = Calculator.Add(1.14, 4.15); Console.WriteLine(result); 4. 类、对象、类成员简介实例和对象 两者的区别主要在语境上：在讨论类在现实世界中的对应时，一般称为对象在讨论类在程序中的对应时，一般称为实例 C#中类的三要素：属性 Property方法 Function事件 EventVisual Studio中，将光标放在类上，点击F1，会自动跳转到类对应的MSDN文档上使用Event实现桌面时钟using System.Windows.Threading;public partial class MainWindow : Window public MainWindow() InitializeComponent(); // 创建定时器 DispatchTimer timer = new DispatchTimer(); // 配置定时器间隔时间 timer.Interval = TimeSpan.FromSeconds(1); // 定时事件 timer.Tick += Time_Tick; // 开启定时器 timer.Start(); // 定时事件 private void Time_Tick(object? sender, EventArgs e) this.TimeTextBox.Text = DateTime.Now.ToString() 静态成员与实例成员 静态成员：类的成员实例成员：对象的成员 5. 构成C#语言的基本元素变量类型 int x_int = 2; // 32bit long y_long = 3L; // 64bit 长整型float x_float = 3.0F; // 32 // 单精度 double y_double = 40.0; // 64 // 双精度char c = 1; // 单字符string str = 12323; // 字符串bool flag = true; // 布尔值string isNull = null; // nullvar thisIsNumber = 3; // 推断类型除了这些静态类型，C#中还提供2中比较特殊的类型：var 可以为任意基础类型dynamic 动态类型 6. 类型、变量与对象C#变量、堆、栈、垃圾回收 堆 存储实例分配内存大分配不合理会导致内存泄漏C#提供垃圾回收机制，防止内存泄漏栈用于存储运行的函数可能会导致栈溢出 Performance Monitor 性能监视器 使用Performance Monitor，能够监控进程的堆内存使用量。Win+R → perfmon → 性能监视器 → +号 → Process → Private Bytes（已分配字节数）→ 选定对象实例（要监控的程序）→ 添加 → 双击实例（进行图表定制） C#五大数据类型 C#的所有数据类型都以Object为基类引用类型类 class接口 interface委托 delegate值类型结构体 structstring、charbool、true、falsebyte、int、long、float、double、sbyte、short、uint、ulong、ushort、decimalvoid、null、var、dynamic枚举 enum 7种变量类型 静态变量 （const修饰符）实例变量（成员变量，字段）（publicstaticprivate修饰符）数组变量值参数引用参数 （ref修饰符）输出形参 （out修饰符）局部变量 7. 运算符运算符实际上是对函数的一种语法糖，定义一个Person类的相加方法：class Person public string Name; public static ListPerson operator +(Person p1, Person p2) ListPerson children = new ListPerson(); int childrenNumber = 11; for (int i = 0; i childrenNumber; i++) Person child = new Person(); child.Name = p1.Name + 和 + p2.Name + 的第 + (i+1) + 个孩子; children.Add(child); return children; 调用加法的效果：Person man = new Person();Person woman = new Person();man.Name = 亚当;woman.Name = 夏娃;//ListPerson children = Person.GetMarry(man, woman);ListPerson children = man + woman; 基本运算符 点运算符：System.IO.File.Create(D:\\\\CS_Demo\\\\test\\\\HelloWorld.txt);函数调用符事件委托Action sayHello = new Action(Person.SayHello);sayHellow()class Person public static void sayHello() Console.WriteLine(hello); 数组访问int[] myIntArray = new Int[] 1,2,3,4,5;字典访问Dictionarystring, Person PersonDic = new Dictionarystring, Person();// 字典的添加for(int i = 1; i 10;i++) Person p = new Person(); p.Name = p_+i.ToString(); p.Age = i * 10; PersonDict.Add(p.Name, p);// 字典的访问Person p_3 = PersonDict[p_3];类型type操作符Type t = typeof(int);Console.WriteLine(t.Namespace);Console.WriteLine(t.FullName);Console.WriteLine(t.Name);default操作符：获取到此类型存储内存全部刷成0的值int a = default(int)new操作符功能1：创建实例并将实例的地址转交给变量Form myForm = new Form()功能2：实例初始化Form myForm = new Form()Text=Hello,FormBorderStyle = FormBorderStyle.SizableToolWindow功能3： 创建匿名类型var person = new Name = Mr.Okay, Age = 20;Console.WriteLine(person.GetType().Name); // f__AnomymousType0`2 功能4：子类隐藏父类方法class Student public void Report() Console.WriteLine(im a student); class CS_Student:Student new public void Report() Console.WriteLine(im a cs student); 什么是依赖注入？依赖注入又是如何对程序进行解耦合的？checked unchecked用于检查某个值的溢出情况，C#中默认进行unchecked，进行变量的checked检查：uint x = uint.MaxValue;try uint y = checked(x+1); //System.OverflowException:“算术运算导致溢出。”catch(OverflowExcept ex) Console.WriteLine(overflow error);进行代码块的checked检查checked try uint y = x+1; catch(OverflowExcept ex) Console.WriteLine(overflow error); delegatedelegate是声明匿名方法的操作符，比如：某个函数声明后，实际只使用了一次：public MainWindow() this.myButton.Click += MyButton_Click;public void MyButton_Click() this.myTextBox.Text = Hello World;这时可以使用delegate来直接声明（现在多被lambda函数取代）this.myButtonBox.Click += delegate (object sender, RoutedEventArgs e) this.myTextBox.Text = Hello World;lambda表达式的方式更加简单，并且程序会对参数类型进行推断this.myButton.Click += (sender, e) = this.myTextBox.Text = Hello World;指针使用指针时，代码块需要开启unsafe模式，并且需要进行额外配置：项目Oporator属性生成允许不安全代码（勾选）unsafe Student stu = new Student()Name = Jason, Age = 18; // 指针符号 * // 取地址符号 Student * pStu = stu; // 箭头符号 pStu=Age = 20; // 取引用符号 (*pStu).Name = Tim; 类型转换操作 隐式类型转换不会影响数值精度的情况下完成转换（低精度转高精度）子类向父类的转换显式类型转换可能丢失精度的转换，cast转换Convert调用ToStringParseTryParse子类转父类internal class Program static void Main(string[] args) Programmer programmer = new Programmer(); // 子类转父类 Human human = programmer; Animal animal = programmer; human.Think(); human.Eat(); class Animal public void Eat() Console.WriteLine(Eating); class Human : Animal public void Think() Console.WriteLine(Thinking); class Programmer: Human public void Code() Console.WriteLine(Coding); cast转换uint x = ushort.MaxValue + 1;ushort y = (ushort)x;Console.WriteLine(x); // 65536Console.WriteLine(y); // 0 ParseTryParse Parse在无法转换时，会抛出错误string x = Console.ReadLine();string y = Console.ReadLine();double x_value = double.Parse(x);double y_value = double.Parse(y);Console.WriteLine(x_value + y_value);对应TryParse，接收无法转换的值不会报错，需要一个out参数:string x = Console.ReadLine();string y = Console.ReadLine();double x_value, y_value;double.TryParse(x, out x_value);double.TryParse(y, out y_value);Console.WriteLine(x_value + y_value); 自定义类实例转换 通过在类中定义带关键字前缀函数，实现类型转换：显示转换 explicitStone stone = new Stone();stone.Age = 5000;Monkey wukong = (Monkey)stone; // 显式转换Console.WriteLine(wukong.Age); class Stone public int Age; // 定义转换操作方法 public static explicit operator Monkey(Stone stone) Monkey m = new Monkey(); m.Age = stone.Age/500; return m; class Monkey public int Age; 隐式转换 implicit// 隐式转换Monkey m = stoneclass Stone public int Age; public static implicit operator Monkey(Stone stone) Monkey m = new Monkey(); m.Age = stone.Age/500; return m; 浮点数除法|正负无穷大 浮点数的除数可以是0，结果会是正负无穷大double x = -5.0;double y = 0;double z = x / y;Console.WriteLine(z); // -InfinityConsole.WriteLine(double.PositiveInfinity / double.NegativeInfinity); // NaNConsole.WriteLine(double.PositiveInfinity * 0.0); // NaN 字符比较大小 比较ASCII编码大小char char1 = A;char char2 = a;ushort u1 = (ushort)char1;ushort u2 = (ushort)char2;Console.WriteLine(char1 + = + u1); // 65Console.WriteLine(char2 + = + u2); // 97 is | as is实现类的检测Person p = new Person();Console.WriteLine(p is Person); // TrueConsole.WriteLine(p is Human); // TrueConsole.WriteLine(p is Animal); // True class Animal class Human : Animal class Person : Human as能够实现类型断言（转换），转换不成功则返回nullobject p = new Person();Person np = p as Person; // 无法转换返回null null值 可空类型：Nullableint x = null;语法糖：int? x = null;null值检测语法糖，下面语句，如果x为null，则返回1int y = x ?? 1; 三目运算符 int x = 80;string str = string.Empty;str = x = 60 ? Pass : Failed;Console.WriteLine(str); 8. 表达式语句反编译 Visual Studio对项目经过编译后，可以在项目目录binDebug下找到.exe执行文件，使用Visual Studio提供的工具： Developer Command Prompt命令行输入： ildasm导入已经被编辑好的exe执行文件，能够反编译出源码： 声明常量 const int x = 100; 代码流控制 goto hello: Console.WriteLine(Hello, World!);goto hello; 表达式相关快捷键 快捷键：ctrl + } 实现代码块括号跳转ctrl + l 快速剪切一行 switch visual studio创建switch语句快捷键：swcase表达式后跟随的数据必须要和switch变量后指定的表达式一致，case表达式后，有执行语句，必须要加breaktry int Score = Int32.Parse(Console.ReadLine()); switch (Score / 10) case 10: if (Score 100) // 直接跳转到default goto default; else goto case 8; case 9: case 8: Console.WriteLine(A);break; case 7: case 6: Console.WriteLine(B); break; case 5: case 4: Console.WriteLine(C); break; case 3: case 2: case 1: case 0: Console.WriteLine(D); break; default:Console.WriteLine(请输入0-100以内的数字);break; catch Console.WriteLine(请输入数字整数); trycatch-throwfinally class Calculator public int Add(string arg1, string arg2) int a = 0; int b = 0; bool successDone = false; try a = int.Parse(arg1); b = int.Parse(arg2); successDone = true; catch (ArgumentNullException ane) Console.WriteLine(ane.Message); //Console.WriteLine(Argument cant be null); catch (FormatException fe) Console.WriteLine(fe.Message); //Console.WriteLine(Argument must be int); catch (OverflowException oe) Console.WriteLine(oe.Message); throw oe; //Console.WriteLine(Overflow); // 无论如何都会执行 finally if (successDone) Console.WriteLine(Success); else Console.WriteLine(Failed); int result = checked(a + b); return result; foreach 对于实现IEnumerable接口的类，都能够通过foreach进行循环遍历：IEnumerable类本身实现了一些用于遍历的方法和属性：MoveNext 指针移动到下一项，如果成功返回trueCurrent 返回当前值Reset 重置当前值使用IEnumerable实现循环：Listint intList = new Listint() 1, 2, 3 ;IEnumeratorint enumerator = intList.GetEnumerator();while (enumerator.MoveNext()) Console.WriteLine(enumerator.Current);使用foreach进行遍历：Listint intList = new Listint() 1, 2, 3 ;foreach (var current in intList) Console.WriteLine(current); 9. 字段、属性、索引器、常量实例字段静态字段publicstaticstatic void Main(string[] args) ListTeamMember MemberList = new ListTeamMember(); for (int i = 0; i 10; i++) TeamMember Member = new TeamMember(无名氏 + i, 士兵); /** * 团队名称：作战小队 * 团队成员：10 */ TeamMember.Intro();class TeamMember // 实例字段 public int Health = 100; // 静态字段 public static int Amount; // 只读静态字段 public readonly static string TeamName = 作战小队; // 只读实例字段 public readonly string Progress; public readonly string Name; // 构造函数 // 只读实例字段在构造函数里进行初始化 public TeamMember(string name,string progress) this.Progress = progress; this.Name = name; TeamMember.Amount++; // 静态方法 public static void Intro() // 静态方法中访问静态变量 Console.WriteLine(团队名称：0, TeamMember.TeamName); Console.WriteLine(成员数量：0, TeamMember.Amount); 只读字段 readonly无论是值类型还是引用类型，readonly变量都不能修改：static void Main(string[] args) // 无法进行更改操作： //Brush.DefaultColor.Green = 0; Brush.PrintDefaultColor(); Console.ReadKey();struct Color public int Red; public int Green; public int Blue;class Brush public static readonly Color DefaultColor = new Color() Red = 0, Green = 255, Blue = 255, ; public static void PrintDefaultColor() Console.WriteLine( 当前笔刷颜色：RGB(0,1,2), Brush.DefaultColor.Red, Brush.DefaultColor.Green, Brush.DefaultColor.Blue ); 私有字段 privatestatic void Main(string[] args) TreasureBox box = new TreasureBox(); box.SetTreasure(一只狗); while (true) Console.WriteLine(请给出宝箱密语：); string pass = Console.ReadLine(); try string treasure = box.GetTreasure(pass); Console.WriteLine(密语正确，你获得了【0】, treasure); break; catch (Exception ex) Console.WriteLine(ex.Message); Console.ReadKey();class TreasureBox // 私有变量，仅能在类内进行修改 private string treasure; private string pass = 最强武器; public string GetTreasure(string pass) if (pass == this.pass) return this.treasure; else throw new Exception(密码错误); public void SetTreasure(string treasure) this.treasure = treasure; getset 实现属性封装getset private Visual Studio快捷键：propfull + tabtab ：快速定义并封装私有变量prop + tabtab ： 简略声明私有变量点击要封装的字段 + ctrl + r + e ：重构封装字段static void Main(string[] args) Cat cat = new Cat(); while (true) Console.Write(请选择撸猫的次数：); string inputNumber = Console.ReadLine(); int number = 0; try number = Int32.Parse(inputNumber); cat.PetCount += number; Console.Write(是否继续（y/n）？); string input = Console.ReadLine(); if (input == n) break; catch (Exception e) Console.WriteLine(e.Message); Console.WriteLine( ================================); Console.WriteLine(游戏结束); Console.WriteLine(最终亲密度：0, cat.love); Console.WriteLine(================================); Console.ReadKey();class Cat public int love = 0; private int petCount; // 对私有属性的封装，get控制读取，set控制写入 public int PetCount get return petCount; set love += value * 5; Console.WriteLine(爱意值：0, love); if (love = 100) Console.WriteLine(你的猫因为感受到太多爱意，即将变身火箭猫); petCount = value; 索引器 Indexstatic void Index() Coffee coffee = new Coffee(); var mocaPrice = coffee[Moca]; Console.WriteLine(mocaPrice); coffee[Moca] = 15; Console.WriteLine(coffee[Moca]);class Coffee // 键类型：string 值类型：int private Dictionarystring, int coffeeDictionary = new Dictionarystring, int(); // indexer + tabtab public int? this[string name] get /* return the specified index here */ if (this.coffeeDictionary.ContainsKey(name)) return this.coffeeDictionary[name]; else return null; set if (value.HasValue == false) throw new Exception(Price cannot be null); /* set the specified index to value here */ if (this.coffeeDictionary.ContainsKey(name)) this.coffeeDictionary[name] = value.Value; else this.coffeeDictionary.Add(name, value.Value); 10. 参数传值参数输出参数引用参数数组参数具名参数可选参数扩展方法（this参数） 传值参数 值参数：声明时不带任何修饰符的参数 传值参数：值类型 参数作为传值的副本static void ValueParam_1() Player player = new Player(); string words = 我是一个普通的日本高中生; Player.Say(words); // 主人公:我是一个普通的日本高中生 Console.WriteLine(words); // 我是一个普通的日本高中生class Player public readonly static string name = 主人公; // 值参数：声明不带任何修饰符的参数 // 参数作为传值的副本 public static void Say(string words) words = Player.name + ： + words; Console.WriteLine(words); 传值参数：引用类型 直接修改参数引用的内存地址（new操作）时，函数内对参数的修改不会影响被传入值GetHashCode： 获取引用类型指向的地址static void ValueParam_2() // 通过new操作创建出一个新的副本 Progress oldPro = new Progress() type = Rapper ; IntroProgress(oldPro); Console.WriteLine(0：1, oldPro.GetHashCode(), oldPro.type);static void IntroProgress(Progress pro) pro = new Progress() type = Dancer ; Console.WriteLine(0：1,pro.GetHashCode() ,pro.type); class Progress public string type get; set; 直接对（引用类型）传值参数的属性进行修改，实际上就是对被传入参数进行修改：static void ValueParam_3() Enemy enemy = new Enemy() Status = 被击中 ; UpdateEnemy(enemy); Console.WriteLine(0：1,enemy.GetHashCode(), enemy.Status );static void UpdateEnemy(Enemy enemy) enemy.Status = 死亡; Console.WriteLine(0：1, enemy.GetHashCode(), enemy.Status);class Enemy private string status; public string Status get return status; set status = value; 引用参数 ref 引用类型使用ref进行标识 引用参数：值类型 static void RefererParam_1() int x = 10; IWantSideEffect(ref x); Console.WriteLine(x);// 使用ref进行标识static void IWantSideEffect(ref int x) x = x + 1; 引用参数：引用类型 static void RefererParam_2() Weapen weapen = new Weapen() name = 小刀 ; Console.WriteLine(HashCode:0 name:1,weapen.GetHashCode(), weapen.name); Console.WriteLine(--------------------------------); UpdateWeapen(ref weapen); Console.WriteLine(HashCode:0 name:1, weapen.GetHashCode(), weapen.name);static void UpdateWeapen(ref Weapen weapen) weapen = new Weapen() name = 钢丝 ; Console.WriteLine(HashCode:0 name:1, weapen.GetHashCode(), weapen.name);class Weapen public string name get; set; 输出形参 outout和ref效果类似，不同点在于out可以传入null值，并且必须在函数体中进行赋值double.TryParse方法使用的就是out传参：static void OutputParam() Console.Write(请输入一个数字（不要轻易尝试数字以外的输入，否则...）：); string input = Console.ReadLine(); double inputValue = 0; if (double.TryParse(input, out inputValue)) Console.WriteLine(你按照要求输入了数字：0, inputValue); else Console.WriteLine(你没有按照要求输入，应当受到惩罚);out声明值类型参数：static void TryOut_1 () Console.Write(请提供料理食材：); string material = Console.ReadLine(); string food = 空空如也; Cooker.CookFood(material,out food); Console.WriteLine(你获得了：一份0, food);class Cooker public static void CookFood(string material, out string food) if (material != ) if (material.Contains(肉)) food = 热乎乎的炖肉; else if (material.Contains(面粉)) food = 新鲜出炉的面包; else if (material.Contains(奶油)) food = 金色奶油蛋糕; else food = 美味料理; else food = 空气料理; out声明引用类型static void TryOut_2() Console.Write(请为您的巧克力取一个名字：); string name = Console.ReadLine(); Console.Write(请用一个词形容它的风味：); string flavor = Console.ReadLine(); Chocolate chocolate = null; ChocolateFactory(name, flavor, out chocolate); if (chocolate != null) chocolate.Intro(); else Console.WriteLine(生产失败，是不是漏了什么？); static bool ChocolateFactory(string name, string flavor, out Chocolate chocolate) chocolate = null; if (name != flavor != ) chocolate = new Chocolate() name = name, flavor = flavor; chocolate.wrapper = 锡纸包装→烫金花纹; return true; return false;class Chocolate public string name get; set; public string flavor get; set; public string wrapper get; set; public void Intro() Console.WriteLine(新款巧克力：0，新口味：1，新包装：2, this.name, this.flavor, this.wrapper); 数组参数 params使用数组参数声明，会自动将传参收集为数组格式，数组参数只能存在一个，并且是被声明的最后一个参数static void ArrayParam() // 不使用数组参数的方法： //int[] intArray = new int[] 1, 2, 3, 4, 5 ; //int sum = CalculateSum(intArray); int sum = CalculateSum(1, 2, 3, 4, 5); Console.WriteLine(sum);static int CalculateSum(params int[] intArray) int sum = 0; for (int i = 0; i intArray.Length; i++) sum += intArray[i]; return sum;string.Split方法参数声明的方式就是paramsstatic void UseSplit() string str = 空调;冰箱,冰淇淋.大海; // 此处split参数为数组传参 string[] result = str.Split(;,,,.); foreach (string word in result) Console.WriteLine(word); 具名参数一种允许乱序的传参方式：static void NameParam() LoadGame(存档1,DateTime.Now); LoadGame(time: DateTime.Now, name:未命名存档);static void LoadGame(string name, DateTime time) Console.WriteLine(新建存档：0 创建时间：1, name, time.ToString()); 可选参数可选参数需要赋默认值：static void SelectableParam() OrderCoffee(orderer:张三, name:冰美式); OrderCoffee();static void OrderCoffee(string name = 招牌拿铁, string orderer = 无名氏) Console.WriteLine(您收到了新的美团订单：0一份 订餐人：1,name, orderer); 扩展方法 this使用this标识参数，能够实现扩展方法对double类型的扩展：// 3. 必须是静态类// 4. 静态类命名标准：// SomeType类 扩展→ SomeTypeExtension类static class DoubleExtension // 1. 方法必须是public static // 2. 形参第一个必须是this修饰 public static double Round(this double input, int digits) double result = Math.Round(input, digits); return result; Linq Language Integrated Query 语言集成查询Linq内实现了对Enumerable的扩展static void UseExtension() Listint myList = new Listint 11, 12, 13, 14 ; bool res = myList.All(i = i 10); bool result = AllGreaterThenTen(myList); Console.WriteLine(result); 11. 委托Action、Func方法委托就是将方法，用指针进行调用，一般作为参数进行传递：模板方法回调方法委托方法1：Action + Invokestatic void Fun()Action action = new Action(Fun)action.Invoke()委托方法2：Func泛型声明static int Add(int x, int y)return x + y;static int Minus(int x, int y)return x - y;Funcint, int, int delegateAdd = new Funcint, int, int(Add);Funcint, int, int delegateMinus = new Funcint, int, int(Add);delegateAdd.Invoke(10,20);delegateMinus.Invoke(10,20); delegate声明delegate类似于声明一个方法签名，声明一个有参数和返回值特点的模具static void DelegateClass() Calculate calculator = new Calculate(); Calc calcAdd = new Calc(calculator.Add); Calc calcSub = new Calc(calculator.Sub); Calc calcMul = new Calc(calculator.Mul); Calc calcDiv = new Calc(calculator.Div); double x = 10, y = 20; calcAdd(x, y); calcSub(x, y); calcMul(x, y); calcDiv(x, y);// 委托与封装方法必须类型兼容public delegate double Calc(double x, double y); class Calculate public double Add(double x, double y) return x + y; public double Sub(double x, double y) return x - y; public double Mul(double x, double y) return x * y; public double Div(double x, double y) return x / y; 模版方法和回调方法static void TempFunc() WrapFactory wrapFact = new WrapFactory(); ProductFactory prodFact = new ProductFactory(); Logger logger = new Logger(); ActionProduct log = new ActionProduct(logger.Log); FuncProduct ChocoFact = new FuncProduct(prodFact.MakeChocolate); FuncProduct PizzaFact = new FuncProduct(prodFact.MakePizza); Box chocoBox = wrapFact.Wrap(ChocoFact, log); Box pizzaaBox = wrapFact.Wrap(PizzaFact, log); chocoBox.Open(); pizzaaBox.Open(); class Logger public void Log(Product product) Console.WriteLine(产品 0| 生产时间 1 | 价格 2, product.Name, DateTime.UtcNow, product.Price); class Product public string Name get; set; public double Price get; set; class Box public Product Product get; set; public void Open() if (this.Product == null) Console.WriteLine(盒子里什么都没有); return; Console.WriteLine(打开盒子，里面是0,this.Product.Name); class WrapFactory public Box Wrap(FuncProduct GetProduct, ActionProduct logCallback) Box box = new Box(); // 模板方法 box.Product = GetProduct.Invoke(); // 回调方法 logCallback(box.Product); return box; class ProductFactory public Product MakeChocolate() Product product = new Product(); product.Name = 旺卡巧克力; product.Price = 15; return product; public Product MakePizza() Product product = new Product(); product.Name = 玛格丽特披萨; product.Price = 50; return product; 使用Interface接口代替delegate委托接口声明与实现interface IProductFactory Product Make();class CandyFactory : IProductFactory public Product Make() Product product = new Product(); product.Name = 糖果; product.Price = 15.0; return product; class BreadFactory : IProductFactory public Product Make() Product product = new Product(); product.Name = 巧克力面包; product.Price = 20.0; return product; 修改原本的委托方法参数为接口参数：class WrapFactory public Box Wrap(IProductFactory prodFact, ActionProduct logCallback) Box box = new Box(); box.product = prodFact.Make(); logCallback(box.product); return box; 修改方法调用的传参：static void Main(string[] args) WrapFactory wrapFact = new WrapFactory(); IProductFactory candyFact = new CandyFactory(); IProductFactory breadFact = new BreadFactory(); Log log = new Log(); ActionProduct logging = new ActionProduct(log.Logging); Box candyBox = wrapFact.Wrap(candyFact, logging); Box breadBox = wrapFact.Wrap(breadFact, logging); Console.ReadKey(); 多播委托（multicast）将多播进行合并，按照合并顺序执行static void Multicast() Student stu1 = new Student() ID = 1, PenColor = ConsoleColor.Yellow ; Student stu2 = new Student() ID = 2, PenColor = ConsoleColor.Green ; Student stu3 = new Student() ID = 3, PenColor = ConsoleColor.Red ; Action action1 = new Action(stu1.DoHomework); Action action2 = new Action(stu2.DoHomework); Action action3 = new Action(stu3.DoHomework); action1 += action2; action1 += action3; action1.Invoke();class Student public int ID get; set; public ConsoleColor PenColor get; set; public void DoHomework() for (int i = 0; i 5; i++) Console.ForegroundColor = this.PenColor; Console.WriteLine(Student 0 doing homework 1 hour(s), this.ID, i); Thread.Sleep(500); 实现异步的方法实现异步的三种方法：隐式异步 BeginInvokeAction action1 = new Action(Func1);Action action2 = new Action(Func2);Action action3 = new Action(Func3);// 隐式异步调用action1.BeginInvoke(null, null);action2.BeginInvoke(null, null);action3.BeginInvoke(null, null);线程 ThreadThread thread1 = new Thread(new ThreadStart(Func1));Thread thread2 = new Thread(new ThreadStart(Func2));Thread thread3 = new Thread(new ThreadStart(Func3));thread1.Start();thread2.Start();thread3.Start();TaskTask task1 = new Task(new Action(Func1));Task task2 = new Task(new Action(Func2));Task task3 = new Task(new Action(Func3));task1.Start();task2.Start();task3.Start(); 12. 事件事件基本概念事件的触发与响应 事件的本质是假装在委托字段上的一个蒙版事件模型组成部分：事件拥有者 eventSource事件成员 event事件响应者 eventSubscriber事件处理器 eventHandler事件订阅挂接事件处理器使用的是语法糖：eventSource.evnet += eventSubscriber.eventSubscriber;触发Timer.Elapsed事件：static void UseEvent() System.Timers.Timer timer = new System.Timers.Timer(); timer.Interval = 1000; Boy boy = new Boy(); Girl girl = new Girl(); timer.Elapsed += boy.Action; timer.Elapsed += girl.Action; timer.Start();class Boy internal void Action(object sender, ElapsedEventArgs e) Console.WriteLine(Jump); class Girl internal void Action(object sender, ElapsedEventArgs e) Console.WriteLine(Sing); static void UseEvent() ExtendForm form = new ExtendForm(); form.ShowDialog();class ExtendForm : Form private TextBox textBox; private Button button; public ExtendForm() this.textBox = new TextBox(); this.button = new Button(); this.button.Text = Click Me; this.button.Top = 150; this.Controls.Add(this.button); this.Controls.Add(this.textBox); this.button.Click += this.ButtonClicked; private void ButtonClicked(object sender, EventArgs e) this.textBox.Text = Hello, World!; 事件绑定的几种方式 被绑定事件的参数类型和返回值如下：private void ButtonClick(object sender, EventArgs e)语法糖this.button.Click += this.ButtonClickEventHandlerthis.button.Click += new EventHandler(this.ButtonClick)delegate 匿名函数委托this.button.Click += delegate (object sender, EventArgs e) this.textBox1.Text = Button Clicked; lambda表达式this.button,Click += (sender, e) = // event detail 实现整体事件流程下面是一个点餐的事件模型：事件拥有者：Customer客户事件成员：OrderEventArgs点餐事件响应者：Waiter服务员事件处理器：Action送餐事件订阅：为客户的点餐事件指派一个服务员并进行响应定义点餐事件委托，以及事件参数：public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);public class OrderEventArgs : EventArgs public string DishName get; set; // 订餐菜名 public string Size get; set; // 订餐分量定义客户：public class Customer public double Bill get; set; // 支付账单 public void PayBill() Console.WriteLine(Pay the bill：0, this.Bill); // 走进 public void WalkIn() Console.WriteLine(Walk In,,,); // 找位置坐下 public void SitDown() Console.WriteLine(Sit Down...); 为Customer类声明事件类型属性：public class Customer // 声明事件 private OrderEventHandler orderEventHandler; public event OrderEventHandler Order add this.orderEventHandler += value; remove this.orderEventHandler -= value; 简化写法：public class Customer public event OrderEventHandler Order;定义服务员以及订餐响应方法：public class Waiter internal void Action(Customer customer, OrderEventArgs e) Console.WriteLine(Got Order: 0, e.DishName); double price = 10; switch (e.Size) case small: price *= 0.5; break; case big: price *= 1.5; break; default: break; customer.Bill += price; 为客户定义事件触发方法：public class Customer public void Thinking() for (int i = 0; i 3; i++) Console.WriteLine(Thinking...); Thread.Sleep(1000); if (this.orderEventHandler != null) OrderEventArgs e = new OrderEventArgs(); e.DishName = French Eggs; e.Size = small; this.orderEventHandler.Invoke(this, e); // 触发事件 public void Action() Console.ReadLine(); this.WalkIn(); this.SitDown(); this.Thinking(); 通过事件触发和响应串通整个流程：Customer customer = new Customer();Waiter waiter = new Waiter();customer.Order += waiter.Action;customer.Action();customer.PayBill(); 13. 类析构函数 destructor析构函数和construct相对应，在实例被销毁时执行class Chocolate // ctor 创建构造器快捷键 public string Name get; set; public double Price get; set; public Chocolate(string Name, double Price) this.Name = Name; this.Price = Price; // 析构函数 ~Chocolate() Console.WriteLine(Chocolate 0 be destroyed, this.Name); public void Report() Console.WriteLine(this.Name); 反射通过class的类型创建objet或dynamic变量承接object实现反射：Type t = typeof(Chocolate);object o = Activator.CreateInstance(t,咖啡夹心巧克力,25.5);// 不能直接调用Chocolate上的实例，需要进行类型转换：Chocolate choco = o as Chocolate;dynamic反射Type t = typeof(Chocolate);// 动态类型可以直接调用dynamic o = Activator.CreateInstance(t,咖啡夹心巧克力,25.5); 静态构造函数VSCode构造函数快捷键：ctorclass Pie public static int Amount get; set; // 在类声明时就执行 static Pie() Amount = 100; public Pie() Amount += 1; Console.WriteLine(桌子上有派端上来，现在是0个派, Amount); ~Pie() Amount -= 1; Console.WriteLine(桌子上的派被拿走了，剩下0个派, Amount); 类的声明关键字 newpublicprotectedinternal 内部类，只有同一装配集内成员能够访问privateabstractsealed 密封类不可作为父类static Assembly Tip: Ctrl + - 跳转到上次光标快捷键每个项目的编译结果就是Assembly装配集，Assembly主要分为2类：exe 可执行文件dll 类库 类继承C#内所有类的基类都是ObjectType t = typeof(Candy);Type tb = t.BaseType;Console.WriteLIne(tb.FullName); // System.Object带有sealed关键字声明的类无法被继承，public sealed NoChildClassc#中只能继承自一个基类，但能实现多个基接口子类的访问权限不能超过父类 类扩展 类继承就是对父类进行横向和纵向的扩展：横向： 类属性和方法的增加纵向：对父类内属性和方法的重写class Chocolate : Candy public Chocolate(string subMaterial) this.mainMaterial = coco + subMaterial; class MilkChocolate : Chocolate // 表示调用父类构造函数时传递参数 // 构造器时不能被继承的 public MilkChocolate():base(milk) this.mainMaterial = coco + milk; public void ShowParentMat() Console.WriteLine (base.mainMaterial); 类继承和类成员访问级别关系 重写多态重写标识符：父类 virtual子类 override隐藏和重写的区别：方法属性不加重写标识，算作子类对父类的隐藏隐藏下父子类之间没有版本关系方法和属性的重写：// 父类class Candy private string flavor; public virtual string Flavor get return flavor; set flavor = value; // virtual标识符 public virtual void Cook() Console.WriteLine(Cook Candy); // 子类class Chocolate: Candy private string flavor; public override string Flavor get return flavor; set flavor = 巧克力+ + value; // override标识符 public override void Cook() Console.WriteLine(Cook Chocolate); 14.接口抽象类接口抽象类函数成员并未完全实现的类虚方法成员必须是public标识不能实例化，需要靠派生类来实现抽象方法纯虚方法声明关键字：abstract子方法实现关键字：override接口功能等同于纯抽象类// 接口interface IFood void Cook(); void Eat();// 抽象类abstract class Candy: IFood public void Eat() Console.WriteLine(美味！) public abstract void Cook();class Chocolate: Candy public override void Cook() Console.WriteLine(Cooking Chocolate...) 松耦合松耦合 使用接口，而不是具体类来作为另一个类的成员的类型，接口类成员使用该类的实现类赋值减轻两个类之间的耦合关系接口实现：public interface ICoffin double HasCoffin();接口实现类：public class Coffee: ICoffin public double HasCoffin() return 30.0; 主动耦合类：public class Custom ICoffin _coffee; public Custom(ICoffin coffee) _coffee = coffee; public string Drink() double coffin = _coffee.HasCoffin(); string mes = ; if(coffin = 0) mes = 无咖啡因 else if(coffin=30) mes = 低咖啡因 else if(coffin=60) mes = 适量咖啡因 else if(coffin=100) mes = 咖啡高浓度因 else mes = “致死量咖啡因” 主动耦合类的调用：Custom custom = new Ciustom(new Coffee());custom.Drink(); 单元测试解决方案 → 添加新项目 → xUnit测试松耦合的2种测试方式：创建类Moq方式一：创建类public class CoffeeTests [Fact] public void NoneCoffInCoffee_OK() var custom = new Custom(new NoneCoffinCoffee()); var actual = custom.Drink(); var expected = 无咖啡因添加; Assert.Equal(expected, actual); class NoneCoffinCoffee: InterfaceLearning.ICoffin public double HasCoffin() return 0; 方式二：Moq用NuGet搜索下载引入Moqpublic class CoffeeTests [Fact] public void NoneCoffInCoffee_OK() var mock = new MockICoffin(); mock.Setup(coffin = coffin.HasCoffin()).Returns(()=0); var custom = new Custom(mock.Object); var actual = custom.Drink(); var expected = 无咖啡因添加; Assert.Equal(expected, actual);","tags":["编程语言"]},{"title":"企业可视化大屏：基于ECharts实现的水球气泡散点图","path":"/2024/05/13/LiquidScatter/","content":"项目简介预览地址项目效果撇开列表进度条环形图这种比较一般的图表不看，整个项目的主要难点就在于散点图、散点图和它之后与圆环图的交互，这也是它的主要亮点。 项目难点项目难点 拿到设计图之后，首先注意到几个难点：水球气泡散点图如何实现单个水球图水球图如何映射到坐标系中水球+外环图如何实现这个图怎么实现和外侧水球图的交互动画任务进度工时趋势时间线图 技术选型开发框架 Vue3+Vite 都是我用的比较熟的：Vue3Vite资源加载可视化大屏对性能要求较高，因此图片尽量选取webp或者svg格式的图片据说还有一种方法：为了避免频繁的图片资源请求，将图片都用dataURL的格式加载 网络请求 axios 因为这个项目对实时性要求并不高，因此采用客户端向服务端定时请求的模式，但是有一点就是当数据请求不来时（可能是后台服务500，或者返回空数据），这里就有三种处理方式：什么都不处理，只对报错进行catch，这时页面会空白，用户体验会降低用loading页作遮罩使用Service Worker，可以把上次请求的结果作为本次的结果返回，页面内数据不变看了mdn关于 Service Worker 的介绍，主要是面向PWA应用的，所以这里决定采用使用loading页作遮罩的方式。可视化图表开发过程中的数据请求问题可视化图表开发的两个重点就是数据和图表，在开发过程中一般我都会模拟一些图表绘制的数据，并把图绘制出来，但是接口一旦对接之后就会出现各种各样奇怪的问题。可视化图表的数据处理真的非常重要！非常重要！非常重要！数据处理的几个可能出现的问题如下：后台提供数据和前端数据不一致：在请求到后台数据，和得到最终绘制出图表数据之间，尽量比较清晰集中的添加一层数据处理层，不要把数据处理分散到各种各样奇怪的地方考虑数据极端情况：除数为0、数组长度为0等等一类情况都需要被考虑在内，这些bug可能会藏得很深，到很后期的时候才显现出来贯穿整个开发流程的前端独立测试前期使用静态数据还好，但是如果切换为后台数据，中间逻辑大概率要调整，绘制逻辑也变得越来越复杂这个时候，如果要涉及到一些细节部分的修改，可能就会非常复杂，比如我想要让图表某个类别显示某个颜色啦，如果好巧不巧后端就不返回这个类别，那就看不到效果所以就算是数据已经从接口中获取了，也一定要做好测试数据的生成，将测试数据和后台数据同步后台服务断开时，前端要有离线模式继续支撑开发图表开发的数据源开发依赖数据进行展示的可视化项目，页面的展示依赖数据驱动。图表的开发比较特殊，比如ECharts，在使用vite提供的开发环境下，修改代码触发的热更新无法驱动页面ECharts图表的重绘，所以就需要每次都手动刷新页面查看修改后的效果，更致命的是，越到后期，图表的微调就有可能越复杂，这时如果图表的数据源已经使用接口数据了，就需要等待接口数据到来（数据量少还好，数据量多简直是折磨）以前参与开发的一个卫星轨迹图就有这种情况，上百条卫星带着各自在时间段里的轨迹数据对卫星点迹进行微调时，要用3-7s获取后台数据，再渲染，再查看效果，好窒息这个时候一般都会搭建一个临时的服务器，模拟后台接口，返回固定数据 图表技术：ECharts 一开始选用ECharts，是考虑到开发工期比较急，挑个比较熟的库就行。但是随着绘制的进行，还是觉得如果选用 D3 ，可能更适合这个项目（可惜我对D3不是很熟）但是我对ECharts的一些基础联动，比如dataZoom、动画、事件绑定、创建销毁之类的，我都比较熟悉总体来看，如果我对D3的熟悉程度允许的话，应该会选择D3。但是目前来看ECharts绘制出来的效果也还可以（就是中间有点小差错）图表的选择事实上，这个项目最后的大部分效果都能用ECharts实现，平面绘制，大多数涉及到的效果无非就是：尺寸、色彩、布局，静态页面的绘制一般涉及到的，大多数主流图表库都能够实现。当我说图表的选择时，实际上一般需要考虑的，是这个图表要实现的交互的上限是什么。因此首先就要先熟悉各个图表库的交互的特点，这个并不简单，但是我这里可以简化思维：如果产品经理和设计根本没设计交互，用ECharts，因为ECharts的交互和动画效果最为主流接受如果设计了交互，但是交互都比较保守，用ECharts，理由还是一样如果设计的交互非常新颖，ECharts已经满足不了，用自由度最高的，D3当然还有HighChart、AntV等等其它的选择，但有的时候真的不想考虑太多，顺手就行。但是这次的设计有一个点，用ECharts还是没有办法实现的，就是半透明颜色之间交叠时出现的加深效果： 设计图 实际效果 可以看到设计图中，颜色交叠处有种ps中正片叠底加深图层的感觉，但是实际的图表绘制中，颜色的交叠部分是上层的颜色覆盖下层的颜色，ECharts实际是提供混合模式配置项的，也就是blendMode 不开启blendMode 全开启blendMode 下层图层开启blendMode 上层图层开启blendMode 但非常坑爹的是，blendMode只支持2个值：lighter 变亮source-over 默认值并且只有在渲染器renderer为canvas类型时，blendMode才生效因为这里我用的是svg，所以大概率是没戏了。但是还有一种方案：绘制两层图层，一层用canvas绘制，用于颜色控制，一层用svg绘制，用于交互配置，不过太麻烦了，查看echarts-liquid库源码，github上已经很久没有更新过了，实际上结构并不复杂，如果花这么多时间基于现有的库去实现这样一种颜色混合的功能，说实话还不如研究一下如何自定义ECharts类型简单这里的label和text的颜色有一个反相效果（svg渲染中），实际上是两个文字叠在一起，一层作为底层，一层作为上层，上层文字被水波图形给剪掉了但是能看到，因为clip-path指定的仅仅是对应series中的水波path，这里也能看出canvas和svg处理图像的不同，svg没有颜色缓冲区的概念，更强调元素之间的绑定关系canvas会把画布上的颜色作为缓冲区进行维护，后加的颜色会在之前计算的颜色的基础上进行混合 时间线表技术：Vis-Timeline 选用 vis-timeline ，主要是考虑到它自带缩放和滚动的时间轴组件 动画：GSAP 没法用css动画插值的属性，可以用 GSAP 处理。用来处理不熟悉的svg动画也很方便 注意事项可视化大屏相对一般项目有几点需要注意的：自适应样式性能resize动画自适应用rem！用rem！用rem！rem依赖根节点的font-size进行尺寸判断，因此仅需要在首次进入页面和之后resize时动态修改根节点的font-size进行重新计算：// 此处最大适配宽度3840，最小适配宽度1024export function resize() return new Promise((resolve,reject)= let rootWidth = document.documentElement.clientWidth || document.body.clientWidth let rootDom = document.querySelector(html) let k = 16/1920 let b = 16 - 1920*k rootDom.style.fontSize = (k * rootWidth + b) + px )window.addEventListener(resize,resize)我用的是Vue框架，组件的mount一定要在resize之后进行，否则一些echarts表格开始绘制时，正确的rem大小还没有被计算出来：resize().then(res= app.mount(#app))另外，需要对网页能兼容的最大尺寸和最小尺寸进行配置：.wrapper background: #e9effa; width: 100%; height:67.5rem; min-width: 1024px; min-height:768px; max-width: 3840px; max-height:1838px; display: flex; flex-direction: column; position:absolute; overflow-x: hidden;将rem的动态范围也限制在这个范围之内，和《CSS揭秘》这本书作者强调的一样，样式编写需要DRY（Don’t Repeat Yourself）能用动态单位（em、rem、vh、vw）就用动态单位，灵活使用css变量、函数、响应式布局如果你只有通过修改大量css代码才能实现页面适配，那就要反思一下是不是你的页面实现存在问题。 ————《CSS揭秘》根据尺寸自适应页面大小样式性能css原生变量非常好用背景图片尽量选用svg或者webp格式直接使用dataurl编码的图片，无需请求资源，性能更高通过动态计算的配色方案往往效果更好，并且可维护性更好hsla非常好用resizeresize实际上就是另一种意义上的“自适应”，但是不同点在于我用了echarts，ECharts的resize需要手动触发，不仅如此，用css的rem控制的页面属性在resize时能够自适应，但是echarts里option的配置基本在创建的时候就写死了，我的做法是在window.resize时，重新计算option里面所有涉及单位的属性，不知道有没有更好的方法。anime不仅仅是可视化大屏，任何有很多动效需要配合的项目都是如此，那就是需要对这些被打的乱七八糟的动画帧进行统一管理，否则后期对某个动画帧的改变，会波及到整个页面其它动画的效果。 水球气泡散点图如何实现基本思路 首先抛开花里胡哨的包装，单看它要实现什么：X轴：任务数量Y轴：参与人数水波高度：任务进度气泡半径：项目工时气泡颜色：项目状态也就是说一张图展示5个要素，根据X轴、Y轴坐标进行映射，是散点图的特性，根据水波高度判断进度，是水球图的特性，根据工时对半径进行控制，是气泡图的特性，但是散点图也支持三种方式所以最接近我们要绘制的目标的实际是散点图，但是散点图上需要有一个类似水球图的波浪动画，因此有如下三种方式：利用散点图的symbol属性symbol属性支持DataURL类型的数据，因此完全可以对散点图的节点进行自定义化但是问题在于如果是吧另一张echarts图表的绘制结果canvassvg，转化为dataurl作为新节点的symbol，这是一张写死的图片，交互性非常有限，因此pass改进方式：不利用echarts实现的图表，而是自定义svg，将动画效果和交互都作为svg的一部分转换为dataUrl，保留交互性和动画利用echarts的custom图表知道有这种方式，但是不熟，所以pass利用echarts的水球图echarts本身支持水球图，可以将水球图作为散点映射到坐标系上，似乎只在坐标映射上有工作量，最终选择这种方式 坐标系映射这里的思路就是把坐标系和上面的散点图从绘制层面完全分离，不用ECharts提供的坐标系和数据的联动，而是手动实现中间的一些联动，也是考虑到这张图在坐标系上需要实现的联动效果不多，如果还要加上datazoom之类的坐标轴缩放、平移联动，可能会更加复杂拿到一堆数据后，需要做如下操作：计算出这批数据映射出球体的包围盒，得到整张图的left、right、top、bottom边界根据边界值，动态计算出坐标系的边界拿到边界，绘制出坐标系再将数据的x、y值在坐标系中的位置映射为px定位值，这里用的是ECharts提供的convertToPixel函数function convertAxisToPixel(data) return data.map(node= node.center = chart.convertToPixel( xAxisIndex:0, yAxisIndex:0, [node.taskNum, node.peopleNum] ) return node )最终就能将水球映射到页面中了，但是这种方法也有弊病：性能问题，每一个水球都是一个独立的series，和真正的散点图的性能相比很低坐标系边缘的计算比较复杂，涉及到更多数据处理的逻辑坐标系边界检测这里没有使用echarts自带的坐标系，手动实现坐标系的自适应，并非最初想的这么容易。由于球体和坐标系不在一张画布上，所以要知道球体是否出界，就必须知道画布的包围盒和坐标单位以计算右边缘坐标为例，基本的实现思路就是：初始化坐标轴右边缘为0开始遍历每个点计算点的右边缘如果点的右边缘超过当前坐标轴右边缘需要向坐标轴右侧添加单位（注意，在添加单位的同时，整体坐标单元也会缩小）计算出添加的单位数量右边缘加上添加数量，重新计算坐标单位遍历结束，计算完毕data.forEach((node, index)= // 计算x轴，y轴范围 let r2px = node.mapRadius/2/100*content_h // 半径 let x = (node.x - axis_range.x[0]) * x_unit let y = (axis_range.y[1] - node.y) * y_unit let left = x - r2px - gap_left let right = x + r2px + gap_right let top = y - r2px - gap_top let bottom = y + r2px + gap_bottom if(left0) // 左侧超过 let n = axis_range.x[1] - axis_range.x[0] let left_add = Math.ceil(((node.x - axis_range.x[0]) * content_w -r2px*n)/(r2px - content_w)) axis_range.x[0] -= left_add x_unit = countUnit(content_w, axis_range.x[1] - axis_range.x[0] ) if(rightcontent_w) // 右侧超过 let n = axis_range.x[1] - axis_range.x[0] let right_add = Math.ceil((content_w * n - (node.x - axis_range.x[0]) * content_w - r2px*n) / (r2px - content_w)) axis_range.x[1] += right_add x_unit = countUnit(content_w, axis_range.x[1] - axis_range.x[0] ) if(top0) // 上侧超过 let n = axis_range.y[1]-axis_range.y[0] let top_add = Math.ceil( (r2px*n - content_h*axis_range.y[1] + content_h * node.y) / (content_h - r2px) ) axis_range.y[1] += top_add y_unit = countUnit(content_h, axis_range.y[1] - axis_range.y[0] ) if(bottomcontent_h) // 下侧超过 let n = axis_range.y[1]-axis_range.y[0] let bottom_add = Math.ceil( (content_h*axis_range.y[1] - content_h*node.y)/(content_h-r2px) - n ) axis_range.y[0] -= bottom_add y_unit = countUnit(content_h, axis_range.y[1] - axis_range.y[0] ) // 推入均匀模式下的x、y值 x_category.push(node.x) y_category.push(node.y)) 数据重叠问题 可视化图表开发，数据非常重要，图表是用来突显数据的特性的，但如果数据没有这种特性，图表的优势就很难得到发挥，有时甚至给人的观感会非常糟糕这个图表的设计就是个例子，这种图用于展示那些在x轴、y轴上分散比较均匀，并且彼此很难重叠的数据较好，但是这里设计的是参与人数和任务数量，企业的项目一般都趋于同质化，大多数项目的参与人数和任务数量都差不多，所以最终真实数据填入后，一定会映射出非常密集的效果。但这是设计层面的问题，那么如何在知道点可能会变得很密集的情况下，从矢量层面也好，从视觉层面也好，将图表的效果优化呢？坐标轴模式转换好在产品经理提出一张图最多只绘制20个球（后面改成了15个），有了数量控制，就能提供一种均匀模式，之前之所以不均匀的原因就在于x轴、y轴都选用的是数据连续类型，数据是在0-max之间连贯映射的，因此还可能出现噪点数据，破坏整个映射的效果，均匀模式就是将x轴、y轴设置为离散类型，仅仅是按照从小到大的顺序排序，下面是连续模式和离散模式之间的对比：离散模式（先）&& 连续模式（后）半径散射这里水球的半径需要能够反映权重的大小，最初的做法是将最大半径和最小半径分别设置为高度的50%和10%，将水球的权重（0-1）线性映射到这个范围之中：let minRadius = 10, maxRadius = 50// node.effect为权重let radius = node.effect * (maxRadius - minRadius) + minRadius // 线性映射结果结果很快发现有问题：如果数据也是线性分布的，那效果还好，但抛去这个几乎不会出现的线性分布，其他时候效果都是很灾难的数据离散度高数据偏高，大球重叠 [y (max-min)x^2 + min]数据偏小，小球重叠 [y (max-min)x^(13) + min]数据离散度低一般数据都是挤在中间，导致不大不小的数据重叠在一起，最灾难的情况gt 大于平均值的数据数量lt 小于平均值的数据数量n 数据总数量a (gt - lt)ny a·x^2+(max-a-min)x+min如何计算数据的离散程度如何判断一组数据离散程度的高低？这里使用的是标准差方法：let variance = data.reduce((a,b)= return a + Math.pow(b-ave, 2),0)/data.length // 方差let standard_var = Math.sqrt (variance) // 标准差let effect = standard_var/avelet SDR = effect 0.25 // true表示数据相差大，false表示数据相差小console.log(`标准差：$standard_var，标准差大于指定值：$SDR，数据偏向：$dir`)因此也就是使用幂函数的方式进行映射处理幂函数映射最终的映射效果要好一些：颜色划界如果相邻两个元素的颜色能区分开，那是最好不过的了，（本项目中，最终终于把颜色从图例的意义中分离出来，用于区分相邻2个元素的颜色了） 水球选中当前问题 这张图绘制到现在都还算比较顺利，问题就出在这里了，因为我现在想要选中水球，但是我们此刻希望把它当做一个整体进行选中，这也是遵从散点图的symbol选中特性的一种交互，但是水球图的弊病现在暴露出来了：它的选中机制在水波上，没有提供整体选中的配置项（WTF）不仅如此，就连用echarts.on绑定的任何鼠标事件，竟然也只能由水波触发，那这用户肯定不能接受。 解决方法 奇怪的是，虽然我鼠标移入球体（没到水波部分）时，虽然鼠标事件没有被触发，但是鼠标的pointer样式却改变了，因此一定是有某种判断鼠标移入的方式的，在zrenderlibHandler.js中，找到了对鼠标pointer进行修改的代码：Handler.prototype.mousemove = function (event) var x = event.zrX; // 鼠标x var y = event.zrY; // 鼠标y var isOutside = isOutsideBoundary(this, x, y); // 判断鼠标是否落在包围盒外 var lastHovered = this._hovered; // 上一次hover的位置 var lastHoveredTarget = lastHovered.target; // 上一次hover的目标 if (lastHoveredTarget !lastHoveredTarget.__zr) lastHovered = this.findHover(lastHovered.x, lastHovered.y); lastHoveredTarget = lastHovered.target; // 如果落在包围盒外，创建一个新的hover对象，反之，找到当前hover对象 var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y); var hoveredTarget = hovered.target; // hover目标 var proxy = this.proxy; proxy.setCursor proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : default); if (lastHoveredTarget hoveredTarget !== lastHoveredTarget) this.dispatchToElement(lastHovered, mouseout, event); this.dispatchToElement(hovered, mousemove, event); if (hoveredTarget hoveredTarget !== lastHoveredTarget) this.dispatchToElement(hovered, mouseover, event); ;实际上能看到一个isOutsideBoundary函数是用于做鼠标移入判断的，于是我就想手动实现一个同样的包围盒判断，但是这个时候，canvas绘图的弊病就出来了，就是较低的dom交互自由度，我的所有水球都是绘制在一张canvas上的，这就意味着我需要获取到每个形状的元信息，经过非常复杂的判断才能知道我鼠标点击的是什么！还好EChats还提供了svg绘制的选项，用svg实现dom交互就简单多了：echarts.init(chartDom,,renderer:svg)我是可以获取到自己点击的元素了，但是怎么知道点击的是哪一个水球呢？打开chrome控制台查看dom树，能发现echarts使用svg绘制多个series的一个规律：它会把所有series绘制在一个svg内部的一个g中，并且按照z顺序进行从上到下的绘制，也就是说，如果它绘制一个水球需要16个标签，总绘制20个水球图，那么g中就会有16*20320个标签一个水球16个标签事实上，这里绘制标签的数量不一定是16，期间可能有涉及到富文本的标签（多个text标签），为实现阴影效果的标签，等等，但重点是绘制每个水球的标签数量都是固定的，且顺序不变，这就好像WebGL绘图中常用的ArrayBuffer一样，用索引进行区分。所以这里只需要根据绘制每个水球的标签数n，和鼠标移入标签在父元素g中的顺序，就能获知点击的是第一个水球：const svg = document.querySelector(`#$props.domId svg`)const svg_g = document.querySelector(`#$props.domId svg g`)const svg_children = Array.from(svg_g.children)const domNum = 16; // 一个svg包含16个标签let index = svg_children.indexOf(e.target)if(index0) let parent = e.target.parentNode index = svg_children.indexOf(parent) let seriesIndex = Math.floor(index/domNum) currentSeriesIndex = seriesIndex // 当前被触发的水球索引能获取到水球索引，但是这时还有问题，就是存在一些干扰因素，水球的阴影标签会导致实际的鼠标触发范围要大很多水球的波浪标签是一个被clip的path，实际的尺寸也要宽很多所以应该把这两个元素的鼠标事件禁掉（pointer-events:none），好在这两个效果都是用g标签实现的，和其它元素很好区分：// 对svg事件进行处理 波浪和阴影不可点击function svgEventHandle(svg) const allG = svg.querySelector(g).querySelectorAll(g) allG.forEach(g=g.style.pointerEvents = none)最后还有一个问题，echarts使用path绘制圆球，但是path最终的dom监听区域是一个方形，将这个圆球包围住，所以需要根据path的包围盒手动判断鼠标是否移入的是包围盒内的圆球区域，仅有移入圆球区域时才判断当前水球被选中：currentSeriesIndex = undefinedcurrentRect = undefinedsvg.style.cursor = defaultif(index=0) // svg dom判断点击到了东西 let seriesIndex = Math.floor(index/domNum) let path = svg_children[seriesIndex * domNum] // 目标series的范围圆 let rect = path.getBoundingClientRect() // 范围圆的包围盒子 let x = e.x , y = e.y; if(x=rect.left x=rect.right y=rect.top y=rect.bottom) // 目标在包围盒子内 let radius = rect.width/2 // 包围圆半径 let cx = rect.right - radius, cy = rect.bottom - radius // 圆心绝对位置 let dx = Math.abs(x - cx) , dy = Math.abs(y - cy) let diff = Math.sqrt(dx*dx + dy*dy) if(diff = radius) svg.style.cursor = pointer currentSeriesIndex = seriesIndex // 当前激活水球 currentRect = rect // 当前包围盒 辐射水球图 如何实现pie+liquid 乍一看这个图，似乎很像旭日图，因为中心球四周的弧度辐射出去的半径长短不一，但是旭日的半径延长出去是有层级关系的意义的，这里则不是，因此这里采用的是弧度饼图的方式，即有几个圆弧，就要在option.series中塞入几个元素，然后计算出每个圆弧的初始角度和结束角度。这里还有一个需要注意的是每一段圆环的渐变色，ECharts是提供渐变色的，在线性渐变中，设置渐变色的2端只能通过指定绘制元素上的一条方向向量的方式进行绘制就算是这里用的饼图也是一样，设置radial渐变也是以每个弧段以自己的中心做radial渐变所以这里每个弧段渐变色的方向向量都需要手动计算：let minRadius = innerRadius + 1 // 最小外半径（40 - 80）let maxRadius = 75 // 最大外半径let angleDiff = 135 // 角度偏移data.forEach((node,index)= let temp = [0,1].includes(index)?(index+1):index const i = (temp+1)%pieColor.length const color = pieColor[i] let pieOption = copy(pieOptionTemp) /** 计算外半径 */ const outerRadius = useEffectMap(node.valueEffect, minRadius, maxRadius) pieOption.radius[1] = `$outerRadius%` /** 计算起始角度 */ pieOption.startAngle = - index * (angle + gap) + angleDiff // let realAngle = angle20? 20:angle // 真正的跨越角度 pieOption.endAngle = pieOption.startAngle - angle // 行高应该为弧度的长度 let height = outerRadius * canvasSize[1]/100 * Math.sin(angle/180*Math.PI/2) pieOption.label.lineHeight = height pieOption.label.height = height let middle = (pieOption.endAngle + pieOption.startAngle)/2 /** 计算渐变 */ let x = Math.cos(-middle/180*Math.PI) let y = Math.sin(-middle/180*Math.PI) pieOption.itemStyle.color.x = x/2+0.5 pieOption.itemStyle.color.y = y/2+0.5 pieOption.itemStyle.color.x2 = -x/2+0.5 pieOption.itemStyle.color.y2 = -y/2+0.5 // 外圈颜色 pieOption.itemStyle.color.colorStops[0].color = getHSL(color.color, color.alpha) // 内圈颜色 pieOption.itemStyle.color.colorStops[1].color = getHSL(color.color, 30) options.push(pieOption))还有一点需要注意，就是当辐射弧段过多时，如果设置固定的字体大小，就会出现label挤在一起的情况，所以这里的label字体大小也需要动态计算 过渡动画点击水球后，水球从图上位置浮现出一个一模一样的替身，然后迁移到画布[30%, 50%]的位置。如何实现这个效果？实际上就是计算被点击点和目标点位之间的dx、dy，然后对辐射图的画布进行平移。使用gsap进行css transform插值，包围盒参与计算的注意事项这里计算实际的偏移量，使用到了包围盒，即被点击球体的包围盒。目标点位是[30%, 50%]，它的px坐标也比较好计算：// 获取画布饼图展示的中心点 [30%, 50%]function getCanvasPieCenter() const target = document.getElementById(props.domId) const boundBox = target.getBoundingClientRect() const grid = props.grid let canvasWidth = boundBox.width - grid.left - grid.right // 画布宽度 let canvasHeight = boundBox.height - grid.top - grid.bottom // 画布高度 canvasSize = [canvasWidth,canvasHeight] let halfWidth = canvasWidth * 0.3, halfHeight = canvasHeight * 0.5 // 一半的宽高 center[0] = halfWidth + boundBox.left + grid.left center[1] = halfHeight + boundBox.top + grid.top + window.scrollY这里得出的是目标点相对整个page（包括所有可滚动区域）的坐标，但是包围盒是相对view视口的，所以在页面有滚动时，一定要将scrollTop的值考虑在内，下面是包围盒中心点以及偏移距离的计算：// 获取偏移量function getRectCenter() // 当页面垂直滚动时，包围盒中心点会计算会忽略页面滚动值scrollTop rectCenter = [ // 包围盒的中心点 boundRect.left + boundRect.width/2, boundRect.top + boundRect.height/2 + window.scrollY ] // 目标圆当前中心点 const dX = center[0] - rectCenter[0] const dY = center[1] - rectCenter[1] // console.log(`centerX:$center[0] centerY:$center[1] rectCenterX:$rectCenter[0] rectCenterY:$rectCenter[1] dX:$dX dY:$dY`) return [dX,dY] 任务进度工时趋势时间线图时间线图 至此，看似所有最关键的问题都被解决了，但现在页面的切图刺客来了，以前对这种时间轴图表了解的确实不多，这里就用的我唯一比较熟悉的 vis-timeline之所以选择它，也是考虑到它提供的下面几个功能：时间轴缩放时间轴拖动时间单位自适应爆改vis-timelinevis-timeline不像echarts，它是基于dom的，所以css配置项全都丢给用户自己通过className进行配置，这一点让vis-timeline的样式自由度变得非常高，vis-timeline本身应该是支持用html定制其中的内容的，但是无奈这一点是我开发一半之后才在文档的犄角旮旯里找到的（vis-timeline的文档精简到一页就没了）所以我使用的方法就是简单粗暴的dom操作。这要从vis-timeline的一个钩子函数说起——onInitialDrawComplete这个函数代表时间轴表已经绘制完毕了，我需要根据之前标识的className，找到对应的dom，然后手动给里面加东西，vis-timeline此时的作用就像是提供一个模具，至于里面是什么，我自己添加。 let options = onInitialDrawComplete:()= // 绘制结束的回调 setProgressStyle() // 自定义进度图样式 setHeadStyle() // 自定义表头样式 addEvent() // 添加事件 loading.value = false , // ...timeline = new vis.Timeline(targetDom, itemData, groupData, options)懒加载带来的问题vis-timeline中，视口范围内的概念非常重要，时间单位跟随视口范围内的数据进行自适应，同时视口范围还规定了需要处理的数据有哪些。也就是懒加载，能够减少渲染时需要处理的数据数量。但是这也是比较坑爹的，这就说明一旦我规范了视口的大小，在图表实例化结束后，只有视口内的dom会被渲染出来，那么我就必须要在鼠标拖动或缩放到其它范围时，对dom进行重新填充操作，也就是配合vis-timeline的懒加载进行dom操作（噩梦）。但是这里水平和垂直的懒加载策略也不同：垂直懒加载，没有滚动到的group在压根就不存在dom树中水平懒加载，没有滚动到的item存在在dom树中，但是被通过css的transform属性移动到看不见的地方，并且vis-timeline将这些被隐藏的元素移动到父容器的后列（dom树顺序被修改了）针对这两点，采取如下策略：垂直懒加载直接一次性将所有高度都绘制出来，不要懒加载了至于滚动，通过css实现注意点：这里图表内有一个下拉操作，所以容器实际高度需要进行动态计算水平懒加载首先和垂直一样，时间范围首先拉倒最大至于下拉的柱状图的渲染，需要在下拉时，根据元素的transform判断这个元素是否被隐藏了，获取到没有被隐藏的元素对没有被隐藏的元素进行操作 未修复时，懒加载导致的dom计算错误 修复后 此处时间轴开发过程问题百出，代码也是修修补补，拆了东墙补西墙，尽管最终实现了产品想要的效果，但是从代码层面上的可复用性不高 其他无限滚动功能描述列表栏无限滚动，鼠标移入后停止滚动，鼠标移出继续滚动实现方式gsap插值控制dom的scrollTop列表尾部加上几个重复项，以实现循环假象比如容器视口内展示5个，列表数据为[1,2,3,4,5,6,7,8,9,10]列表数据应当填充为[1,2,3,4,5,6,7,8,9,10,1,2,3,4,5]用户鼠标控制动画mouseenter tween.pause暂停动画mouseleave tween.play继续动画鼠标控制动画看似没有什么问题，但是这里问题就来了：当用户鼠标移入滚动dom时，dom的scrollTop被改动了，此时鼠标移出，tween如果接着之前的位置向下滚动，肯定是不行的必须得接着用户滚动到的位置继续滚动所以在动画暂停滚轮自定义滚动之后，需要重新创建一个tween，它的目标值不变，依旧是容器的scrollHeight-scrollTop，但是它的持续时间需要按照比例计算了，得是当前动画滚动距离初始动画滚动距离*初始动画持续时间，然后再这个半截动画结束之后，将容器scrollTop置顶，重新发起循环的完整滚动动画：watch(loading,(nv,ov)= let dom = document.querySelector(#hot-kanban) if(nv == false) dom.scrollTop = 0 let scroll_h = dom.scrollHeight let dom_h = dom.clientHeight let offset = scroll_h - dom_h let delay = 3 let duration = 30 if(offset0) let initTweenOption = scrollTop:offset, duration:duration, ease:none, tween = gsap.to(dom, ...initTweenOption, delay:delay, ) dom.onmouseenter = e = tween.pause() // 动画暂停 dom.onscroll = e =dom.scrollTop == offset (dom.scrollTop = 0) // 开始监听用户滚动事件 dom.onmouseleave = e = let current_offset = offset - dom.scrollTop let radio = current_offset / offset * duration tween = gsap.to(dom, // 重新开启动画 scrollTop:offset, duration:radio, ease:none, onComplete:()= dom.scrollTop = 0 tween = gsap.to(dom,initTweenOption) tween.play() tween.repeat(-1) ) tween.play() tween.repeat(-1) else tween tween.kill() tween = null dom.onmouseenter = undefined dom.onmouseleave = undefined dom.onscroll = undefined ) 防遮遮挡浮窗字体背景反相处理 正常情况下 浮窗不遮挡上面字体字体在空间不足时反相处理 这里的字体和背景颜色反相处理，使用到css的mix-blend-mode属性 loading效果 CodePen参考：Chokcoco CodePen 这里的效果都是用css的filter实现的，父容器的contract和子容器的blur结合，能实现液体融合的效果，非常有趣，另外，用毛玻璃对彩色背景进行遮罩也能实现比较高级的效果。 结语上面记录了很多问题的解决方案，但大体看来，要么是在手动拓展组件无法带来的效果，echarts有这个图吗→如何实现→如何自定义交互→如何实现颜色混合要么是修复组件特性带来的bug，vis-timeline怎么会导致我找不到目标dom→原来是懒加载导致的→如何修复再回顾这些，最初选择图表库是为了节省时间，但是最终为了弥补库无法实现的效果，花费的时间和书写的代码可能还要多得多（写水球散点图的代码比echarts-liquid这个库的代码还要多，还不如研究研究echarts的custom类）最重要的还是把svg、canvas、dom、数学这些基础知识平时夯基础。 后记VisualMap之后又仔细阅读了一下echarts官网关于dataset和visualMap部分的介绍，发现当前的这种实现气泡图的方法，确实比较生硬，比如数据映射，visualMap可以非常简单的就实现某个属性根据权重在某个范围内的映射：option = dataset: source:[ // x y size [12, 323, 400, 11.2], [23, 167, 300, 8.3], [81, 284, 100, 12], [91, 413, 450, 4.1], [13, 287, 140, 13.5], [50, 250, 310, 15.5], ] , visualMap: show:false, dimension:3, // 映射维度 min:2, max:15, inRange: symbolSize:[5,60] // 气泡尺寸的范围 , xAxis:, yAxis:, series:[ type:scatter, encode:x:0,y:1, type:scatter, encode:x:0,y:2, ] 坐标映射bug手动实现坐标映射（仔细想想果然还是没有必要吧），之后测试过程中还是发现有bug，这是因为是一次遍历所有水球计算出上下左右边界的，遍历过程中可能出现这样的情况：水球A下边界出界，坐标系y轴下面加上几个单位，继续遍历水球B上边界出界，坐标系y轴上面加上几个单位此时由于单位变多，单位绝对长度变小，水球A又被挤出下边界了针对这个bug，可以将球体根据半径由小到大排序，从小的开始计算添加单位，这样更不容易出现在这种bug，也可以循环遍历，直到遍历结果为没有一个水球出界为止。","tags":["Web","可视化"]},{"title":"Web Video 使用问题记录","path":"/2024/04/01/BlobVideoUrl/","content":"问题背景参考文章： 为什么视频网站的视频链接地址是blob？最近在做一个web大屏项目，其中有很多视频需要同时播放，每个页面包括8个实时监控视频，再加上1个背景视频，再加上页面上繁重的dom渲染和css动画，运行起来巨卡，好不容易优化了之后，dom没这么卡了，但视频还是卡的出奇，于是就特地研究了下这块。 同源策略监控视频怎么就加载不出来呢？ 视频加载慢和视频格式有关吗视频加载为什么会慢？硬件问题：检查一下浏览器运行网页时的任务管理器资源占用值，CPU都飚到七八十的，电脑是真的*GPU烂的就把浏览器的硬件加速关了吧，CPU更烂的当我没说渲染策略问题：不该渲染的元素去掉，少加动画本地视频，不考虑网络问题，空白页面，不考虑渲染问题，为什么视频加载会这么慢呢，难道和编码相关吗？实时视频是以FMP4流的格式传输来的,后端还提供了其它一些格式的视频流：关于视频格式问题，实际上到现在也没有弄清楚：几个搜索关键字：WebRTC-Streamer RTSP Fetch流媒体播放策略历时数月钻研推流对比各种流媒体服务程序PK总结监控实时直播的四分屏的前端展示webrtcVUE3+TS+VITE+webrtc-streamer实现实时视频播放在web中播放rtsp视频方案对比HTML5 播放 RTSP 视频fetch+Blob从 Fetch 到 Streams —— 以流的角度处理网络请求Fetch API 教程但实际上，8个视频从来都没有一齐被加载出来过，从来都是加载出6个，后面就没音了，查看控制台，发现8个请求中总是有2个请求没法出去，被挂起了：然后我才知道同源策略有个路数限制，就是最多只能同时对一个协议+ip+端口请求6次，这里实时视频以FMP4流格式进行传输，接口需要一直保持连接，所以后面再发起的请求就分不到这6个名额了，参考Issues解决方法HTTP升级到2.0使用HTTP2.0解决浏览器限制同源HTTP1.x连接并发个数的问题怎样把网站升级到http2websocket + flv浏览器只能播放6路http-flv流的解决方法nginx代理解决网页视频最大只能播放6路的问题 Blob Url搜索关键字： Video Fetch Blob Url比较奇特的一点就是，这8个实时视频一番折腾后终于请求过来了，但实时视频要比本地视频流畅的多。为什么本地视频会这么卡呢？一开始我以为是视频编码的原因，于是将MP4类型的视频转换为webm类型的视频，结果不知道为什么webm视频一跳转就卡住。其实视频也不是一直很卡，而是和网页视频缓存条一样，时好时坏，直到我看到这篇博客：html5 video 视频页面内缓存 - 全量加载方法重点是，对普通视频，浏览器会播放一会缓冲一会，即局部下载，我的视频很短，但是会有很多跳转操作，如果能在一开始就把视频全量加载，就不怕后面局部加载时出现卡顿的情况了，实现视频全量加载而不是跟挤牙膏一样的方法就是fetch+blobfetch(url).then(res= if(!res.ok) throw new Error(network response was not ok) return res.blob()).then(blob= const url = URL.createObjectURL(blob) const sourceDom = document.createElement(source) video.src = url)需要注意的是，我这里使用的是videoJs播放器，使用blob url加载视频，需要将创建player的option中的type配置成视频对应的编码let options = autoPlay:true, muted:true, loop:true, preload:auto, type:video/mp4 IndexedDB对视频进行切片缓存fetch重请求导致的问题 使用fetch能够一次性加载完blob格式的视频，但是又出现新的问题：本地开发时，视频从本地加载，因此速度快，服务部署后，静态资源远程fetch需要一些时间（3分钟视频需要加载2分钟）并且每次加载网页都需要重新加载视频我尝试配置fetch的option中的 cache选项fetch(./xxx.mp4, cache:no-cache).then(res=)实际上是没有用的，因为：配置仅是告诉服务器客户端期待的回复方式，服务端如果不支持配置的方式的话也是无用的。对于ico、字体这种小文件，还比较好缓存，视频这么大的文件就不怎么好缓存了。 浏览器存储视频 视频大小：300MB左右视频长度：2分半MIME Type：videomp4一开始因为不知道有“存储限制”这个东西，我尝试使用localStorage存储这个300MB大小的视频，结果把浏览器卡死好几次，这是因为localStorage有存储限制测试localStorage大小Web Storage于是我想到有 indexedDB 这个东西。在用b站看视频时，同样是用blob格式fetch的视频数据就非常流畅，并且打开时会接着上一次播放，这里使用的也是用户的浏览器缓存。除了对视频的meta数据和时间帧进行缓存外，有些时候还会对blob格式的视频本身进行缓存： indexedDB的使用 参考文章IndexedDB使用与出坑指南（16年的文章）用promsie解决IndexedDb异步问题","tags":["Web"]},{"title":"Electron","path":"/2024/03/30/Electron/","content":"https://www.bilibili.com/video/BV1xd4y1J7dB/?p=2&spm_id_from=pageDriver&vd_source=f55c755ba9aae4a4382a0f9d56858d01https://puyixiu.github.io/%E5%8E%9F%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90 Electron介绍electron核心技术 Electron的三个核心组成：Chromium：浏览器渲染Node.js：文件读取Native apis：提供统一原生界面能力（操作系统交互）用Electron做的比较出名的软件大概就是VSCode了，electron主要的特点就是跨平台兼容性好，但是在内存占用方面也经常被人诟病，因为electron应用就算什么内容都没有，还有整整200MB的Chromium引擎包在里面 electron工作流程 桌面应用和web应用不同的是涉及到对操作系统的操作，但这一部分都由Native apis实现，前端工程师只需要关心渲染层面的东西就可以。electron中的两种进程：主进程 Main Process一个应用主进程唯一启动入口一般在main.js中（package.json中main配置入口）首先启动，启动后调用Native UI创建一个或多个BrowsersWindow界面渲染进程 Renderer Process一个应用可以有多个渲染进程在BrowersWindow上运行的进程各个渲染进程互不干扰，在自己的沙箱环境中运行各个进程之间使用IPC进行通信step1启动APPstep2主进程创建windowstep3window加载界面step4界面交互涉及到操作系统，渲染进程通过IPC和主进程通信，主进程再调用native apis Electron开发框架结构代码结构 官方提供的框架案例：入口文件main.jsconst app, BrowserWindow = require(electron)app.whenReady().then(()= let mainWin = new BrowserWindow( width:800, height:600 ) mainWin.loadFile(index.html) mainWin.on(close,()= console.log(close) mainWin = null ))app.on(window-all-closed,()= console.log(window-all-closed) app.quit()) 使用nodemon辅助开发nodemon 使用node命令启动server时，每当代码修改，都需要重启server：node server.jselectron开发也是这样，每当主进程代码（main.js）发生变化时，都需要重启项目：electron . 使用nodemon，可以监听指定源码的变化，自动执行命令：scripts: test: echo \\Error: no test specified\\ exit 1, start: nodemon --watch main.js --exec npm run dev, dev: electron . 生命周期生命周期 readyapp初始化完成dom-readywebContents监听，窗口文本加载完成did-finish-loadwebContents监听，导航完成时触发window-all-closed所有窗口都被关闭时触发before quit关闭窗口前触发will-quit窗口关闭应用程序退出时触发quit所有窗口被关闭时触发closed窗口被关闭时触发，此时应删除窗口引用可以在closed中将窗口对象置null进行内存回收 窗体窗体显示 由于窗体先创建后显示，因此在dom渲染之前会出现白屏的情况，可以先将窗口show设置为false，loadFile后监听ready-to-show事件，再用win.show将窗口调出：let mainWin = new BrowserWindow( width:800, height:600, show:false)mainWin.loadFile(index.html)mainWin.on(ready-to-show,()= mainWin.show())调出控制台快捷键：Ctrl+Shift+i多个窗体创建多个窗体如果MainWindow里渲染的界面有一个按钮，点击按钮，创建一个新界面，这意味着需要给按钮绑定一个事件，并在对应事件中进行窗口调用操作。在窗口对应的html文件中，引入js脚本，脚本内引入electron提供的用于创建窗口的对象：（这部分参考Electron最新版remote问题）注意：需要打开MainWindow中的WebPreferences.nodeIntegration后才能在渲染进程中使用node。调用Electron的API还需要打开WebPreferences中的两个属性：contextIsolation:false; // 上下文隔离enableRemoteModule:true; // 远程调用新版本的electron远程调用需要安装@electronremote库，注意，安装@electronremote库时报错可以用cnpm安装：cnpm install @electron/remote在渲染进程中，通过引入@electronremote远程调用api在主进程中需要对remote进行初始化：app.whenReady().then(()= let mainWin = new BrowserWindow(...) require(@electron/remote/main).initialize() require(@electron/remote/main).enable(mainWin.webContents))index.html引入的index.jsconst BrowserWindow = require(@electron/remote)window.addEventListener(DOMContentLoaded,()= const oBtn = document.getElementById(open-btn) oBtn.addEventListener(click,()= let win = new BrowserWindow( width:200, height:200 ) win.loadFile(remoteIndex.html) win.on(close,()= win = null ) )) 自定义窗体自定义窗口 和在渲染进程中创建一个新窗口一样，需要使用从remote中引用api进行窗口操作：getCurrentWindow 获取当前窗口win.close() 关闭当前窗口，会触发window.onbeforeunload事件win.isMaximized() 查询当前窗口是否已经最大化win.maximize() 窗口最大化显示win.restore() 窗口回归原始状态win.isMinimized() 窗口是否已经最小化显示win.minimize() 窗口最小化显示win.destroy() 摧毁当前窗口，不会触发onbeforeunload事件代码实现const getCurrentWindow = require(@electron/remote)window.addEventListener(DOMContentLoaded,()= let mainWindow = getCurrentWindow() // 获取当前Window const closeBtn = document.getElementById(close-btn) const maxBtn = document.getElementById(maximize-btn) const miniBtn = document.getElementById(minimize-btn) closeBtn.addEventListener(click,()= mainWindow.close() ) maxBtn.addEventListener(click,()= if(!mainWindow.isMaximized()) mainWindow.maximize() // 最大化 else mainWindow.restore() // 回到原始状态 ) miniBtn.addEventListener(click,()= if(!mainWindow.isMinimized()) mainWindow.minimize() // 最小化 ) window.onbeforeunload = ()= let mainWindow = getCurrentWindow() const dialogDom = document.getElementsByClassName(close-dialog)[0] dialogDom.style.display = flex const yesBtn = document.getElementsByClassName(close-yes)[0] const noBtn = document.getElementsByClassName(close-no)[0] yesBtn.addEventListener(click,()= mainWindow.destroy() // 需要销毁，使用close还会触发unbeforeLoad事件 ) noBtn.addEventListener(click,()= dialogDom.style.display = none ) return false ) 父子和模态窗体父子和模态窗口 有些应用程序点击按钮会出现一个弹窗，并且不能跨越弹窗点击到后面的窗口，这就是父子和模态窗口，需要在子窗口上配置parent和modal属性：let win = new BrowserWindow( parent:getCurrentWindow(), width:300, height:300, show:false, modal:true)渲染进程中创建子窗体，需要通过getCurrentWindow()设置parent父窗体，但是在主进程中创建子窗体时，需要给主进程提供一个父窗体标识，然后由BrowserWindow.fromId获取到目标窗体：保存父窗体的id：let mainWindowId = null //主窗口idapp.whenReady().then(()= let mainWindow = new BrowserWindow(...) mainWindowId = mainWindow.id // 记录id)子窗口创建时，parent指向id代表的窗体：let subWin1 = new BrowserWindow( width:400, height:300, parent:BrowserWindow.fromId(mainWindowId), webPreferences: nodeIntegration:true, contextIsolation:false, )父子窗体还有一个特点：父窗体在关闭后，子窗体同时也会被关闭 菜单自定义菜单 Menu介绍自定义菜单需要一个数组变量作为菜单配置：let menuTemp = [ label:文件, submenu:[ // 子菜单 label:打开, click() // 菜单点击事件 console.log(你按下打开按钮) , type:separator, // 分隔符 label:关于, role:about // electron内置的默认行为 , ] , label:角色, submenu:[ label:复制,role:copy, label:剪切,role:cut, label:黏贴,role:paste, label:最小化,role:minimize, ] , label:类型, submenu:[ // 多选 label:选项1, type:checkbox, label:选项2, type:checkbox, label:选项3, type:checkbox, type:separator, // 单选 label:item1, type:radio, label:item2, type:radio, label:item3, type:radio, type:separator, label:windows, type:submenu, role:windowMenu ] , label:其他, submenu: [ label:crazy, icon:./assets/crazy.png, // 自定义图标 accelerator: ctrl + p, // 自定义快捷键 click() console.log(going crazy) ] ]用配置生成菜单项，然后将生成的菜单项设置到应用的菜单中：let menu = Menu.buildFromTemplate(menuTemp)Menu.setApplicationMenu(menu) 动态创建菜单 动态创建菜单需要使用到MenuItem方法，现有一个菜单项的子菜单指向一个Menu类型的数据let menuItem = new Menu()let customMenu = new MenuItem( label:自定义, submenu:menuItem // 子菜单为一个Menu)要为子菜单动态添加菜单项，需要用到Menu.append方法为菜单添加子项：menuItem.append( new MenuItem( // 新菜单项 label:new menu item, type:normal )) 右键菜单 右键菜单的创建和导航栏菜单创建一样，都是由Menu.buildFromTemplate完成，不同在于不会使用Menu.setApplicationMenu,而是Menu.popup：const Menu,getCurrentWindow = require(@electron/remote)let contextTemp = [ label:测试, type:separator, label:其他,click:()=console.log(click click),]let menu = Menu.buildFromTemplate(contextTemp)window.addEventListener(DOMContentLoaded,()= window.addEventListener(contextmenu,ev= ev.preventDefault() menu.popup( window:getCurrentWindow() ) ,false)) 弹窗dialog Dialog Doc弹窗方法api：electron.dialog异步获取文件弹窗配置：btn.addEventListener(click,()= // 返回Promise dialog.showOpenDialog( defaultPath: __dirname, // 默认路径：当前目录 buttonLabel: 选好了, title:自定义标题, // openFile 打开文件 // openDirectory 打开目录 // multiSelections 多选 properties:[openFile, multiSelections], filters:[ // 配置获取文件的类型 name:code, extensions:[js,json,html], name:img, extensions:[ico,jpeg,png], name:media, extensions:[avi,mp4,mp3], ] ).then((ret)= console.log(ret.canceled) console.log(ret.filePaths) ))错误弹窗：errBtn.addEventListener(click,()= dialog.showErrorBox( Errorrrrrrrr, 错误内容 )) shellshell Shell可以用来：打开文件管理器将通过浏览器打开urlshell doc使用shell在资源管理器中打开文件目录：const shell = require(electron)const path = require(path)shell.showItemInFolder(path.resolve(__filename))shell在浏览器中打开链接：shell.openExternal(urlPath) // 外部浏览器打开链接 消息提示Notification Notifications Doc在electron应用中触发window.Notification，能够触发操作系统的消息提示，同时，还能监听到消息提示的点击事件let option = title:title123, body:something, icon:./app.ico// 创建消息let my_noti = new window.Notification(option.title, option)// 监听消息的点击my_noti.onclick = ()= console.log(消息被点击) 进程通信主进程与渲染进程通信主进程与渲染进程 主进程与渲染进程之间的通信有几类：渲染进程发起 - ipcRenderer异步同步主进程发起的通信 - ipcMain异步同步（不支持）异步通信 send异步通信是没有返回值的通信渲染进程 → 主进程渲染进程发送：asyncBtn.addEventListener(click,()= ipcRenderer.send(msg1,Render 发送异步请求到 Main))主进程回复：ipcMain.on(msg1, (ev, data)= // main 向 render 发送异步消息 ev.sender.send(msg1Re, Main 异步回复到 Render))渲染进程消息的发送&&主进程消息的回复控制台打印中文乱码bug使用chcp 65001命令改变当前活动代码页格式为utf-8主进程 → 渲染进程主进程需要通过根据当前focus的窗口的WebContent，来实现向指定渲染进程的通信：let menuTemp = [ label:send, click() // 实现一个向渲染进程通信的菜单按钮 BrowserWindow.getFocusedWindow().webContents.send(mtp,来自于自进程的消息) ]子进程开启事件的on监听： // 自进程发送的消息ipcRenderer.on(mtp,(ev,data)= console.log(data))点击send菜单按钮，主进程发送消息，子进程打印消息同步通信 sendSync同步通信只支持渲染进程向主进程发送，渲染进程可以用一个值接收sendSync的返回值： // 发送同步请求syncBtn.addEventListener(click,()= let res = ipcRenderer.sendSync(msg2,Render 发送同步请求到 Main) console.log(res))主进程通过设置returnValue作为返回值：ipcMain.on(msg2,(ev,data)= console.log(data) // 同步回复 ev.returnValue = Main 同步回复到 Render)渲染进程请求，主进程返回值 渲染进程之间传值方法1：localStorage传值 使用localStorage能够跨窗口传值，之前在一个vue项目中就遇到了跨窗口传值的需求，结果发现vuex无法跨窗口传值，所以用的localStoragelocalStorage的跨页面同步localStorage适合具有父子关系的窗口之间传值 方法2：通过主进程通信 A进程和Main建立通道B进程和Main建立通道AB进程就能通过Main进行通信：A进程和Main建立的通道：ipcRenderer.send(stm, text) // A → MainMain将A进程数据转发到B进程ipcMain.on(stm,(ev,data)= // Main ← A let targetWindow = BrowserWindow.fromId(id) // 获取到B窗口 targetWindow.webContents.send(msgAtoB,data) // Main → B )B进程接收数据ipcRenderer.on(msgAtoB,(ev,data)= // B ← Main // do something )通过主进程实现子窗口创建时传值通过主进程通信方式创建窗口的同时传值，父窗口渲染需要在告知主进程开启新窗口的同时传递值，然后在主窗口将子窗口进程创建好后，将值通过自通信的方式传递过去：父窗口通知主进程创建子窗口进程（监听did-finish-load事件）：ipcRenderer.send(openWin,123)主进程创建新窗口并传值：ipcMain.on(openWin,(ev,data)= let subWin1 = new BrowserWindow( width:400, height:300, parent:BrowserWindow.fromId(mainWindowId), webPreferences: nodeIntegration:true, contextIsolation:false, ) require(@electron/remote/main).enable(subWin1.webContents) subWin1.loadFile(subIndex.html) subWin1.on(close,()= subWin1 = null ) // 在创建窗口时传值 subWin1.webContents.on(did-finish-load,()= subWin1.webContents.send(its,data) ))子窗口监听：ipcRenderer.on(its,(ev,data)= alert(`父窗口传来的值：$data`)) 快捷键globalShortcut globalShortcut docglobalShortcut可以在操作系统中注册销毁全局快捷键。这种绑定是全局，即便是应用失去焦点，也能持续监听。在ready中注册快捷键app.on(ready,()= let res = globalShortcut.register(ctrl + q,()= console.log(something be active) ) if(!res)console.log(register fail) // 判断快捷键是否已经被注册 console.log(`[ctrl + q] 被注册情况：$globalShortcut.isRegistered(ctrl + q)`) console.log(`[tab] 被注册情况：$globalShortcut.isRegistered(tab)`))快捷键的销毁：app.on(will-quit,()= console.log(快捷键解绑) globalShortcut.unregister(ctrl + q) globalShortcut.unregisterAll()) 剪切板clipboard clipboard docnativeImage doc剪切板文本的读写：let res = null // 复制内容copyBtn.onclick = ()= res = clipboard.writeText(copyInput.value) // 写入pasteBtn.onclick = ()= pasteInput.value = clipboard.readText(res) // 读取剪切板图片的复制：const clipboard, nativeImage = require(electron)// 读入图片let imgData = nativeImage.createFromPath(assets/app.ico)clipboard.writeImage(imgData) // 剪切板写入图片let imgFromCb = clipboard.readImage() // 剪切板读出图片let imgDom = new Image()imgDom.src = imgFromCb.toDataURL() // nativeImage进行图片格式转换document.body.appendChild(imgDom)notenativeImage是electron为多种缩放大小准备的图标操作类，读取的图标具有一定格式要求（png、jpg、ico），还有一定尺寸要求（见官网介绍）如果尺寸和格式不满足要求，读入进来的图片就默认为空","tags":["Web"]},{"title":"electron-egg + vue3 + vite 实现桌面应用","path":"/2024/03/28/ElectronEgg/","content":"Electron-eggElectron-egg 官网地址Electron中文文档Electron-egg是对electron的二次包装，其中使用到的大部分API都和electron非常类似，使用起来最大的亮点就是 跨平台性好因为我也没用electron打过包就不过多胡诌了 实现过程STEP 1: 拉取electron-egg框架 按照官网的介绍，拉取electron-egg框架：git clone https://github.com/dromara/electron-egg.git拉取下来的文件目录目录介绍这里只介绍我本次项目用到的文件：build 打包用到的资源和脚本icons 后面打包成应用程序会用的图标data 内置数据库文件（没用到）electron 主进程服务addon 插件目录config 配置文件bin.js 开发环境配置config.default.js 默认配置 config.local.js dev环境加载config.prod.js 生产环境加载encrypt.js 加密配置文件builder.json 打包配置controller 控制器service 业务层preload 预加载jobs 任务index.js 主进程生命周期frontend 前端目录logs 日志out 打包可执行文件目录public 资源目录dist 前端打包放在这html 模版electron js加密文件images 一些图片main.js 入口文件 STEP 2: frontend包壳 使用electron-egg框架，前端开发实际的文件都是放在frontend目录下的，因此除了一些不必要的文件，我就直接把原先的vue+vite目录下的文件挪到frontend下了，frontend目录下的文件转到根目录下，安装electron-egg框架依赖包： npm run install转到frontend目录下，安装前端项目使用到的依赖包： cd frontend npm run install运行前端页面： npm run dev-frontend运行应用程序： npm run dev STEP 3: 打包 打包前端程序： npm run dev-frontend打包成可执行程序之前，需要先把打包好的前端程序移动到根目录下public文件夹中，用打包的dist替换原本的publicdist。这里框架也提供了命令： npm run rd打包成可执行文件exe： npm run build-w-64 踩坑记录运行白屏运行白屏 问题描述用npm run dev启动项目，electron弹出，一直停在loading的界面。解决方式官方整理的问题中也提到了这个问题，页面一直loading或白屏，就说明没有请求到对应的前端资源，官方提到可能是前端路由模式错误，不能是history，必须改成hashhash和history的区别解决方法1：检查端口号配置确保下面两个端口位置一致：vite.config.js server.portserver: port:8090, // 指定端口 host:trueelectronconfigbin.js dev.frontend.portdev: frontend: directory: ./frontend, cmd: npm, args: [run, dev], protocol: http://, hostname: localhost, port: 8090, // 指定端口 indexPath: index.html ,,并且确保此端口没有被其它服务占用解决方法2：检查vite.config.js中的base路由设置vite.config.js中，base基础路由必须是’.‘base:./ 图标无法更换图标无法更换 问题描述electronconfigbuilder.json中能够配置exe打包图标的样式，buildicons中存放着图标资源，但是更换图标后依旧无效问题解决因为windows缓存应用图标，清理图标缓存的方法cmd控制台输入：taskkill /im explorer.exe /fcd /d %userprofile%\\appdata\\localdel iconcache.mongodb /astart explorer.exeexit图标缓存的位置在：C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Windows\\Explorerexplorer.exe： 资源管理器iconcache.db 图标缓存文件 打包用到的icon生成打包用到的icon生成 问题描述因为上面提到的windows图标缓存的原因，改了很多次icon都没用，以为是icon的问题，于是试了很多生成icon的方法，都很艰难解决方法egg-electron官网也提供了2个图标生成工具，其中有个叫做icon-gen的npm包，能用命令一键生成尺寸不同的icon（大喜），而且作者甚至还贴心的把icon-gen的命令集成进去了（虽然我调用发现没用）拉取icon-gen库：icon-gen命令：icon-gen -i sample.png -o ./dist --ico --ico-sizes 16 # 16x16icon-gen -i sample.svg -o ./dist --ico # 转ico根据官方文档介绍，打包图标需要下面这些，而且名称不能修改： 窗口zoom不生效窗口zoom不生效 问题描述一个蠢问题导致了另一个蠢问题……用户屏幕分辨率是3840x2160的，开发用屏幕是1920x1080的，因为正好是我的两倍，所以我就把浏览器的放大倍数缩小到50%，然后把图切完了…… 这就等于没做屏幕适配，在浏览器可以通过ctrl+滚轮放大缩小倍数，但是桌面应用不行，但是在windowsOption中有个zoomFactor配置，可以配置放大倍数，我想让这个zoomFactor能够根据用户的屏幕进行适配，但别说适配了，这个值生效都难，就第一次配置生效了，之后接连修改好几次都没反应。气麻了。问题解决缓存，缓存，是因为有缓存！（麻了）Previous zoomFactor is getting cached, unless you manually reset browserWindow’s zoom缓存地址：C:\\Users\\Administrator\\AppData\\Roaming删掉就行了。至于根据屏幕分辨率设置zoomFactor这事，我一手准备好electron提供的screen.getPrimaryDisplay().size，获取主屏幕尺寸，一手准备好win.setZoomFactor设置缩放率。组合在一起，无事发生。至于为什么没有实现我想要的效果，到现在我都没弄明白。所以最后我还是乖乖的把px全都转换成了rem做页面适配…… electron安装失败electron安装失败 问题描述npm install electron -g报错：RequestError: unable to verify the first certificate解决方式参考博客cnpm安装：npm install cnpm -gcnpm install electron -g windows打包卡顿windows打包卡顿 问题描述使用electron-egg提供的win打包命令（首次），一直卡在包的下载上：downloading url=https://github.com/electron/electron/releases/download/v11.2.1/electron-v11.2.1-win32-ia32.zip size=74 MB parts=8还不只卡在这个包上，后面还有好几个包。解决方法参考博客镜像资源直接网上手动下载卡住的包，放在C:\\Users\\Administrator\\AppData\\Local\\electron\\Cache目录下 electron和chrome版本对应electron和chrome版本对应 问题描述打开electron项目，发现像background-clip、text-wrap等css样式失效，大概和electron对应的chrome版本较低有关。解决方式根绝electorn-egg提供的这份版本对应表进行更新：版本关系 ssl证书错误ssl证书错误 问题描述electron应用无法访问不安全地址解决方式在index.js中的ready回调函数中忽略证书验证：async ready () // ssl证书错误app.commandLine.appendSwitch(ignore-certificate-errors) 打包成exe后网络请求错误打包成exe后网络请求错误 问题描述打开election打包成的exe程序，发现网络请求路径全都变成了file:开头的请求解决方式1、将axios发送请求时替换成全路径打包后算桌面程序，没有http服务器支持，加载的是静态页面2、 electron开启允许跨域模式 webSecurity:false全路径请求会出现跨域问题，因此要设置忽略安全策略参考博客const getData = params = axios( method:get, // 全路径 url:https:192.168.0.1:8090/123/abc, params)webPreferences: webSecurity: false // 禁用同源策略 electron打包后应用文件体积大electron打包后应用文件体积大 问题描述暂且还不知道这个如何解决，但包壳前比包壳后多了250MB左右，其中还包含Chromium内核。解决方式","tags":["Web"]},{"title":"云服务器使用和服务部署（阿里云ECS+域名注册+SSL证书）","path":"/2024/03/25/AliECS/","content":"云服务器购买云服务器购买 这部分参考博客： 记录第一次Vue项目部署到阿里云Linux服务器上线的艰难历程借此文章记录一下自己的踩坑问题。 域名申请域名申请 参考博客： 如何申请域名、购买证书并在Nginx服务器上实现HTTPS？域名在阿里上买的，xyz后缀域名，首年6块钱（挺便宜）之后需要走实名认证，很快，但比较坑的是阿里实名认证完还得入库工信部系统，这得花2-3天的时间，如果工信部系统没有入库域名，域名网站就无法备案，没有备案的网站在网上挂一段时间就会被限制：有了域名之后就可以将域名和解析记录联系在一起，通过域名直接访问到指定ip地址： NginxNginx基础配置nginx配置 配置Nginx大多数时候都是以下2个步骤：配置nginx.conf文档vim /etc/nginx/nginx.conf重启nginxsystemctl restart nginx其他命令用的比较多的也就是下面这些：启动nginxsystemctl start nginx结束nginxsystemctl end nginx查看所有开启的nginx服务进程ps -ef | grep nginx杀死所有nginx进程killall nginx检查nginx.conf配置文件是否有语法错误nginx -t配置文件 nginx.conf这里我在8080918092三个端口上配了服务：# Homeserver listen 80; listen [::]:80; server_name www.e-duck.xyz; location / root /var/myapp/home/dist/; index index.html; try_files $uri $uri/ /index.html; error_page 404 /404.html; location = /404.html error_page 500 502 503 504 /50x.html; location = /50x.html # ThreeJsserver listen 8091; server_name www.e-duck.xyz; location / root /var/myapp/three/dist/; index index.html; try_files $uri $uri/ /index.html; # Lotteryserver listen 8092; server_name www.e-duck.xyz; location / root /var/myapp/lottery/dist/; index index.html; try_files $uri $uri/ /index.html; 就是非常普通的配置，但是实际上，一开始我觉得后面的端口号不好看，想用路由映射的方式映射到不同的服务上，似乎用proxy_pass或者alias都能实现，proxy_pass配置server listen 80; server_name www.e-duck.xyz; location / root /var/myapp/home/dist/; index index.html; try_files $uri $uri/ /index.html; location /lottery/ proxy_pass: www.e-duck.xyz:8091; server listen 8091; server_name www.e-duck.xyz; location / root /var/myapp/three/dist/; index index.html; try_files $uri $uri/ /index.html; alias配置server listen 80; server_name www.e-duck.xyz; location / root /var/myapp/home/dist/; index index.html; try_files $uri $uri/ /index.html; location /lottery/ root /var/myapp/three/dist/; index index.html; try_files $uri $uri/ /index.html; 但是实际这样配置的时候却发现，静态文件无法加载出来，打开网页控制台报错：Failed to load module script: Expected a JavaScript module script but the server responded with a MIME type of text/html. Strict MIME type checking is enforced for module scripts per HTML spec.这个问题我找了很久的解决方案，反正现在还是没有解决，所以干脆就恢复了端口的写法。 Nginx搭建静态资源服务器参考博客添加虚拟主机时，将root映射到本机存储资源的目录下，开启浏览目录权限：server listen 8008; server_name localhost; location / root /root/pic_lib; autoindex on; Nginx代理二级域名申请二级域名申请二级域名（阿里）在【阿里控制台云解析DNS域名解析解析设置】中，添加记录，新增二级域名在弹出的【添加记录】表单中，填写基础信息：记录类型：选择A- 指向IPV4类型主机记录：填写二级域名的前缀记录值：填写域名代理的IPV4地址TTL：DNS域名解析的记过在LocalDNS的生存时间 给二级域名申请证书一级域名在使用url访问时，实际上也默认加上了www前缀，申请方式参考下面【SSL配置】部分顶级域名和二级域名顶级域名（TLD）：xxx.com不带www直接以定义域名结尾的网址注册和管理由国际互联网名称与数字地址分配机构负责二级域名：www.xxx.com依附于一级域名在一级域名前加上一个特定前缀由各个国家和地区的注册服务商和机构负责 配置Nginx代理参考配置：nginx开启HTTP2Nginx配置主域名和二级域名注意点：在listen的端口后加上http2表示开启http2传输在80端口处进行拦截重定向主域名和二级域名的关键在于server_name的设置主域名二级域名e-duck.xyz############## 主域名站点 ##################server listen 80; server_name e-duck.xyz; rewrite ^(.*)$ https://$host$1 permanent;server listen 443 ssl http2; #域名 server_name e-duck.xyz; #ssl证书的pem文件路径 ssl_certificate /etc/nginx/cert.pem; #ssl证书的key文件路径 ssl_certificate_key /etc/nginx/key.pem; location / root /var/myapp/home/dist/; index index.html; error_page 404 /404.html; location = /404.html error_page 500 502 503 504 /50x.html; location = /50x.html next-lab.e-duck.xyz################ Next-Three-Lab ################server listen 443 ssl http2; # 关键部分：设置服务器域名 server_name next-lab.e-duck.xyz; #ssl证书的pem文件路径 ssl_certificate /home/key_cert/next_lab_e_duck_xyz/cert.pem; #ssl证书的key文件路径 ssl_certificate_key /home/key_cert/next_lab_e_duck_xyz/key.pem; ssl_session_timeout 5m; ssl_prefer_server_ciphers on; # 使用的加密套件 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 使用的TLS协议类型，自行评估是否配置TLSv1.1协议 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; location / root /var/myapp/next_react_lab/out/; index index.html; server listen 80; server_name next-lab.e-duck.xyz; return 301 https://$host$request_uri; 端口配置端口配置 参考博客： 阿里云服务器开放端口的正确方式需要外界访问的端口服务需要再云服务器中进行开放，这个可以在阿里云服务器上配置，也可以通过命令行配置：开放指定端口firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙systemctl restart firewalld.service Tomcat浅配一下 操作系统 CentOS 7.9 64位Java 1.7.0tomcat 8.5.99配置Java参考博客： CentOS 7 安装和配置java环境 | tomcat启动“成功”，但是浏览器无法访问需要注意的是TomCat的版本和Java的版本一定要匹配，否则tomcat运行不起来，我是报缺包错误：Exception in thread main java.lang.UnsupportedClassVersionError: org/apache/catalina/startup/Bootstrap 检测Tomcat是否开启的方式：ps -ef | grep tomcat SSL配置流程简述 配置ACME使用ACME安装证书nginx配置ssl服务 配置ACMEACME：自动证书管理环境，是证书的签发工具acme.shCA：证书颁发机构Let’s Encrypt参考内容：Let’s Encrypt 证书申请及配置acme.sh官方中文文档acme.sh的安装安装acme.ch，顺便注册邮箱curl https://get.acme.sh | sh -s email=my@example.com安装到root目录下：~/.acme.sh/在root目录下创建一个.bashrc：vim .bashrc在bash中配置一个shell的alias：alias acme.sh=~/.acme.sh/acme.sh这样使用acme.sh命令更加方便：acme.sh -h 安装证书使用acme.sh安装证书 一共有2种生成证书的方式：http dns这里使用的是http方式生成证书需要将ca服务器修改为letsencrypt，默认是zerossl：acme.sh --set-default-ca --server letsencrypt指定域名和网站根目录，就可以生成证书了：acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/指定证书的安装位置：Apacheacme.sh --install-cert -d example.com \\--cert-file /path/to/certfile/in/apache/cert.pem \\--key-file /path/to/keyfile/in/apache/key.pem \\--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\--reloadcmd service apache2 force-reloadNginxacme.sh --install-cert -d example.com \\--key-file /path/to/keyfile/in/nginx/key.pem \\--fullchain-file /path/to/fullchain/nginx/cert.pem \\--reloadcmd service nginx force-reload检查已安装证书信息：acme.sh --info -d example.com Nginx配置Https参考博客检查nginx是否存在ssl模块：cd /usr/sbin./nginx -V如果configure arguments存在–with-https_ssl_module，说明存在ssl模块，可以直接进行配置注意要检查服务器的443端口是否开放配置模版将80端口重定向到443端口 jenkins的安装和配置jenkins的安装环境版本 操作系统：CentOS 7jdk：21.0.5maven: 3.8.8jenkins: 2.463 参考资料 centos7 + jdk 1.8+ maven + jenkins2.346的安装配置指南注意：由于这篇文章里使用的jenkins和jdk版本都比较低，到后面jenkins安装的插件都有不兼容的问题安装Maven2.4新版本jenkins配置方式jenkins卸载方式官方提供的jenkins安装方式jdk21的安装 安装jdk和maven安装jdk 安装地址下载tar.gz压缩包，传输到opt文件夹中，-bash-4.2# cd /opt # 进入存放tar包的文件夹内-bash-4.2# mkdir /usr/java # 创建/usr下的java文件夹-bash-4.2# tar -zxvf jdk-21_linux-x64_bin.tar.gz -C /usr/java #解压文件到/usr/java内配置环境变量-bash-4.2# vim /etc/profile # 编辑环境变量配置文件插入环境变量：export JAVA_HOME=/usr/local/jdk-21.0.5export PATH=$PATH:$JAVA_HOME/bin编辑结束后esc退出编辑器输入:wq保存修改重启并检查java版本-bash-4.2# source /etc/profile # 使配置文件生效-bash-4.2# java --version # 查询java版本 安装maven 下载地址将安装压缩包移动到opt目录下安装结束后基本和jdk的安装相同的步骤：解压文件到usrlocal下-base-4.2# cd /opt-base-4.2# tar -zxvf apache-maven-3.8.8-bin.tar.gz -C /usr/local配置maven环境变量编辑配置文件etcprofilevim /etc/profile添加环境变量export MAVEN_HOME=/usr/local/apache-maven-3.8.8 export PATH=$MAVEN_HOME/bin:$PATH刷新配置文件，检测是否成功source /etc/profilemvn -v 安装jenkins直接照搬官方的教程：安装jenkins拉取安装包：sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io-2023.key还要安装jenkins中用到的字体：sudo yum install fontconfig安装jenkins：yum install jenkins配置及运行jenkins：如果需要修改jenkins的端口，需要修改jenkins.service文件：vim /usr/lib/systemd/system/jenkins.service修改其中的环境变量JENKINS_PORT：Environment=“JENKINS_PORT=8888”修改完之后需要重新加载系统配置：systemctl daemon-reload启动jenkins：systemctl start jenkins 问题以及解决方法配置的时候遇到了很多坑，大部分时候都是由于jdk和jenkins版本不兼容导致的各种报错。java版本切换时，java命令刷新失败因为一开始安装的是1.8低版本的jdk，jenkins的很多插件都无法运行，于是要把旧版本的jdk删除掉，换新版本的，删除方式如下：删除所有名为java的文件find / -iname java | xargs -n 1000 rm -rf删除etcprofile中旧的jdk环境变量清除bash shell内部的哈希表缓存的命令（重要）如果不执行这一步，即便是删除了usrbinjava，执行java命令时还是会软链接到原先的文件夹hash -r运行java命令时报错：libjli.so not found把旧版本的java删除干净之后，重新安装java运行jenkins报错：usrsharejavajenkins.war not installed报错发生在切换java版本之后，把jenkins删除后重新安装应该可以运行jenkins报错：WARNING: An illegal reflective access operation has occurred高版本java配低版本jenkins导致的错误，换高版本jenkins运行jenkins报错：Caused by: java.io.IOException: Failed to bind to 0.0.0.00.0.0.0:80808080端口已经被人占用了，现用lsof命令检查一下端口状态：首先安装lsof命令（如果没有该命令的话）：sudo yum install lsof用lsof命令检查8080端口情况：sudo lsof -i 8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 6056 root 108u IPv6 6181134 0t0 TCP *:webcache (LISTEN)如果端口被占用，杀死占用端口的服务：sudo kill -9 6056卸载jenkins# rpm 卸载rpm -e jenkins# 检查是否卸载成功rpm -ql jenkins# 彻底删除残留文件find / -iname jenkins | xargs -n 1000 rm -rf jenkins的配置","tags":["DevOps"]},{"title":"PicBoo","path":"/2023/11/03/PicBoo/","content":"4e553101230d2a6139bf4ebca5206e100865995d37b8e5259c13d18d8c77dbdafb8ba61642286de09c14681a287b2e542d144b2ec91ec502e64d3fb9e91828c92f89a571518577749915c7162ff85fb458d7a0386d4d89a51b7e85cfa277cd1cb81a91b27142bcfc952b04a24c720a992ee665cff3ed2b5580ca496ceae617e0b6926fd0b62b49eaa29114fd1b6f00c1d4044cc69aedcd184cd6d9c69600f649e700fc993a24854a64df208028741bc197e71e69c4f8698e80217d582269283c9b170b574b6f4f70c0b5eee7f7779cd18d39663b17e31da4c52b77d6647e7561f6c59295a726fb513b8b449db6d69bab3471165ce663d862da4d075e39ddaef2725716b61e93e5ad27e7d3464a5a0d83236885b4b8030e607e08ed344f48b9f2c963c3fd472cc566ff22f1983c30a29afa4ba768b6de84926998e298d524d0fdc4d7a81cf5e6ea0522ca7d1b6de921882e9b873ea1949697f140b4c9d18d955ee57284b3755f5bd34eae6561c8cc5fd5e14a3c38dabc93bec185a89bb19400ebc872e82826ad29a95013585272c20c08e72e5062624e77ead6aee02c66783f8aff248a45b2a361888f613ae34d51201b4cfb838af21cdc1be13843c6b615cabb42f07f9e3c18130de48b90f4fc9139fab9cb01744e7c87d627e012d9b9842c10d96c7ae8318a12887baa1f5b90d98253868ef497cb3005fe0576523085007462bdb42c10c1086482864a64cfa97648f833f2eb1c032b76b05b46ec4ea160aa7fc9da874f7e8beaa60574cf47eb52d1dbce48fa477da0b9533e6ceb3975c598d0335277950fd1e067e25ca0e9405434a5186d3d0a1984e698b38905b009f255c28e3c20d366d4f563b9de0a9fbe9b911bc01644950fcf1662fa4d095ec0f5f685a06f46a8200acf3f8c9076a674b6ac478cf632affa0d7a2937c8d6bf14ed5f54f790c3ccb95e9b94e674cb2f35e90ef06517517b0c4b78e5e7a4643a753d724c36001d8415e41251d7ddaa259fe398f127c30e6b4191a55fefdeb347a1b47288a7c44e9d3a499c76e7f9d80202b0afdbb687b48695a24a38af82cb9e492b51497599b8c3a2dc8097902dac224b15ba69d62e6d08c4d22b683f4dc0dab597f6a88e9885e29afe10dc439ab44be0351f80dd1e89780a94c288a0215c8d2ede3a32bad31df945d25c671dc5355ae08ce0638a1409f8fd74bb268cccc163ec6a9dc0021648792063242e7f3685e15768edf6ca7f0e25fd7241c7ff10bd0cb094fb10f2f6c8e727a2632967aa2172f1bc131ddfa90fb43f7de28199448e4b0f31b258040e00f2c0e257e4970ff1ac81e0d2b68d2c46252491349258dd0b782354ccd65f98201852affe000ecb60c2e2bf61bb2631287da55d48a8acb12287615ba15177c87ff4eb64a42c2367f3849f6ee0cab9477b6c1681ac5c3b4f01b80c38b242a40830015d4002d2aef9e67efb71441a226e007b88a54804cf726f92184ed1395c84594f7a19e60db4577ebb2ee911dd3b8a23d39f519d7bb80c0cbb453714c88dcf85936e5022020b643dbafa7fd803f890a3cbbe134072f6964a73dcc7b9f264a9ee48185ffe29b8209344e6d1b41a2b94af3c4f52ac61d2932835df0ca7ceacad47ef03aba39f840f632029656027ea41c7afa7b42608e4341d9212f6fbac8620f0af63ea5eeb82591de72e30fe3c8fa3d9fa9ff828cfcd0a7a8a1c25fceb54ee9bcf8b876d097bf09cd58d43fb1b6b3c117bbcd6b51d6307b291a30427c59b258aef7d9b9056865ef24e3791010fdff19f56c9ed038922155b9275194c586bfb33c626c5a2601c8f87162437c861c66194221c7e8e93bba553839957855dbc6f8cced6ea027a77526df4a9cf5776980d89b54721e89a18f647850f029035a3c5754c21811c0d3a14b0cb4ebcc0c8e723f0820d0d9ff1d3d7d569109b8db4d4ef54c0082018087a8e707adcd9f461a7db2eba72e41d8c9b8bac3e0c5880fd5e007faaf01b408424807f743980dcd0db917caf0b46833e689290295ee97f4675381bd02db71dd8058b0dc9df9beb269209ec541cdd84ae317d4b9b9aa25c649f2cb630e4d013d30c89de74474b341401e93a69a471ee7f9eb288aea6981e794e760f1521858c76e72bba7299e763a8bd32ace659fe4becb160455b7288fb23ee7ba2676a645fa7beed6ca133155cb5bc4f9f63164a85f47c081996180099c9663d35a0a0ded2355c1c5962688d5439c4fa5e533897a31a3f65468bed9de0fc99ebcbd9e5baf34bf6ec8d47ae62c4e911505140f11ce708d24e8cdda04b7bddfd04314fccbf1d32f2d1a6545897f2488e720283ad74cc772766d8ade7d7118206f0d59d5d6fe54f48138f156fc3633eda0ee3af8983f5091409bb7062d366847582b53cf5db06933f11cb4003f6c8e3c191bf1145c70cffc5801d92f62be2838273882a3942e8fc4fbaf61c0a7bc544a0faf6e2efd984cf38ec9915e8fcc604dde7c604ff61b34e736dba5d422d45b3bf7acb6c924dbb4cd24d2fd9e4e2568988708c6a6d572be6d724b54f00bf5e025c227d4c2f12cc55cb840be6b68ec2ef40758028c78186368a35523ee4772cf5426342308f062bcf3862304b91f72610dfd76fcf3f45d4ea082251601e0200f0e102daed4e8ca7ce09d32de4b6ad1d453cf22b2115cec7dfb140d0c576a0bc88adcd226c24ea50adfe8befb47dbaaa5313b932fa8c9765b8fded7af8b56fbfe9830ea26eeda50e87dc51875cfcfb45f83bcb0b7b61bfe8d2175e7d0fce9fb2618e8351a3d7182f0a6b12126d996a74caea11d77b9a5a86ce3432de3c764156de9058b132d59a6272e5ce35cbffdbd1d5b4c416c5b38e8f658d54613ab83315658c86140298146455429f4cd48ff149335a491e585e8be9b8d55e48e4a12764b6fa8ff06392f3d1232b79d465975e139b7a23868ba7967751f23b1b713626efbdb70462da74e8cd31d6b5a4a869b4f0abaeee41fa4457df7dc9e50415cc50c542596e7d7bffda2dc62b19bec156c8c13ad4d86e6de16665bbb77f0fcc67a7cd71c135cdcd8aa7e91eed3a57b7c364f99fca3cb3136d8be214165f06e96eae4b99272378c2b185865250581cefdc6acb1ee95133a12468c75f41fac5f603e768d128002c3413ebf91df8ab547107c075025724b8bc08a218529916e7b840e9ade53bb2db7d1241f5ec7387aa2c1fad94420f936938ff207e09f0393cb691d130c32c33f1b138789ca934dd85b4883c27a1a743490c37872375f109c7fbb10c57f7d271f3610ab6a2c0ef06dde4e7bbdfa3ec1bc6df68bd6565c1dcd4518ba84dcfd131722208007e79b3b1b024fc67bc6e077e18875d537e2d474ce9464c17c374864be43e93e1bfdc549eff68a93a8f129ab1d6088d05ca62519dbf1195072aa1c7db2cdfa802e5b013b2815dd6fa0de7f93c8ace4f6b54e0c8203a8a7a379cd44a4735a710dcfb8bdce9fc61783a591fde7cad01dfe8c87e01cd835a284005bdcb5ff5d0e20ae801dfedd03a368ea0e27fb12cd105c5a0e41131ded27deb8fdb547a780bdc5ae984a4d57ff0f5b6af1e87b8bc85706ac625a988e5c60ebceafafef983c1ef38210466ee1ca65401c7c4ac2fcd4a9d08f8be2d1b4f98495666b62cc967dc589f807782a8c6c90c314aa31c8849c665848a40e3ab580dd86f38c119023cad35f92b990089237354ebcccd70ce1b65b6a4e6c788495ddf4bae618efcc019e10a4066609a16f9fd15e7ddde2b8a7f05c97d8410e9e7f5a66cdfbf56a20abb74b89e9950f270dfe9e6e794b2410e4c02c3370faf37712f43ffeedba2bd8e0adc7ff4cfd9e284db41fed369e275f83a1f6d8aed5521edab9327bf4b519bdc6dbd25f8499839b02f22b6674c817174fd6820aa336f048630611591361e125f9b9c7dcd1e7a0df2905aaa9ff6a9f812e431f0a9dabab6bfd1b5fb029b9f7af1310d0c8c764a7817fc3fc482c1802a9ac07adfc88763a1ffca91e33e7d4c524d2d6c625baceb41bb51c376471c91a3e63454fb2bb98d89943c16be82ad4be4a38d6d4816d2f7f3d8a2cbc028352da5bc5bac1762e27f07aa073b4dc733ac72d0e8ff13156313fbf52b15a43c610807682835ef3409ec60a406d47e70f93276c03bf2da9e3fb3791010b1874573092a0634830259cdce0af6f055a108a52037c93f3ebeac3c20f9f89bd7d6be9dfe8921e0fb8c6562816a1e78b6d33a9ee24bc7033ff5cdc945cc7cffbfca2476c0e54d118b888b666268c761527e5c273423b707cf785cb913562a6a2de73d43fa3580532554d2e7c5ee5c300d65959d4d244a25ca72767c350a6a2fb95a7b86a12a1c633a779943186604e1f0871bdf8b77dab9d98c209d922191ca05e0810ef24173d53eb03fad9652cc6b9bfaac290ecceefaf46a88bf4e13e4733c791fae28d05c60d0a61c80744d7ad6f83f0029e02f1417da4271a25846756bec506c0667eb12322ff8bc47c1b54e25592b39c9c689cf02a4f08aa88e2ec0a4e5f4e21af2aebd63a7542099c35dc85cf7dab8c9735d5c9c67d1a9aacfd256d7d50706d988ff92cf981bf659e2aec29221815e61473920174e03fb238eb3b65327b2fc63b04bce7aed20fc7fe9f13e3a8a53e2d45a9f44e1098d2c39462224fc7bdca22eb1bf80cf5e2c68b6b28d6ef33119d0c3f72824fa3e14dc95c8b15e85f8fee7d67925eb5ee79e2c04136b6f3d10fe9578ce54f18a1e1c49f9cadf36a18a2ffd2bcd85257b9f7082c427424ed625188f2578b823d8d0098de0f63615417b4bcc88e6df74898c9287532c032d4c48dce7a7fa9f0ba96822859d91fec31054392f2444158588e9daa83cd1070ad092eb1a9c3f6407137aa60f9176b2e65e480f7d476d5a08ad3542ff4866f5bbbee3aab85cdd7ca79a51abc380599858aadf2e04e9282195e20ebf01fd1744a83e8fc2218660a92793ac33fe0a8632446c5196cffd45665394a1425dc9a1839a46dd06155d8949e6f11768d95e8359f83e33d1451bdf869c0cb92916f2d2daa1abf040f6efdabee3adc44d6f9c97273c5e3838ca4506874a92068a71a04a63a145a3bbddb8ae7cd9ad0eae427f4355f1426da56872c5c993aa6cbd40ded51d13e35db9850923d8999cef9df951034cd9b9552709f44f37e7873301ea1ee6c7cf8cef3149c944202abe9140eb0e46b295feaea595998708e6d14482bbdb1ef752c6970d8f3e7d59071f7f6f12878a657612980acaf172c668dfd8bac5d9b36778c3461bd1c3108434e098ffdb71d597bb0143b9865b3351b16b3ef7bdcf7d15e2be9c853dae72d35bd8fdd673d0ee8ef0d361fc99acdd53f5a8bd88a95f3d021bfda7e9c7daf47ebba53d81308d943b3387279f705e6570c7221964975b20453e1af3392967246ec7c7943697b3abac2ffed7dd3ce3448c3d5e7754db9d5e2a2d62b7b6c362b639dd82fd0fe339d945e08e2eeb698dd949138470f3cd570808859d7a8934532e9e402f37fb0a51644d97b4d2fe52aac8feab02347bb7179673751129fb9277426ff2cc16d292a8ef7ac48a45cecb48ba6410065e68a05ef447a1bad8a4e142376dfea6cd14b23bd0c71e4659f4c4fa1a6514b14b546003d4982821145c914bead5d1cdab897f9aacbc008c5625f1d2b0c4211cec2ea8104383aed343ce5d9a65806f5ac4ddbf1590f4b26673b1f38311e0dfe379e46e0cae0f01841c8f8103e015401e7999cf7077141ea7dc8c147cdf8be5d70aabb37c88148db5bb341bd032c706fea1ad42ef76c60d7a97cf3d5d9405c4be59c6342d199e329f95a4724b57d3b76d75746a08567d694fe16eb7246bdfc6b49d9f00391f3034b3e15f9c71af2630ec97dd6a438fae71ae7770b607238b0ec30638af021dccf0d0e0500a4f6a4c2c2c41b0ca903027b8d2e575b4487c5e847df4fa817c8d2b2cae6c90f490531abf5884baaf8e9399312463498fc4ebd56f21c2ae7e63e1d3c1fe9b54e5e0a07ccfa22732baef83e7dc6cfb9de5011237939660a418265abcec03db5f11613d09e3863395cc263e5005002e6ca46dcf986be80f112e480bd7ef0c7ace36de3fc9acebcdc653f0ffde40dd5f8b9d7e064cb039cedd53afb3075684d624af420ebe834bd0006a51fb073c922e193d4e9212568ae21ef39a379ad663c0dbe9de570d8eec64e2ac7bf013c45f9ce2016751af5a0dfc9ad8adf8fb50d8b8abca2f2ae28c868fc30c5b8b43dddfa8774e9f144a5dcf388d7703641e26b9a99a4632da3913ebecf2758678c8277e52c4f2ad588f6277f5f368e17beeacbfd535d7530f904863722343cffdfde4f394ddbe30a1a93b84cd04bf8dbf8e0e33320f6fe828869283be8c48ca21c4c52c8bad747c45ed2be66410932ebdca56564236a8032d6cd3c4d67475232ae33d26ca7624d78a3bdf8db2538a79d2039f31bdbaa205de4292491f52ae707c433f99f88d0d00b3ebe93ab50d49f2b3b48a43a303bb90260c7b725f373dc2dabdbe9599d39fd0c26925d88e9f8d5695847760dbf6c39bc6a571885d04440b73e2a9cfd49758cf23cdd372b7c35491703734c6fcbf48fe72da3300c936cce9231aec11e32cf46a12813bcfecc9e1fa926e76688c7b68d214f9445cd09398a0311a4093ec56fdff7a456fa66007a30837090b6d2405c39d9aa987fcc81804def1b5dd4c3b21c28080c8954de538c59783ca4bdb8aadb7c6462652b8256ee095e40f54ab4bfef8be99cb2425a2eca61686fb1e0b8879b52b15750a5eae00a24caa6968235b0b32ac72521c060de6f59d340f6ed9dcd86f3b7675488eae41c17c327c2f13c389b22523627dfaffdef5b6ae02e9b9ceb5a2bfeac1b6a4289d742d54e55983eb6673a267e8fe938310f10e96cf4fbcf47111b78e653193d7275cab0d21058dd93b9f5aff51435963462a31211d4751861abe12b2cf2ddc738a0457039a088c0a1cf2ac90d22f1bd65372a0202e1a24e13c839188044f42d06ba9501cb42a884924df43039db0ae4a82e53a9c317007a7727c73cc73dd19bb7232b9fa4b8d415e2353881ab43d73a7ac201e881fb34e9adad159e600797b507fa660ae1bd09160488091a1bfc579f1e4613f71f6b03df12daf6a6eb7d64864a308e6b66a4f3e87357be6e0f8b7e48222cc3ab4f20a130a5c763140c92c59db35b1de6fb5ac7898737592578c2189eed6cc544f260df7e85416e7be48a4560239370ae5e16df3437e4d9b3b99b4c1cc7ea691b6108af3f1114ca8ab4ed333a74ebd85771f0a577609e8c3d52c90b066fa79bc334abc4ced0a38865a633fe66d27ec230e787afac7cda3e42d9d89dd29f1afd87d44f20f04dd897e45a493d24ef17f3ce77293e5616b6749f197313a1f604f0625cd18ae28745623ba1efede1ea1ec1b93a9157fc80269ff5b4d5ee6c9e3bf84ce672ee6200864dd002c0edf2672cd1b69003a5b5438cf083a963316e7a262ed895b129935ec6a207d3e5a1e063fb8b0d2cae8a142ec96c0656f1e85d3aa5847396c3d2c248b47daf4c329d0b64a4cd825817048e08b97d694829cf327cbcd8c4ff8b83a3fe75fa3796ed365415c4322a6128da722ce46899ab0d8b51d57b98b844fb195f68c8db9ec3914420e649fe26d5bf746079a8e8b7efc77385190d1773c889a7f83155de229d1a5b6907777d705c8f07d218c130e36a5f277215fbfa3e49cc22571b68611896b8d0ab3357b0491ec22b05d1e236290711db59c05bf621b9aec189637eafbb6ec9aae66a3a06606e796e262dba24a0ff636e701ace6158dff245dc59b2f7f5b43a9e65376ceea907a0bcaf52fdbe9d6048f4aec8210ac37ca4406aaae0c48b3a8bc82fd037e299a310c8a696b2f87084a2cf928e3082a88fd6859a1a24003147d133c3f3a6b632d88cd9303e0927ecc468b86e0fdce29ecb9875cf471ea5155d48a1715e7829f682e26f74c1a08a62899d57a4e1614e7bbf7e9a000cf71564a524b8ccfbf4a8c712ae40d950ca7f7a6a0819dfb8988ceeff94634629e0fbc9121262e4675ae16ae9080eeeb1273859a962674fc2818c1136d8d59f1b6bcd01f76a941f77d608053e8045736f3f54982379d06c71a6c75d818b1d9eff1ed5a8e85c8f63cff98c09215b3428d0e23ce2c6c5eda6de56084d2f8651ab3c1d5f1d1901162cb2cf288e4b8a06ef206695220dc3ab13a777d1ebd796d8084bc5c41dce853a170a041894e2d69b6d748127af94f1d89acc07fca144c9e7a5ab983eab624543be3939b13ea7f0695e21742f90663ec079874ae11d2ae5a8a506bef8d1ed18795e371d0d722eac0167317e05ece12ec3642afd2cfe329286a1e288dc676390c98abae8270b776e9deb2507cd2915d0a3dc2e371d8d64c20c3fa3e0b8e6f8d1c50baee126301013fcf4d8c68847dca5ac6f294d2d925a470792588caac1fbf6749d227558cd072174d7d5c262c550d02713219393195ccabdd0218f55a90131199fcaf68b1403425d1a55acc0696c885357493605c10c6754d7d194102954b6b2773664855221e1e92ef31e3e96576154a39a49e5f227872053871b07dd10055f6bd6a2b0314383da59472a6a55b9400954cd11953d7ff6b0a152df41534970927fa8fdfe153ddcfea6c89aa164ca54161f5ba99232283025fa5be45d06096977c0796b60cf619f2a864df869a7e856ef50407148a286000c5896f57d53b8834347e8728ca4f6607a58569c8ec044280ab426c1235f10859500fc98911ebca60b29e95c49b95d0a719759c00531440f5f650a57f8315fe4405ea42a2f0ffe1881476169021b914ed3fb8d9e73a8381bbccb03e9e4847adb6773f51c0a15534433be102e1808104a3524fba515b01666a7ed130cc61ac6b56b2f9e3f98553495520e0c15489d19a0416c965884257b62ad611845d380847da71d87948ce089ed0c7bfda8cfaad52a0662ab3cb72a99c8cea627173803c3bf965358e257d002ecd0b90366a3fbedf04d00782b17de53adec17622a61ebbe8acd3fdfbbf407e960ee0374968b2b76f57807630900994ea15386372d9ac7b317fe8b0a104b5dbba0641c174ed98ab520b8edf99a9e8aee86d304b3d49595b3b3c074afd4f44edf5b58bcaf611b41911c9bcbbe1505de9bd9849369ebfbf2298d476bd712bd713453c1661ed4c6b07589775e10d089fc5895c8ef4725a61925e9b63c2f4efb08a20228951237c0b29ce519a54b025a9f328785c2005b8b960743fdc9677451a624a38723525e03e1179f6019eda73e6101f35b0cada02ecdeed907cb878bcdb599c66fdf5f1bcfe31e98a32043f403563d42fa6e476cbc2cffdf49d68c032dc7f26f8bf1a31faf82f122a5717133b127a3e95c8a63ce9f549e54e7ec621ab80fa5b938318c0aa18eeefed43d656c4d8cd9c433af07996861acb361bdec70b4a172a95a09f933b81ea664064e7d99014d44c2652f616d357d6d94c597ee08f13165d9df0985d17e4437470439e703e7aa83e422010ee4f98bf94ecb9835553be73d4305e4243609af5cbad047134465479daaf17171d617f516f38491afe2ee2c8ecda8ca593fc6d62610c1c54ebdff9d54a1a07ed29f3f32c8a8b73c9254aa57cb0e341c7c74f98968a9bc0153d1b5e8d3fc56a460a16fc7b3fb22033c281ecb87eed3a636eae596e07b2829dceb785304f934c616e9e134c973169115ca268d61f44f50c8ee7ddbe942697e35fce70d72542982baea1b3a7b4772def2675e031b75da085b81a01a0f87d462eff45a7a734f383b2493d939ade0dfaa7588b204da379e7389112450a321137d6eb5c87df48af6bcaa950f1ca02d0d54543f376d558306ca853bc6aba8b1882c09ad88bfb63f874745860a262d947fdf5e894d6f2d28caa3af84728baa675303df70c000587c179119e52ae8922bce4741eed2b6baf657a0a0e0eff09c37889feaa0df37ff34dd37b0f20ae9c051022d80f7370ed14717514a0dbde0473ddd84b738cfb22c1f46fbddf5c5a230eaa27990f2ddd92b1df0c8b69218bbbea13cf0de7f6ee1f681aaa8215ac70c923478fc0d8910b7a19bdc5ddc2ac741ed38d11689b34be886b4896e5e5664cef2a3ced0d863d515391d86c25815b368adf0971e12b831ef5cac612a662e8c132ee0837ffe0a24a69251c2dce2c88c329e3cd6c57b606116cafb66669e7fe9315a39baf8a7e6d1eff9afbdd0203c7967c587ecb73d0c16abc8c841276422472bd8ce5aae861cc3ace7593b95e1dbb77fca7b7d96764eb03d243bb855ccaf53985e5ed5bfe75caded489d9049ae9634a62ab9ad80f22dc8b3355981e53a02ca18632ef5c8d33c82b40fe5b1e0181bea6259c1064f8ba35311752e3ee906582925645d614b525db7aafedc108e7550bdc359ed5b9902dd4a9ae9330c668e7e040ec31eca321c47d4fdd6ff0fb85f83f7f3e03926c83cfdbf920aad69bdba03a45372892c04c71e8d4eef69cb096511354d162bd37b9f6467714eec2e74c7cf6045e3f18c5926e3efd78e9667c7f155b7fb0624bfa2d2cc31f62b81923228b7c4d6d1ab3a6d0e32857462fc2973129e049931a93b804ed6c009b9a0bbf08e23c16bc188ad630bf51e6f4a6ba272186ad29311c7dae47924ee16846e98fe2d752f026ce24ab161a952f86834c399312304db07b85a0d159b6408777c304e35b42ee3f71eced879ed5e80b61cb199e0e1fde5b3b9aece168d6f854df3894595e6218daf837dffdee61f54f2e7f26153e59b72ebabd7ee61adb7dbee22f5378745e62b0f838d739f4f8899737eda5d94f51e9b7d3ab7c32b4379248d50c4318922489e055a15c8f8aef6beb3903b3678975368565ed6ad1374a35c08cfd970533f9fdb8af4695b1d7fc1553807e14548b9b7db203a92ab268fd683b5da583a058f7f4f69eb34c2032f448a2b4da65c269a20ec6ccbe1639cd2a2b0da5c478812c0448e28a14a5e591e04c2338a2e6dab7c56436845a72397b3b515ae2a0be25a252f53897506b6ddc9b10fb89c85215a521257689c127dde4fa56adc9469ec16522431a633a022077370ecf45c0032de3b3954ca38f1a4f66f0a380861570a0c8e968878b1d116b7bcecae148e3a8ed836fdb58bfc667c1c78fb0393961218e769d651d64962c75da97e966e4cd40dcb4ac83b48fb512a137d09e7d25ba5aabfaae92299e7102c24c88e8a26d8815f5db6348c97014d0786312afe094b5071e80b4da5dbe639367d85ecdda7a68f14862cdb938a9ad863416394e5d3af0a656f9df125108cc63d595dd4b5902e56f6ee928e63d70dd80a31e9ebc5aad4e0a6cd520d5870170653fac23982289dae95905cdfe56a7dee963131f09c85f48cdbf840569aa748e4b925fcae61efe742677b18f8b72214169f34559345a936f7fb8569de5323b7a6aaa34fb889458beea552ec394bcae0313363c54a68fce492271b15d570249cb3003ea7af235cad179521404cc834b8f0964afb6d0c30ac84a4605b5db964775ab0eb9c51e87444208c04738f50819e086cb8055a627ef658ac361317c5526c8f1d9069fbe2fb4181d8d10e32fe3a89ea3f038aa5b1f0456b97e5692cbb51d1cd3859fa2dbfb5b3bdcea296a7fbdf59647131f6fcca2f60e8a6ffec285ac393d40c8770df5a4b0a1014407549df96eec772b0916ca313f6477e08b74e28adf658b7c712f057e2975e241a16a9ac53c4339fe0176e24ea9c3368401f4ccbc329c69455afff37096a77a830493b052a261301022647f10d81cce02af1111b8b2c1bce1f206501f0e457072092b9144999a1d7b62f6f7626ae34c37f7c70fb8d3a981f78946381d6a44958854ffc06be0f08f335d91e76b1822d16c26dccdcbe00906e067b99bf931bffb4625a29ee7d187e827b8b8fc006a2478e5f241d6d424025e107c6681f3deda7c84c19561d292154cce271cc1c2ebf3b8ce21f1953b3b8c2b32d279a0d2182fa657b153c22fdf9479b8cc4c4c25145688e19b4bed32def5900fe10efb455ec0343ec4ec4d5a7fc8a5451a542006a5942475133e1e142d66389884e7ddf7aff5e955a87aba0716995dcbadc5818ade3cb4ac9b8cdf6654f3bfc18df5e309af9d16c77aceddc0726e49bf05a10d66c1bbe53a1ef24532e6ffff4cc94fcf5ab2d925597df75a96045236afa54432c614f314745980aabfefa1519cbb3128aadf5b25c0517365df591b7df9ebd25dce654270264933ddd8abd9295a826d5644d7ce6c3fdd54a10a435bb43704d01986befac2c7eccdb0deb1cc8877d44bbefd4617fbe4a269a733c46083cb3a1f5e5e7ddf8d9f47db292a8a8c8ad7322beb734f4557319acd0bd223fcd6cf0139f37d5d2f934339f1c3248985ad1a6e068b2c3434f73b8cbec56a52f49bc9530cbc902fd756ab0ba0ffc1d75baf43f577e0e8894ff6db890c85bc589753565ece4ba506863a7b9317a8ba4b5b8250d271c60677c2f2bf8a7357f386e8c8551c796f629092e58a472b705ac8c5c77b84aea9fd37385475ca66b092ba4dafe854f0de41b51be1f5ad9c08a79c0c5065898277b187391a9446177cbd7c1cd9525a74fa193df4d6f91efca29a4d0f9f75f87adf89d9c5e05876fbd32646ce17e15165858cef5114c352c5ae6ed0ac3167c4ced7ba40e2149df67179b7cb958900f0433ba0fbb9d14bd76c0d1d24bace7261f8c5ced3f912d08319001917424d10d1537f6ad381bca25756a1e04931890e84ba13728468d0f7c01ff41d6aa09a7e7be209fb6ca5d2f78f6366146d4e428f744f479255eae1dcc0c53a7e576b575f0fdff45d13f84f87ec5da1e3f99828bd02fecd127ae671b15091a634fb0e93168ade51676c3c3f6a34e917ae2492df5ca7dc8a60ce417641e9a2efb88a77d4f557f060dda25750515ce8da9245be81562ae6bd331faa5fb8585a2e51443f918245c7d8e3b36f38caf019b7c87bec6720062f0223298b6f4a5855755a0efeb37eeb63df4e0f6c60c84433c12b743d8b187a4dee8770f151a8c37c6c31068a104dbe7956c6ab17e584b85ea5c7e7356043b2f120f5c6c6b166e735e5078c3904c0408589a360164fd50d5088584c4c8bb681388cf02bae24d44248cf549d60b582a009995640e737b63593b49b32e24882627f36de7e34209dd41bd42119f9b15b67e686bf9a3ef727d65154135274248968ffc1c9372602936c1bd7abe7144eb61d5b5e4d82c09bfd915011e92d93e578ef0f31380711ef6c5e053f5382692430f864d77986614f3353e8b95bd668b7b276519ea5f34fae1805be8207b81bdd7de09ffec328b09f858472b02423fdb04112734e4d358d4901d8db6c48fefe0438dfca87f1e01f03e6b9adf31ed14046e52a808b8afda043cf3548a418053da2acd3bdb93a7c903f6da3f819b4212f57cf9d503bb2e5931f5536d45b22db3092135744926adaab94aa010c5ec923444dcb425d83dccd7fe33bc243096cb1b14f8283b9303009d0c285343d8753a0de84039f790dde3036f85f0404685c2ba546a44097d111c3b66dec6e21055501ee188f5eccba175cd91d41abe499c015101b0d7e895af0137218ae4bf7cba4c4beb4e06b499db5dee9a7fdb2a0caca4dda63cecdc25527de33622334c4cf5a93fc4dd907415c91268aabf7aff934e1108d1f13f34ea04efd1ccef1d38d888216918c6ee919c38517fba82a93afec97bc71cfa31e61654511edd98b605c8e8ddbc1521d2f6b0c21ab48fefeb93b2c05b647d4f39f081d9463bfcbf8775226388479b8d1e3ac5b9db76abf78b61085870d2ddac22f6d2c5389e49ffaa5eb72de049764ef86cab3aa79a6877820cf5b709abc18470c69451f3dad1ba027fb862838b46fa827d13f39cd20f951e038b2523bf0f93d01d5009b8d21fd165aa30631033f69e9e1924ce91f1ead2ca52789b45f2d47009cd9f67a33765ec80e5bcfbe32ac6335bb703d573d5db9a347dedc5c1a02945a7c8c0628925df7f229f720561fd4abd3ce7e2dd12b1dc7cd60b9b9e59e563b8ada9363033b7b84e4156f841f59be1bb3be1cd16a70c21e15301244c7f88b31d420c51699067f3ba7379a3b2557560fbbed6daa20cbb53b850c8b1777e80f71dd687c81b101ca3509969184237eeb1843bef4d73a8a7e61431212cfabd297635ba8294e4b7a6ca5e5a3e9b16efb2bc20d845b5db62ced0b866534bfd07f1ccc9b644186df175206650d0cea07978bd3d3899f6e9880d7c8dbd050988c07142d4266166f048b190403c8d60086cf0318c81ee5808672a6706323a9047ff2775b2aa5701513ef52e7b45a35fcfdfe1846db2ed5a04c8b57b58ef744db15873df2b3af0cd4f31835f4799413868eb8034bf702d9bc74747911beb6962957000765dd30c83bf82a175cb8183a011fd8f28390ddda89ffbaa57c4d8a56d474dacbfb1fb95b26ee65792a794e8574f27c76b8691a13404f65b1b11bea02c54dcb995c7ebf9d7926db2b2df6ad4c6df77cddce90d172a3bcb51ee55847c9beca85e75b21f47c4b6873a3558c5c0e5a1cc1859c8a891405b5ccbd52758f46c6985ba4bc8f6221e1a212dc5dda29fe5ba3103ab5ea873f9b18d7adf0bbb1e2ca147f3a16baf5fb46fa4d9c11dbc6141c15668ad8b55f08aed450b40a37b6ead504b3714c1392ad1c029c713308e79105ed95adcdbe6412d4e775ac345eb5c189da140141cf4902ff3939a4cf7b3a8b5e388b1e1b323d374c3d91629c945f389045191ea3c3ca51a38b85482534f724aa3997ac9cbb9df3a94a8a93027fae232dc67d54141d40ddc2ed18a5e02a350d14bc938b360bb22c6fac12b23ebebbed9fa27edc8a1f8d1ca908830d0a98fc37b9c873028798cffec6f5e5bd2fb7a490f0042361f2b1cda23abe14a91fdabf599b98421cbb9b2f8449b4b701f41081aa1b3f5abdb1a8abfb91e5329b4fe56769f376a14030d8c1fb429527b5d08d59fa1a64cff1ccb4811fb1e625213b933ca37d829a192785872668adef997317e5f96d431e2809c0b255df583c316a67a693396f62719bd9538eb0ae15138bee54d5d36751ca2d6b0da42d3ca719ededb98f3f0bedeb5ccaf808037627d38b29dafc521174ae06f307c5af2d29ff84d0614902b54d5a2c8478c47ef5413963dfcfe2ff8dbab4cf149aa21d067fe6607fa420339bb56f4332b1bb719d5b77442b202ef14e6aa6e794172f188c7d1c21c09dfeb97de81c0c6c0ddfd76b6b41abdb6b28638b38af19c2fac88ad38b07c0b5994e3662f9364e36b55e375334184ea25d406730dae049af9750b75206b006a9b3b34843a2b6403749096bbb9698e35a6bf4e2a1812d5a52b469a0155db938f19d5b17f3196d1edb142dea4c45f436531cb982d57a19358a3dbed1f8f69b2869ab12a3dda04a2f0187e101e12c2a68053884c0531c6b3d94644ea9affd966781b0790d63c2b708bc3a4c96989e5adebb63ad95c45e41ec31318cdf3ab854950be418ff68ce0a0c18512233d2c96f440b70eeadad9915b04ffea1b80323d3f1c1cd9cda1d1b621ea5befe6a440492a55bcf72b1c4e58c692d7229bb1cec2462f3ca69972586e2ece33027ee8b94ed32913a154209bdb894f9eb809139cdb7759880129a90138de4d62bdd4299694fa4963cc4c5e07b2ed217e7af5135eda09d9119596af87b6cf51f9de146e5866650c6754502ea32df9bb8dea864fbdc016d9dc02d27935f7d6e76687dd341dd3cdef40940b10a9965bae9f759d815e37761c9cac8cfb6bbb9be307c376e9ae80b044178537e2822ac69832b66ea5475354dbec6f8ac41e6534c0aaa7772408872418122b137eff0d47c609aef29b27ae0cc301dce207b362b9d9c1eb51ebfe3d67d1dba7af89cae2cf5058e63f26d9f195e77b62d023f338abb80940c6bef1add0b14473cff0eda5cdb884e9dfe8f61aedef107c62ac9b91f6abfb7e7c344f54d381be0339227819c2858e4b9cf68245884a9e5e060d23f4a5c3f04820db5c2bed928e277ed04fac03aea1d7ff9156236c7b16e4bf9e788e4c1e7211f5595d1c26158af4c88cd26c7fc728062238ed1c67b6422623ecf91792dc7648ea03f144ec26fe8eef4aac7ad54d65ffc6dbb88e258ff7bdf500657e7d905aa0461e4ce8990931ae4c72b21ea3f1625a67e8da783b69c19c8aed5d17133c53db309b35e0fffeae53e202f24f6109a4242cf15fe0d5aca3cdf612d2efa4bb7cb89e2147b4fdbd43b87fc442692ac08f2e9b116436205ab04758572d30b03afb95e6a2de5c027b49c1ec8aa6db9c848069265403a1ad054a35ea9706c35c6a038c9fad5ce689cf7d8ebfc004d84577de9fb139386a37859b43345839c5bfa671f8a0c804f004417983c56fab65bcce5233761e1db821a00a0ec2cbc241301f7dc6324adfc192b57f73c8bd574b63ac3a10612c33a7a52efeca2f59ef5e586ad424211b77c001c9c1ad543e41ef1c7fb2c085b48169a35298c3394c3b1cbe6ecf66a93c8c76b89795bee1eba2d357347e400062cf22e3d087ba5b03cad2ef1b4d5ddb07d701fdebfdf68d238f721b5b08bb5610e1c2a7fe4d7cd66e15bfbe8c01c78cc3a28ef3e530fd561aaba2ecdc6c4961a4ec4bd13b6e06f089de51ed7da5906d4406c9ea15f8e0e6a4d1385d4919ab9ab03fcaddfdb7678186478e5d07331a61df5980cf0f608b8353579d51bc577b059e158233da5714e282fd60172285570c73e4428e2c200b12c8083b1ccddb023bc2f013c3ed06398fa0686297cfd11c830fd4f8ecc478df7f5d328142d82a5b80422da4208122b02ec2f776887ad5b1fd49acad0168207228109b3d083c495ebc51f6fe0ae7f8b72b7af27ad9a39ce150e93c0e8af0ea6040f6f47e7431e25ada39ebfab389d614589e7a0228f60855836fa510b0e5b3b5066914965dd11bd9462dbc941b79cca483bbfe656f71c08fc3224fcda9fb456eec024341d3857989986d6e92433083844268e6b3de3207ab87b9b2e6607d7906e9e89ffd1064121e459a797340b67f9f6f0244910c41dc173ced5f9ffa4fc2583e96596558f4c05a5863f3b75fe4e29a7fefc7150e24cac2b71bc618c08752f93cefed7b8b4e91c7aff52bf1ba55e2604d28ad9ca0a89e5dec9178a43579af7d55dce913e30d112247bd67fddc2b0428f510cadadfaf7a6ae280134df1fb9eb5ca12c1122bc9c9e48024d952344b0c9eb6ebefed356dd422fdbd2bb3f2ffd8d924093f070a6a8dc6dbfda8a56db3a68f051f282c787d08adedaf409a3e648f42aaaee9859eb123afdff9b4e65b92fad98417fd00b52045df424f7a26389572f658c24bd58ef241b3aa504853e0ff396212a8fa573f2645914d8fcf88e5afd0731645fc6fe9be8fb555d51fbe1b9d1e400b3aeb34f3962488b0d3e90792a58d42d159e91c3f8edfaab033cec36c583a0b7135e4794e06b6ebbc9258dc328cd912f4999d4aca16ab254127677e8057e536136435e50201fff4bbf2a3a3f2a77d1730d961c8b2be644d99703c187c4b87f5def534397398fdf6d6de8aa12cba466c68f00e95d7fd2c498e5b2ee6986d776c0013c5f27506c5c9933e8376b2de0d36dd0bf8088d0ec0978c4a8fd73c9c093d4dcd81e73362037b77f944f28c6feacd71cf461f81d1b36c78d1bef0715cb4c8d2d21226a1db76ab6df73d76644dc98798a766a8f663148748962d3945f9e7ca04e2a73fd25c64c364daaa2fe2beb09b9f7214570eb20183103cf5b82d22bda034c2892dc2d25ead01d577ad94ccd02f77d085817b949b74a5783641016e0f59fd58e7e2e8a92336f42a2edbfefe5733157a3f6537eb9e9f09586418273047312cb66a479df241e53b0ed6fedcd89e28bccd3bca90c634390e2289bc3ca9768cc5c708df1d75c348b3d6553878a3f6bfe472161fd10e4b20e7c8b38afca79268ef6c9df853b72ead87d574ca4c4e8071dc868419f93b95f55e33e04b15d8fb1f625f4a67e708c2306c0b00fdddfe46419c10654a8a3738138abb67e2e32769fde5650cdd75dc55e5018987bb683a342dceca6a6e452d52a6f9778446f27cab8305ee212b779dbec79e87dbe52680349150b80f731b86588dc9d55bbd0e0e5509b3f4ff03e2a56526c726f81446c5d1420d562fdaa4ded0a91b813c42f4c7b1d0f43de5631377e5e4f9ff81ae28ba805b0cbc4ef99adc2bffd43918e680a818b70dfee8de2df16e89f57ec519c8cc27031f52458b7c1581c5320efc8d42ad3b29eddfba5e3987c9e1c1ff15cd439efc137a8a80ac9908ecf7c9395f746e82261fdb771454a1cc34092f0e14706fb5c270728dd3a8f157d07f7afe0d8d7432ff75db8e90360f2ffcf5b8ff9acd14ae2d32775ff866468f66da3f54c2887d14d51ca8a0cb50777a9cc0efd2b99b409dc36c3b08aaf9103f2c985c136bd99cded9a19e82621bd2fcb0898f68c183df2fc3c34ccda6bef21fa91441ba7bc7e2e283fd4817e24e30d0cde31fd33fb882262d3d36ac74c6c83e6324ad1e67f203cd83a6d310ac6738f864bf26a9dd462ef7f026225e8177f560fcdacb512ee82eb5353d1dd5aa75aef11fca569326594e2cca3330f01b4853a5eb612c99021155eb94be6a132ede4ccc6fc3806460ee717473947c950f6279425dec82369d852f30c06d3043c6651446c5ce5f5314c43259276d383ae100e5f0901f12a6cc622839a3858a9b113981f194175566041bc022a0445033c52aecec4bb0b11e43b35ad191e26c2188120771721b04c67767cab2f4d5282d32ea34efa35e61a0defb8917bbdf03de9ce3716b00705c1b3429b83d3d74ab72826d03c93dc276f9fae0a540c1bf34ad4f6d4c314d10d1d40ab0757f9534f6f7f1e981b78b409f596ffb295ea2943297dd3bdd50100a03d14869c6e2fb37f9296b73d49709477278e83b119bbc0bdbcca154dbd847ffd4cb13db7d4e0c55e3880a0a7be33d08e3981666647d5c9623474cb1b268355a4278a0ea8967702fd48a620f92ec7f52226b5c9744cf47bef6a0940ec0b91d4fe2062eb41d500f69264c1959fc8f8df49c76ad2fb8db3b9dd7fe1b56af67241b0557a983113ba94314b2f9a4d2a2519a43df37e4c3e6e34b7f216bccd82608ad917760aff2b90d5b46ca73081c8de4c45981258bd9f510223ac8f917261fe79f89c71a981a013b085fd255338e614e69a31f1509872850b494713356e259f8f9034550a2206b5d1ac814071158152e00891212259a3dc9fbe4461825a8b727ae109da62fa653cf9d5533d4c06217e134c5a4d7a60169e6f1d446ba0dc7755438e16ed420a89b84bf79d8f74a342375cad1af0c371e61ecec16cee9c873a2876a0a7cdae0bf3987283e62c59a84005b527c7075491beedd9fa8c0433b4d1bea456a15f66f1a9f9744b324f8b9e111cb23427a943b43c21e5dd191cad068de09a45265264971a5fb62d501b8eb54b4f516b86cf30ff596666031047c7293883eaf40d9cb8598969b5f9119b8a31dd19c0132731ab8b381fa27f4ff70788293cac0dc4b6e73aadc1b41b7983dbdda557c57ddf95996eb9ab9ac24998cf46874e564f7471d91789ec737f3c37186c2c4b1e7665a3ba1caae29fdfedcced40e41efe32c9fb65d730f00df6404c58192a7fd335fc75eeb06f0f029bcffee3758b7969d512ee5ca02e57ecf27c7f840bec56fc57480d4a185a4ebb1e2cb494705f90ff187852b3fb18b1f951584d25cca601cd97a6b7c0b92b031c794110d5fba64447b6bd73b21fa3ef76298089bf6b33b72636b2c4497e3e53412a71b772c73a8fcca20ae133b69fdb1519148d18762ba8c84e7c8ff62432a30aed8d9ea728d67e528c3a2a0b8567307fd6e3cb38e0c42cb003c24f6dd69eccf213077dd2ced4f41c9c364ecb9411809b158e4658865f4c464acd07eafc51a30ffcdd74e0a6b3603151dbef38e7967847f64658a9d3d848d09a0ad1bf5ef0fec9d1b53c679e747623c92550dbfbf2a3378f8c15f518ffc63be63c57e39330c9651393b37fe3bb9ab220b7e27ac5fe9cae324f4ed11e9ccb84eea188719d74aafebf1dcc71d080b3184b532ae0b709e493d7c34cfb1dc48ebd8b06e1d1ef398173a408fe0c654b16fbe7bb4d446722125c7ab0e20581b51d24e646e6a8122204cffdc6c594622372afe15a6495e80cc67b3e0775f740dea70f42116c25b18ee5c3b02f2fed7a6c65a00e1e47afc063f94cb8dbb07df863371928c75521ebe7f4f5284098c4e239669e06d2de468263360c64b1493239785c045a916469ed49a2f9a2afccfaf7c7274a0daf31bbbc83edabcb9738fd186589f67b2e6fd2395910a1fb0e106254457582acbcecfdf273bf020602e35d878a624fe912658c6a0201663b0849e013dbb7a63c419d005399f9069581c0c9fcbb1965dcd21961a2ce34b7c9b336122d1d670e31a9891dd37313ec1288195c868cc2cc23c5cff8009cba49aa595e277ad58cc7a39cdcd00f74d0cbddf0e056027cf66288f7c87a2a914360ff615ad2323e82b6e8fd78bf315a49fcd116c972bf06456f9aec03c11165d05c4da7b807cb44a593cb5ba7137cea3cab52709e5f4ceafc9533918a2d06241c6bda5b9433b40e50a157229737ed7057a71675716d94db545728ccad9f5181d5b580f00b8fa669c859728364a2b7bd12dc1eef793aa32260f692fd66b030bdb824e62265f1c8508dc5ab98f93f17fe0344fd81a00242f54c461f0017bcd31f00818444412c925af017a799782609817b7664ce5198f3365ade25ae5294527a9893823910a673ecd19c1fb000ca609b24c12c57257f217c1d6e6dab585101575b9dd6c024ebf8c4911910d00229fd2724fcb99e0d8538a5eea2659b0b03fbb8e3803d40abebbe23e648a46ce3cf45586143366201bb134681ebe8c5bb22a0f561053879e91dd2b5b83535971d009df4002a0131761c79fc35bb918f6675c553dcf08ddff26defd43f9b5ff8809170d458f036cf9fdb9cb69fead895a362f661b29359be1b2d878e585b534ba6605b288b06c79ddaf190442302cc5d08124f5ba2d82050175abbff36684dcae99e7ceb9e9503f30dd496fd6445b100bbc4e3fd426f40b1ccf29fc87eacf319c6a50388c7addb4d1d196bccb8a14c636dbcc9de6aaf230293e7e0bbcdac339d8790f4895b2d974afde165634d54c672943b4f945bbe2651127cfd3bf221fc064286507829435bb64cb6b1e9044c3d11b03342a8984ea3a5e8c0e52660d0f70a0f014463d4903a01d8f52f0928ad46d47c5876200dca96984f1809ce8b948bf3a1b1a39bb57e8d6d3fe381524c1fb818866e91343ee03c609e6395ebc476e9b5392aa38ea22cd12ab60afbecccca24164e135a1ddae8222a30dbcd542ff0da890abc3e87bae4af70201ac121d9a1080b8b1385e46e5ae8dc5560a7d1ea7c1cd9725c1882362b696f47976a0ff8de440145ab48e1fa20483826607076d97a7edd2339b7dc0405efca13c4084f3dc085c408dd1aac55a991f31aad801cea6995d182839dbfdabf070a20b0980e9c9a852cc0497a8077b4782456746b24e296a70cd045e3146276c85cb2fa7b7dec8fcce4a63b1a22a6143283558650707a98b08910e487317bd2b2c76e3c201de67607a6a17a43d8a9ad42f5c8ce01a73126a81031c757e5d05689be42402df87f6369303df60b41b23fffe6ee1b5c138a242a09c91f653e915d0af8cfa0b773964abce025458636c885b4e5c853598520e61c750e2897eae5a94217918f24efb161ce01c110efbae259f276ba63db13ca8523d39d083693de4d21cadf83e72a60a7356d006b3d2eb744b2282c95e2e77a4a7f9d32d49ea2860b66402bf36934eb54d2e475def6a9acddc43f1ab7f1ee72857652e0848302dbcee7fe3eeb99aad63b288439707b403f2e0dcf1aad02219e537a35ae5bf33225d11eef776f3f19ca17ac14dc027dabf7599baf2d640b2b275ae704d5e3d754e8e9c4857ab82bd25f8351ca20716b38c13f6bc438a99ad11acdaf3daecfa4ae771bc015efc9e6235009d6b923bc1166199dbddaab298578a9fd37289bed3658987b385764b4216e068cb7091f97be5e134bec1d35eaf11d444817c609937154d254c95b91ce0fc2550eff49339418f844f0e6388aaf9a5e540df9ef6a1c0a75c9bd7b1ec439bcd840a7ddb5841e19d6765f10498a8c8a5a4033e2e5bae4a8d22fd1fdfdb6ba78fd3d3ce6ace8f2d984cd6966f021d56874380800adef61d6fc55c58038a17f47d6f43cde4a539971439730e53ac27c268691ac26124c45b651bc7aa403e6f4672aaba59d62b89f9214e72807668aab93e449d08e98677f35ae36da2444da5d1c51c2dea21fa6bb0c686377dc948badab3db8e3f1a24658307abd87cfc380096c1c4b13f6b428459174ae813703f646caee2d9787528ef05c41a8db34214f656ce95377885800cea3c9b78df10e0550db636298f3b8b514c5053dddb844e94cd7b1ee5fc6aa1dd0b04df6f25fda82d3a4335b7aa829360e55dc838793dec0f0d268edef6f4956c7386dabdb52250ac0212d54c540fe77cf8270b82fb0a3f85bb936bf58274020cd3a6b2624546daea851f2286fb63f606d2cf6b1204001a400c271a0d569f4238e504d8102ec5ac4da3abbb8dc70efbaf67bfb14cd0353df9f7674c489e369181a5a2dae694ed93b08439324280537f3c6c38757c83b2e737953cc0a9616b8d28eaaa8ccfeea2dd00659d059e847eb5c5339954d35e52742a077de3c346618323d33573cc2f7935384df98ae0921c685c98bc0d1ad1577c835b7ccd0e32758ab11084cb32841846116fe857ac268ad1fd775fa693f55806df52b22c5a06010e1fcf84d448ca11407af4220bb9de1e5b92197fd260087c292e71b82de677d040051a321931ed109ef92ac5215b8b902be4395f072d834c921ef6823aa3a5685ce3773b5dafc560e1b8f56a349b9a9b1d8985f32e5e49487bbf0fe9e12ab859de962a2dd7bc097a506a56d6169240c2e2f9919a909635fe0e37cce2428ca9d0cfce8fc2aa5b9e0dee9375425ba246576d343d7f1e420fdac3f8af99729322d65ddece41ea95a6f9b9ea830ceef9cfa6afcdeaca6b69152933f5b52ed82ed5be393edfde2132af25957e034d3d07c92b3601dbcf9afd82ef6820b01d8ad736ebb2a15e5cd0ee24cb005ce21e9a720d7821539c4209bb29353cd9388923b95f9c26243b773e7d4e3cc270e7dcbc4101b9dc861fca35bb33383a933d72b338ab357f1 请输入密钥🔑"},{"title":"Nginx入门","path":"/2023/10/12/Nginx入门/","content":"01 nginx简介https://lnmp.org/nginx.htmlhttps://lnmp.org/nginx.html 又称 engin x，是一个高性能的 HTTP和反向代理服务器 特点 内存少，专为性能优化开发 并发能力强，能经受高负载考验 02 nginx概念正向和反向代理正向代理Nginx同样可以用作正向代理进行上网。正向代理： 典型的就是VPN上网，需要在客户端配置代理服务器 反向代理客户端对代理无感知，客户端无需做任何配置，由反向代理服务器选择目标服务器，反向代理服务器和目标服务器就是一个服务器，暴露代理服务器地址，隐藏目标服务器地址 负载均衡单个服务器性能低，可以增加服务器的数量，将请求分发到各个服务器上，也就是负载均衡。 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器解析。 03 nginx的安装和使用3.1 nginx的安装Nginx全部安装步骤https://blog.csdn.net/weixin_37056888/article/details/107326131 XShell安装https://baijiahao.baidu.com/s?id=1747920954538162924&wfr=spider&for=pc SHH服务器拒绝密码解决方法https://huaweicloud.csdn.net/63561cd9d3efff3090b5abe7.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-124917457-blog-128695452.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-124917457-blog-128695452.pc_relevant_aa&utm_relevant_index=1 error: You need a C++ compiler for C++ support.解决方法https://blog.csdn.net/qq_17496365/article/details/97019490 pcre-8.37 make install报错https://blog.csdn.net/weixin_37056888/article/details/107326131 ubuntu安装zlib方法https://blog.csdn.net/wu_cai_/article/details/80278611?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-80278611-blog-124211318.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 nginx make报错https://blog.csdn.net/weixin_46273997/article/details/115550134?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115550134-blog-121437087.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115550134-blog-121437087.pc_relevant_recovery_v2&utm_relevant_index=1 永久保存修改过规则的更改http://www.manongjc.com/detail/25-zqxeremurgqyisq.html 3.2 nginx常用命令前提条件： 必须要进入nginx目录。具体目录位置： usrlocalnginxsbin 命令： 查看版本号.nginx -v 查看进程ps -ef | grep nginx 启动nginx.nginx 关闭nginx.nginx -s stop 重新加载nginx（特别是修改nginx.conf之后）.nginx -s reload 3.3 nginx配置文件配置文件位置： usrlocalnginxconfnginx.conf usrlocalnginxconfnginx.conf #user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events worker_connections 1024;http include mime.types; default_type application/octet-stream; #log_format main $remote_addr - $remote_user [$time_local] $request # $status $body_bytes_sent $http_referer # $http_user_agent $http_x_forwarded_for; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server # listen 80; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / root html; index index.html index.htm; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html root html; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ # proxy_pass http://127.0.0.1; # # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; # # deny access to .htaccess files, if Apaches document root # concurs with nginxs one # #location ~ /\\.ht # deny all; # # another virtual host using mix of IP-, name-, and port-based configuration # #server # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / # root html; # index index.html index.htm; # # # HTTPS server # #server # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / # root html; # index index.html index.htm; # # 全局块events块http块从开始到events块之间的内容，影响nginx服务器的整体运行 #user nobody;worker_processes 1; # 表示nginx服务器并发处理的数量，越大表示处理并发量越多#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;影响Nginx服务器与用户网络的连接 events worker_connections 1024; # 支持的最大连接数nginx服务器中配置最频繁的部分，代理、缓存、日志绝大多数功能和第三方模块都在这，http块包括： http全局块 包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等 server块 和虚拟主机有密切关系 又包括全局server和location http include mime.types; default_type application/octet-stream; #log_format main $remote_addr - $remote_user [$time_local] $request # $status $body_bytes_sent $http_referer # $http_user_agent $http_x_forwarded_for; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server # listen 80; listen 8080; # 端口号 server_name localhost; # 主机号 #charset koi8-r; #access_log logs/host.access.log main; location / root html; index index.html index.htm; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html root html; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ # proxy_pass http://127.0.0.1; # # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; # # deny access to .htaccess files, if Apaches document root # concurs with nginxs one # #location ~ /\\.ht # deny all; # # another virtual host using mix of IP-, name-, and port-based configuration # #server # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / # root html; # index index.html index.htm; # # # HTTPS server # #server # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / # root html; # index index.html index.htm; # # 04 nginx配置实例4.1 反向代理反向代理配置全过程https://blog.csdn.net/XJ0927/article/details/109501032 rz传输错误问题解决方案https://blog.csdn.net/qq_40443457/article/details/86595668?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-86595668-blog-128444598.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-86595668-blog-128444598.pc_relevant_recovery_v2&utm_relevant_index=2 linux中配置javahttps://zhuanlan.zhihu.com/p/492149414 linux中配置tomcathttps://baijiahao.baidu.com/s?id=1752814258019071848&wfr=spider&for=pc 4.2 负载均衡负载均衡全案例https://blog.csdn.net/XJ0927/article/details/109501188 4.3 动静分离05 nginx原理","tags":["DevOps"]},{"title":"React笔记","path":"/2023/07/27/ReactNotes/","content":"第一次学习（失败）：挖坑系列React简介React中文官网https://zh-hans.react.dev/ React官网https://react.dev/ React是什么？ 一个用于构建用户界面的JavaScript库。强调将数据渲染为HTML视图 React由谁开发的？ Meta（Facebook） 原生JS的问题 DOM-API操作UI效率低 JS直接操作DOM会导致浏览器进行大量重绘重排操作 原生JS代码复用率低 React的特点 声明式编码，组件化模式 命令式编码： 你先坐电梯下楼左转，走到自动贩卖机前，买一杯水，按原路返回给我 声明式编程： 我渴了 React Native支持移动端开发 虚拟DOM+Diffing算法，减少与DOM的交互，性能好 React入门Hello React 需要引入依赖： babel.js ES6 → ES5 jsx → js react.js react核心库 react-dom.js react扩展库（dom操作） prop-types.js hello_react.html html依赖引入jsdiv id=test/div依赖的引入需要按照一定顺序：!--引入react核心库 --script src=../React-js/react.development.js/script!-- 引入react操作dom的扩展库 --script src=../React-js/react-dom.development.js/script!-- 引入babel --script src=../React-js/babel.min.js/scriptscript标签的src一定要是textbabelscript type=text/babel // src一定要为text/babel // 1. 创建虚拟DOM const VDOM = h1Hello React/h1 // 2. 渲染虚拟DOM到页面 // ReactDOM.render(虚拟DOM，容器) ReactDOM.render(VDOM,document.getElementById(test))/script JSXjsx与js的对比 jsx能够简化js的dom操作但简化操作只针对编码者而言，实际由babel编译后的jsx依旧是按部就班的在操作dom jsx script type=text/babel let VDOM = ( h1 spanHello World/span /h1 ) ReactDOM.render(VDOM,document.getElementById(test))/script js script const VDOM = React.createElement( h1, // 标签名 id:title, // 标签属性 React.createElement(span,,Hello World) //标签内容 ) ReactDOM.render(VDOM,document.getElementById(test))/script 虚拟DOM与真实DOM对比 真实DOMdiv id=test h1 spanHello World/span /h1/div 虚拟DOMObject对象挂载的属性数量较少 type: h1, key: null, ref: null, props: children: type: span, key: null, ref: null, props: children: Hello World , _owner: null, _store: , _owner: null, _store: JSX语法规则 标签中混入js表达式时使用 花括号{} 包裹let name = Johnlet VDOM = h1name/h1类名指定使用className之所以避开class，是由于class与ES6类定义的关键字有冲突let VDOM = h1 className=titleHello/h1内联样式需要注意以下要点：style {{样式内容需要使用双括号包裹}}样式的赋值采用键值对格式样式值采用字符串格式样式名采用驼峰标识let VDOM = ( h1 style= color:#fff, border:1px solid #000, fontSize:14px Hello World /h1) jsx内的遍历案例 const data = [AAA, BBB, CCC]const VDOM = ( div ul data.map(item = (li key=itemitem/li)) /ul /div)ReactDOM.render(VDOM, document.getElementById(test)) React组件React Developer Toolshttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi 组件定义React提供两种定义组件的方式： 函数式定义组件 类式定义组件 函数式定义类式定义组件使用函数形式定义，函数名首字母一定要大写 function MyComponent() return h1My Component/h1ReactDOM.render(MyComponent/,document.getElementById(root)) 定义组件的函数内部，this指向哪里？ 答： this指向undefined。这是因为代码经过babel翻译之后，会进行严格模式规范： use strict 严格模式禁止自定义函数的this指向window。组件类一定要继承React.Component类 class MyComponent extends React.Component render() return ( h1Hello MyComponent/h1 ) ReactDOM.render(MyComponent/, document.getElementById(root)) 类定义流程 找到MyComponent组件类创建新实例new MyComponent()通过创建出来的实例调用原型的render方法将render返回的虚拟DOM转为真实DOM呈现在页面上 类组件中的this指向哪里？ 答： 组件类实例 组件实例三大属性 state props refs statestate中用于存放组件中的一些状态信息 class MyComponent extends React.Component constructor(props) super(props) this.state = // 构造器中初始化state country: UK, color: #00ffff 在render中使用state中的数据，注意： 每次更新state数据都会重新调用一次render render()return( h1 style=color:this.state.color this.state.country === UK?Hello:こにちは /h1 ) 组件中事件函数的声明方式 dom事件对应的回调函数并非由组件实例调用，因此会导致回调函数中的this实际上指向的是undefined因此需要先一步指定事件触发的回调方法的上下文class MyComponent extends React.Component constructor(props) super(props) this.state = country:UK, color:#00ffff // bind指定上下文 this.sayHello = this.sayHello.bind(this) render() return( h1 style=color:this.state.color onClick=this.sayHello this.state.country === UK?Hello:こにちは /h1 ) sayHello() if(this.state.country == UK) this.state.country = Japan else this.state.country = UK this.setState( country:this.state.country ) state语法糖 class MyComponent extends React.Component state = // 类中直接定义state country:UK, color:#00ffff sayHello = ()= //类中定义事件回调函数一定要用箭头函数 if(this.state.country == UK) this.state.country = Japan else this.state.country = UK this.setState( country:this.state.country ) render() return( h1 style=color:this.state.color onClick=this.sayHello this.state.country === UK?Hello:こにちは /h1 ) ReactDOM.render(MyComponent/,document.getElementById(root)) props props用于存放需由外界传入组件的动态数据 基本用法 const sayHello = ()=console.log(sayHello)class Person extends React.Component render() return ( ul li onClick=this.props.sayHelloName：this.props.name/li liAge：this.props.age+1/li liSex：this.props.sex/li /ul ) React.render( // 通过标签的属性实现props值的传入 Person name=aaa age=19 sayHello=sayHello/, document.getElementById(root))传入组件的参数还可以通过解构赋值实现更简洁的写法let p = name:bbb, age:20, sex:maleReact.render( // 此处使用解构语法 Person ...p/, document.getElementById(root))babel在对JSX做转换的时候会对下面这种语法做特殊处理：Component ...obj/实际上就相当于将obj的键值对作为Component组件的属性值 props限制 PropTypes官方文档https://legacy.reactjs.org/docs/typechecking-with-proptypes.html需要引入prop-types.js类型检验库Person.propTypes = name:PropTypes.string.isRequired, age:PropTypes.number, sex:PropTypes.string, sayHello:PropTypes.func类型检验需要放在组件类的propTypes属性中：Person.propTypes = // 类型限制类型配置之前需要加上PropTypes类的引用： age:PropTypes.number多个限制使用链式声明： name:PropTypes.string.isRequired // 必须字符串数据类型标志与关键字的冲突避免：为防止关键字与数据类型的冲突，将类型首字母小写处理：PropTypes.numberPropTypes.stringPropTypes.boolPropTypes.objectPropTypes.arrayfunction由于是关键字，因此简写处理：PropTypes.func sayHello:PropTypes.func定义属性默认值使用组件类的defaultProps属性定义默认值：Person.defaultProps = sex: female props语法糖 注意：props一旦传入类组件后即为只读属性，不可修改props的语法糖实际上就是使用static静态属性给类本身定义属性class Character extends React.Component static propTypes = name: PropTypes.string.isRequired, age: PropTypes.number, sex: PropTypes.string, makeQitatapu: PropTypes.func static defaultProps = sex: male render() return ( ul li onClick=this.props.makeQitatapuName：this.props.name/li liAge：this.props.age + 1/li liSex：this.props.sex/li /ul ) function makeQitatapu() // to doReactDOM.render(Person name=aaa age=19 sayHello=sayHello /, document.getElementById(root)) 函数式组件的props 组件函数只能用props，并且propTypes和defaultProps只能定义在函数外（这是因为函数内的this指向undefined）函数组件无法使用state和refsfunction MyComponent(props) return ( div h1Hello props.name/h1 h2props.age/h2 /div )MyComponent.propTypes = name: PropTypes.string.isRequired, age: PropTypes.numberMyComponent.defaultProps = age: 20ReactDOM.render(MyComponent name=Jerry /,document.getElementById(root)) refsref用于标识dom容器，一般有三种定义形式： 字符串形式 影响效率，不推荐 内联回调函数形式 官方更为推荐的方法 但是重绘时会导致每次render调用两次 第一次：传入参数null 第二次：传入当前dom元素 绑定回调函数形式 能够解决重绘参数传入null的问题 createRef 字符串形式的ref class MyComponent extends React.Component alertInput = ()= this.alert(this.refs.input.value) render() return( div /* 定义字符串格式的ref */ input ref=input onBlur=this.alertInput/ /div ) 回调格式的ref 有内联和绑定两种定义格式：class MyComponent extends React.Component bindRef = (currentNode)= this.input2Ref = currentNode render() return ( div /% 内联样式 %/ input ref=currentNode=this.input1Ref = currentNode/ /% 绑定样式 %/ input ref=this.bindRef/ /div ) createRef React.createRef调用后返回一个容器，存储被ref标识的节点，每个容器中只能存储一个dom元素class MyComponent extends React.Component state = value: myRef = React.creaeRef() myRef2 = React.createRef() setValue = ()= this.setState( value:this.myRef.current.value ) render() return( div input ref=myRef onBlur=this.setValue / input ref=myRef2 / h1this.state.value/h1 /div ) 受控与非受控组件 非受控组件组件中的数据现用现取，一般需要依赖refmyRef = React.createRef()state = value:// 非受控组件借助ref获取到数据inputInfo = ()= this.setState( value:this.myRef.current.value )render() return( form input ref=this.myRef type=text/ button onClick=this.inputInfoClick me/button /form ) 受控组件state中与组件相关联的数据实时更新，类似Vue的双向绑定组件，受控组件可以减少ref的使用state = value:// 受控组件通过原生事件中的event参数获取组件的状态值inputInfo = (e)= this.setState( value:e.target.value )render() return( form input ref=this.myRef onChange=this.inputInfo type=text/ /form ) 虚拟DOM的Diffing算法React中使用key属性对虚拟DOM进行唯一标识，每次调用render重新渲染前，会将用最新数据生成的虚拟dom和旧的虚拟dom进行比较，比较是将key值相同的两个dom元素拿来对比其中的内容，如果内容改变，就用新的虚拟dom代替旧dom，因此，dom元素的key值必须唯一并且尽量可以保持不变 使用变化key值和不变key值更新dom时的对比： key值的唯一性会决定组件更新的dom元素有哪些 将key值全部更换ul ref=list inputList.map((item, index)= return li key=indexitem=input type=text//li ) /ul 使用唯一标识作为key值ul ref=list inputList.map((item, index)= return li key=itemitem=input type=text//li ) /ul React生命周期旧生命周期React旧生命周期 组件挂载视角 组件初始化constructor组件挂载前componentWillMount 渲染组件render 组件挂载后componentDidMount 组件卸载前componentWillUnmount 父组件更新子组件视角 子组件即将获取到props传参componentWillReceiveProps判断组件是否更新shouldComponentUpdate组件更新之前componentWillUpdate组件重渲染render组件更新之后componentDidUpdate组件卸载之前componentWillUnmount 两种引发组件更新的操作 两种操作会引发组件更新：setState 更新stateforceUpdate 强制更新 setState 判断组件是否更新shouldComponentUpdate组件更新前componentWillUpdate组件重渲染render组件更新后componentDidUpdate forceUpdate组件更新前componentWillUpdate组件重渲染render组件更新后componentDidUpdate 新生命周期React新生命周期 React17弃用的钩子函数 ComponentWillMountComponentWillUpdateReact17对弃用的旧钩子函数做了兼容，需要在函数名前加上 UNSAFE_ 前缀UNSAFE_componentWillMountUNSAFE_componentWillUpdate 新添加的钩子函数 getDerivedStateFromPropsgetSnapshotBeforeUpdate三种会触发getDerivedStateFromProps的操作：New props 传入新参数 setState 修改状态forceUpdate 强制更新getDerivedStateFromProps主要用于处理组件的state依赖props的情况getDerivedStateFromPropsstatic getDerivedStateFromProps(nextProps,prevState) return nextState将更新前页面的状态传递到更新后的生命周期函数里getDerivedStateFromPropsgetSnapshotBeforeUpdate() // 返回值会作为第三个参数传递到ComponentDidUpdate函数中 return snapshotComponentDidUpdate(prevProps,prevState,snapshot) // 第三个参数来自getSnapshotBeforeUpdate的返回值 React17生命周期 组件挂载流程组件初始化constructor状态管理getDerivedStateFromProps组件渲染render组件挂载后componentDidMount 组件更新流程状态管理getDerivedStateFromProps判断组件是否更新shouldComponentUpdate组件渲染render组件即将更新getSnapshotBeforeUpdate组件挂载后componentDidMount React脚手架create-react-app 全局安装react脚手架依赖包npm i -g create-react-app使用脚手架创建新项目create-react-app 新建项目名脚手架搭建项目的目录结构默认提供四个运行脚本：start 运行项目，默认端口3000build 项目打包，使用webpack项目管理工具test 前端测试eject 将隐藏的webpack配置文件暴露出来，此过程不可逆启动项目后的初始化界面 public文件夹 public文件夹存放一些静态文件index.htmlmanifest.jsrobots.txt!DOCTYPE htmlhtml lang=en head meta charset=utf-8 / link rel=icon href=%PUBLIC_URL%/favicon.ico / meta name=viewport content=width=device-width, initial-scale=1 / meta name=theme-color content=#000000 / meta name=description content=Web site created using create-react-app / link rel=apple-touch-icon href=%PUBLIC_URL%/logo192.png / link rel=manifest href=%PUBLIC_URL%/manifest.json / titleReact App/title /head body noscriptYou need to enable JavaScript to run this app./noscript div id=root/div /body/html网页做app套壳时的配置文件 short_name: React App, name: Create React App Sample, icons: [ src: favicon.ico, sizes: 64x64 32x32 24x24 16x16, type: image/x-icon , src: logo192.png, type: image/png, sizes: 192x192 , src: logo512.png, type: image/png, sizes: 512x512 ], start_url: ., display: standalone, theme_color: #000000, background_color: #ffffff网页爬取内容的相关文件# https://www.robotstxt.org/robotstxt.htmlUser-agent: *Disallow: src文件夹 src为开发使用到的的主要目录,初始化的src目录结构如下：App.css 根组件样式文件App.js 根组件js文件App.test.js 根组件测试文件index.css 全局样式index.js 项目入口js文件reportWebVitals.js 用于记录页面性能，依赖web-vitals库setupTests.js 测试文件，依赖jest-dom库index.jsimport React from reactimport ReactDOM from react-dom/clientimport ./index.cssimport App from ./Appimport reportWebVitals from ./reportWebVitals// 创建根节点const root = ReactDOM.createRoot(document.getElementById(root))// 渲染根组件root.render( // React.StricMode用于检查App内子组件是否合理 // 如 字符串类型ref 等 类似Eslint React.StrictMode App / /React.StrictMode)// 引入reportWebVitals文件// 依赖web-vitals库 用于记录页面性能reportWebVitals(); React Ajax跨域 本机3000端口服务需要请求本机5000端口数据，可以直接请求吗？axios.get(http://localhost:5000/simData)答： 不能，因为跨域，到底是在哪一步跨域失败呢？跨域发送请求 √ 跨域返回数据 × 跨域的解决 解决方法实际上就是在3000（Client） 和 5000（Server） 之间，再配置一台代理服务器（同样在3000端口），3000端口同时提供微型代理功能 和 客户端功能。解决方式1：package.json配置适合的业务场景：代理目标唯一配置位置：package.jsonproxy:http://localhost:5000这样项目中所有发送到3000端口的请求都会被转发到5000端口解决方式2：http-proxy-middleware适合的业务场景：需要代理多个目标地址时配置位置：src/setupProxy.jslet createProxyMiddleware = require(http-proxy-middleware)module.exports = function(app) app.use( createProxyMiddleware(/api1, target: http://localhost:5000, changeOrigin: false, pathRewrite: ^/api1 : ), createProxyMiddleware( /api2, target: http://localhost:5001, changeOrigin: false, pathRewrite: ^/api2 : ) )changeOriginchangeOrigin用于决定是否在服务器端暴露请求源changeOrigin true 不暴露请求源此时3000请求5000，服务器端收到响应头中Host如下：HOST = localhost:5000（服务器端地址）changeOrigin false 暴露请求源此时3000请求5000，服务器端收到响应头中Host如下：HOST = localhost:3000（客户端地址）pathRewrite表示是否对url的部分路径进行重写，被替换的部分往往是用于进行代理转发识别的路径段，比如配置如下：createProxyMiddleware(/api1, target: http://localhost:5000, changeOrigin: false, pathRewrite: ^/api1: )则当请求的url为 http://localhost:3000/api1/simData 时，url会经历如下处理：原始路由http://localhost:3000/api1/simData路由替换http://localhost:3000/simData代理转发http://localhost:5000/simData 第二次学习（失败）：快速系列npx create-react-app app-name 数据注入 列表渲染 事件 状态处理 useState 基础类型 数组类型 对象类型 参数传递 父传子：props 子传父：函数参数裹挟值传递 同级传递：父组件中转 多级传递：Context Hook 参数传递场景练习 一个用户评论列表，有三层结构：List 列表ListItem 列表项Button 点赞按钮context状态项： theme 控制样式风格 filterOption 筛选项 - userName 用户名 - isSort 是否按照点赞数排序 第三次学习（完结）：面向Vue基础系列b站教程 jsx基础组件首字母一定要大写函数式组件function FunHelloComp() return divFunc Comp/div类式组件class ClassHelloComp extends React.Component constructor(prop) super(prop); render() return divClass Comp/div react中创建组件的2种方法：jsx：需要由babel将jsx翻译为jsReact.createElement 实际实现jsx的接口 事件传递react事件绑定的函数被触发时，如果不做处理，this的指向是undefined有如下方式使得this指向当前组件：箭头函数定义事件方法事件绑定时用bind函数处理事件方法行内定义事件方法传参方式：高级函数使用bind获取新函数第一个参数为this最后一个参数为事件对象event 响应式数据react响应式原理 vue：监听响应式变量的get和set方法react：手动调用setState进行更新往setState内传入一个新对象，其中包含需要更新的数据将传入的新对象与旧state进行合并使用合并后的state对页面视图进行更新 响应式的优化 无论数据有没有发生变化，直接调用setState都会触发页面的重绘，要想优化这一点可以使用PureComponent：class App extends React.PureComponent使用PureComponent时，如果响应式数据没有被更新，就不会触发多余的页面重绘。注意：使用PureComponent是对数据更新的一种优化会监听变量的内存地址的变化因此仅仅是数组和对象的成员变化是监听不到的必须要对原数组或者对象进行拷贝更新 组件间参数传递props react不需要在子组件内对prop声明，只要传入的参数， 都可以直接拿来用prop类型验证：propTypes类型验证库：proptypesnpm install proptypes –saveChildComp.propTypes = // react中，类型验证必须是个函数 mes: function(props) if(typeof(props.mes) !== string) throw new Error(Mes must be a string); , count: PropTypes.number默认值：defaultPropsChildComp.defaultProps = mes:Default Mes 插槽 默认插槽props.children具名插槽使用HtmlElement元素作为props参数传递作用域插槽哦返回HtmlElement元素的props函数由父组件创建，能获取到子组件值的插槽 样式引用.css后缀的样式文件，作用域为全局。引用.module.css后缀样式文件，相当于vue中的scoped，对全局作用域做了限制这种引入方式需要对样式文件进行命名引用import childStyle from child.module.css;//.....div className=childStyle.title/divclassnames库使用classnames库，能够快速用js变量控制class类名的toggle切换npm install classnames –saveimport classnames from classnames;// ...state= hasClass2:false//...div className=classnames( class1:true, class2:this.state.hasClass2) /div也可以通过classnames.bind，将样式文件使用这种方式进行控制import classnames from classnames/bindimport childStyle from ./child.module.cssconst childBindClassNames = classnames.bind(childStyle)//...div className=childBindClassNames( class1: true, class2: false )/div 生命周期React.StrictMode模式下，生命周期执行两次shouldComponentUpdate表示是否应该更新PureComponent优化的原理根据获取到的新值判断是否进行更新componentDidMount相当于vue中的mounted对比vue和react的更新vue在get和set函数中触发更新在get函数中进行依赖收集在数据更新后，只更新用到该数据的地方react调用方法触发更新更新整个组件树 增删改查案例 ref contextref 父组件访问子组件参数const childRef = React.createRef();childRef.current.addCount() // current代表子组件的this context 使用 React.createContext 创建context使用ContextName.Provider进行value的传递使用ContextName.Consumer接受参数并用回调函数获取到value值// 父组件export const Context1 = React.createContext();export default class Parent extends React.PureComponent render() return ( Context1.Provider value=key:123,label:外太空 Child ref=childRef/Child /Context1.Provider / ) // 子组件export default class Parent extends React.PureComponent render() return GrandSon/ // 孙组件import Context1 from ./Parent.js;export default class GrandSon extends React.PureComponent render() return ( Context1.Consumer value=return ( div pvalue.key/p pvalue.label/p /div ) /Context1.Consumer ) 函數组件和类组件的区别 无生命周期不用考虑this通过hook完成操作函数体相当于render函数props作为函数的第一个参数 Hook React内置HookuseStateuseEffect类watch功能useMemo类computed功能防止不必要的数据更新操作useCallback方法的缓存，防止不必要函数更新操作useRefuseContext更方便获取Context.Provider中提供的值 高阶组件和高阶函数（返回函数的函数）概念相似，高阶组件相当于一个返回组件的函数，主要用于：在多个组件上装载相同的逻辑片段对多个组件进行相同的生命周期处理场景：修改父组件的state数据时，对子组件进行选择性更新（shouldComponentUpdate）使用一套逻辑封装的鼠标定位组件： 关于性能优化 React的性能优化需要开发者手动去实现，如果不做任何处理，一个父组件的更新往往会触发它所有子组件的更新。React.memo 对组件尽心优化的高阶组件，避免不必要的组件更新相当于类组件中的PureComponentuseMemo 对静态类进行优化useCallback 对静态方法进行优化 React-routernpm依赖 React-router 服务端渲染SSRReact-router-dom 浏览器渲染React-router-native ReactNative混合开发 React-router-dom 首先要给需要路由的组件添加最外层标签包裹：两种包裹方式：HashRouterBrowserRouterHashRouter App//HashRouter路由跳转RoutesRoute 声明路由跳转的页面NavLink 多用于导航栏，最近被点击的navlink会多出active类Link 纯路由跳转用标签路由重定向Navigate子路由OutletRoute path=/wish element=token?Wish/:Navigate to=/home/Navigate Route path=createWish element=CreateWish/CreateWish/Route Route path=destroyWish element=DestroyWish/DestroyWish/Route/Routeexport default function Wish(props) return ( div Best Wish: Outlet/Outlet /div )异步加载路由LazySuspenseconst LazyKill = lazy(()=return import (./pages/Kill);)function App() let token = 12 return ( div className=App ul className=nav-ul li className=nav-linkNavLink to=/homeHOME/NavLink/li li className=nav-linkNavLink to=/mineMINE/NavLink/li li className=nav-linkNavLink to=/killKILL/NavLink/li li className=nav-linkNavLink to=/wish/createWishCreate/NavLink/li li className=nav-linkNavLink to=/wish/destroyWishDestroy/NavLink/li li className=nav-linkNavLink to=/work/123Work/NavLink/li /ul /* v5：Switch v6：Routes*/ Suspense fallback=h1加载中。。。/h1 Routes Route path=/home element=Home/Home/Route Route path=/mine Component=token?Mine:Home/Route Route path=/kill element=LazyKill/LazyKill/Route Route path=/wish element=token?Wish/:Navigate to=/home/Navigate Route path=createWish element=CreateWish/CreateWish/Route Route path=destroyWish element=DestroyWish/DestroyWish/Route /Route Route path=/work/:id Component=Work/Route /Routes /Suspense /div ) 路由参数 params参数useParams 直接返回params参数 Routes Route path=/work/:id Component=Work/Route/Routesexport default function Work() let params = useParams() return ( div Work No. params.id /div )query参数useSearchParams 返回类似useState格式的数据mine?nameLilyAndAndyexport default function Home() const [searchParams, setSearchParams] = useSearchParams() console.log(searchParams.get(name)) // LilyAndAndy setSearchParams( name:NiceBoy ) return ( div className=Home app-page mine mine mine /div )location路由跳转：useNavigate返回路由跳转时的一些数据：const location = useLocation()路由跳转时，可以跳过params和query方式，传递数据：/* state内的数据在nextPage中可以通过location的方式获取到 */button onClick=()=goto(/nextPage, state:mes:hello world)Go to kill/button 权限控制 Route.elementComponent中做判断：使用Navigate重定向Route path=/wish element=token?Wish/:Navigate to=/home/Navigate 异步路由 LazySuspense// 异步引入组件const LazyKill = lazy(()=return import(./pages/Kill))Suspense fallback=h1加载中。。。/h1 Routes Route path=/kill element=LazyKill/LazyKill/Route /Routes/Suspense 全局状态管理npm库 react-reduxRedux@reduxjstoolkitreact-mobxMobx Redux 需要手动实现store逻辑的修改，比较麻烦：reducer仓库创建state：管理的状态action：操作相关的自定义参数约定俗成type为操作类型，payload为目标值import legacy_createStore as createStore from redux;// 创建reducer状态管理函数function mesReducer(state=mes:hello, action) switch(action.type) case changeMes: state.mes = action.payload; return ...state case resetMes: state.mes = hello; return ...state default: return state // 包装成store并返回let store = createStore(reducer)export default store拆分成模块合并包装import combineReducers from redux;function mesReducer(state=mes:hello, action)/**/function numReducer(state=version:1, action) switch(action.type) case addVersion: state.version ++; return ...state case resetVersion: state.version = 1; return ...state default: return state const reducer = combineReducers( mesReducer, numReducer)store.state的双向绑定Redux中维护的状态并不会像state或props一样，被监听是否改变并刷新页面。思路一：store.subscribe（不推荐）使用store.subscribe进行监听，每当有数据被修改时，重新渲染组件思路二：使用react-reduxreact-redux提供connect函数，能够在state和props之间建立映射关系，从而实现响应式更新react-redux使用步骤：对根组件进行Provider包装在调用状态的组件中使用connect进行关联connect是一个返回包装后组件的高级组件connect关联的状态在新组件中的props中包裹connect的2个参数：参数1：对state进行映射返回参数2：对dispatch进行包装返回import connect from react-redux;const connectApp = connect( (state= console.log(state) return mes:state.mesReducer.mes ), (dispatch= return dispatch, customFun:()=console.log(print something...) ))(App)export default connectApp; @reduxjstoolkit toolkit是redux的优化版，不同点在于：状态管理模块创建方式不同：redux创建reducer函数，legacy_createStore对store进行包装toolkit使用createSlice创建切片sliceconfigureStore对切片进行整合调用方式不同redux中dispath传递的actions.type类型要亲自定义可选操作和逻辑toolkit中根据切片的name和reducers中的成员名进行调用创建状态切片：let mesSlice = createSlice( name:mes, // 切片名称，用来在dispatch中定位 initialState: mes:hello, , reducers: changeMes(state,action) console.log(state,action) state.mes = action.payload , resetMes(state,action) state.mes = hello )组合切片：let mesSlice = createSlice( name:mes, initialState:/**/, reducers:/**/)let numSlice = createSlice( name:num, initialState:/**/, reducers:/**/)let store = configureStore( reducer: mesReducer:mesSlice.reducer, numReducer:numSlice.reducer, )切片reducer的调用export default function App() const state = useSelector((state= return state.numReducer )) const dispatch = useDispatch() return ( div Version: state.version br/ button onClick=()=dispatch(type:num/addVersion)/button /div )响应式修改状态的几种方式connect函数通过将props和store.state进行映射关联HookuseState：组件的state和store.state进行映射关联 useDispatch：获取到store的可操作方法useDispatch不需要用action调用到目标方法，可以直接将方法从切片中暴露出来：// 将方法从切片的actions中暴露出来export const changeMes = mesSlice.actionsexport const addVersion,asyncAddVersion = numSlice.actions// 直接在dispatch中调用import addVersion from ./store/toolkit_index;const dispatch = useDispatch();button onClick=()=dispatch(addVersion())新增版本号（引入版本）/button异步修改全局状态redux的action中是不支持直接执行异步修改状态的操作的，要想异步修改状态，必须对异步的三个状态（pending、failing、fulfilled）各自的操作进行定制（好麻烦）其间需要使用到createAsyncThunk，创建异步执行对象：/** * createAsyncThunk 为异步操作做包装： * 参数1：操作名 * 参数2：异步执行函数 */export let changeNumThunk = createAsyncThunk(numSlice/asyncAddVersion, async (params)= return await new Promise((res,rej)= console.log(params) setTimeout(()= res(999) ,1000) ))执行对象需要包裹在切片中的extraReducers中，这是一个专门处理切片内部逻辑（不用于暴露到dispatch）的reducers定义模块：let numSlice = createSlice( name:num, initialState:/**/, reducers:/**/, extraReducers:(chunk)= // pending状态的配置 chunk.addCase(changeNumThunk.pending,()= console.log(pending) ).addCase(changeNumThunk.fulfilled,(state, action)= console.log(fulfilled) state.version = action.payload ) )// 暴露出来export const asyncAddVersion = numSlice.actions异步操作的使用：import asyncAddVersion from ./store/toolkit_index;button onClick=()=dispatch(changeNumThunk(456))新增版本号（异步+引入版本）/button 路由权限案例案例描述 根据用户登录身份，服务端返回不同的路由客户端根据返回的路由生成路由映射当用户访问没有生成的路由时，重定向到默认页面 React生态React生态常用库 UI组件：Ant Design Ant Design Mobile应用框架：Umi 官方文档阅读HookmemouseCallbackuseMemomemo React子组件更新的触发方式有几种：父传子的props改变基础变量类型props（memo包装）函数类型props（useCallback）引用类型props（useMemo）自身state改变内部用到的context改变优化意见需要将props的变化范围控制在最小防止一个总会变化的props无效化memo如果不是绘图级别细粒度的组件更新，memo优化程度不大数据视图的展示放在父组件，修改数据方法用useCallback包装传入子组件 useContextuseContextcreateContext搭配实现组件对context的订阅context支持基础类型、引用类型防止Provider结构过于冗杂，可以将Provider封装成组件context可用于在传递对象和函数时进行优化重新渲染 useReduceruseReducer旨在对大量state相关操作进行逻辑集中书写，reducer函数需要两个参数：state：被操作的state数据action：选择的操作reducer函数的返回值就是state被修改的结果比如需要对同一个列表list进行增删改查操作，action一共有4种：增删改查reducer中根据action的不同，集中实现四种操作对应的逻辑，对外只暴露出4种action使用reducer往往出于以下几点考虑：代码可读性可调试性可测试性 useEffect一般用于将组件和外部组件同步常常将重复的useEffect用自定义Hook的方式单独拉出来封装可以定义setup和cleanup操作常用场景封装和第三方组件之间的接口挂载和清理Event事件请求数据useEffect可以指定依赖项：依赖为[]，只执行一次不加依赖数组，每次useEffect内容都会重新执行有依赖项，依赖项改变，useEffect内容会重新执行在使用引用类型（函数对象）作为依赖项时需要谨慎 forwardRef useImperativeHandle用forwardRef进行包装的子组件，可以将ref节点暴露给父组件，相当于vue中的defineExpose：这种暴露可以跨辈获取。配合useImperativeHandle可以自定义子组件暴露的内容 useLayoutEffect在浏览器重新绘制屏幕之前触发使用场景：网页内容的布局有时会根据显示内容而改变，当希望用页面上一帧的信息计算下一帧的布局时，就可以在useLayoutEffect中进行 useOptimistic允许在异步操作时更新state，增强用户体验，使用场景： 类似于数据未加载到客户端时的loading作用 useSyncExternalStore主要是为了在组件中，响应式展示第三方数据源。需要2个参数：subscribe参数为触发组件渲染的函数返回值为clenaup函数getSnapshot返回值决定暴露那些数据使用场景：类似store的用法，作为全局状态管理器监听浏览器的变量变化 组件Fragment 用于组合多个组件的空标签Profiler 测量组件渲染性能StrictMode 严格模式Suspense 在组件加载完成之前提供替代渲染内容 APIcreateContext 创建上下文forwardRef 创建可以将内容暴露给父组件的组件memo 创建根据propsstatecontext进行缓存的组件（而非强制根据父组件的重新渲染而重新渲染）lazy 组件懒加载startTransition 不阻塞UI的情况下更新state lazy用于实现组件懒加载可以配合Suspense实现组件灵敏加载 综合练习Hook综合练习一个聊天软件界面：鼠标移入时，光标变为圆点useEffect自定义Hook封装点击人，输入邮件内容，发送邮件聊天内容模块，提供跳转到最早聊天记录查看最新聊天记录按钮父组件调用子组件方法 forwardRef useImperativeHandle2个主要组件：联系人列表prop1 联系人列表 context1 当前发送信息的联系人context1 在此处被修改聊天界面context1 当前发送信息的联系人全局存储：useContext当前发送信息的联系人界面主题颜色监听网络：useSyncExternalStore监听浏览器网络连接 组件纯粹性 React提倡组件要保持纯粹，意思就是组件函数无论被调用创建多少次，渲染结果应当都是一样的，就和纯函数一样，只要输入值不变，输出值永远相同，这就意味着不应当引入全局变量等可能出现mutation（突变）的内容来污染组件这也是为什么在开发环境、严格模式下，React会将每个组件内容执行2次的原因，就是为了检查组件的纯粹性 React18 + Redux + React Router环境配置react开发依赖安装 安装下面的依赖包： react: ^18.2.0, react-dom: ^18.2.0, react-redux: ^9.1.2, react-router: ^6.26.2, react-router-dom: ^6.26.2, redux: ^5.0.1 初始化项目样式 以前都是手动添加，可以最直接npm下载包npm i reset-css 配置路径别名 首先安装node库的ts声明配置（为了在ts文件中使用path）npm i -D @types/node在vite.config.ts中配置路径别名：export default defineConfig( plugins: [react()], // 路径别名 resolve: alias: @: path.resolve(__dirname, ./src) )在tsconfig.json中配置，使编译器中提示路径别名下的目录结构：配置方法 baseUrl: ., paths: @/*: [ src/* ] antd 记住组件和图标是分开安装的就oknpm install antd @ant-design/icons --save 路由配置方法1：组件式路由配置 在src目录下创建router文件，其中创建路由组件index.tsx：import BrowserRouter, Route, Routes from react-router-dom;import App from @/App.tsximport Home from @/views/Home;import About from @/views/About;const baseRouter = () = ( BrowserRouter Routes Route path=/ element=App/ Route path=/home element=Home//Route Route path=/about element=About//Route /Route /Routes /BrowserRouter)export default baseRouter其中将根路径的组件设置为App，其它的组件都是App下的子组件，因此需要在App组件内添加Outlet组件作为子组件容器：function App() return ( div 下面是子组件： Outlet/ /div )在入口组件main.tsx中把Router组件嵌入：import Router from @/routerReactDOM.createRoot(document.getElementById(root)!).render( React.StrictMode Router/ /React.StrictMode,) 方式2：路由表配置 这种方式类似于vue-router的路由配置：import Home from @/views/Homeimport About from @/views/About;import Navigate from react-router;const routes = [ path:/, element:Navigate to=/home/Navigate , path:/home, element:Home/, , path:/about, element:About/ ]export default routes;入口文件中的App照常引入，并用Router包裹：import React from reactimport ReactDOM from react-dom/clientimport App from ./App.tsximport BrowserRouter from react-router-dom;ReactDOM.createRoot(document.getElementById(root)!).render( React.StrictMode BrowserRouter App/ /BrowserRouter /React.StrictMode,)在App.tsx中使用useRouter引入router：function App() const outlet = useRoutes(router) return ( div outlet /div )export default App 路由懒加载 使用路由懒加载lazy+Suspense组，可以对loading页面进行封装：const withLoadingComponent = (comp: JSX.Element) = ( React.Suspense fallback=divLoading.../div comp /React.Suspense)const routes = [ path:/, element:Navigate to=/home/Navigate , path:/home, element:withLoadingComponent(Home/) , path:/about, element:withLoadingComponent(About/) ] 子路由 和vue-router中同样使用children属性：const routes = [ // 子路由 path:/home, element:withLoadingComponent(Home/), children:[ path:page1, element:withLoadingComponent(Page1/) , ] ,] 全局匹配路由 在路由配置表最后添加一个配置项：const routes = [ path:*, element:Navigate to=/home/page1/ ] Redux具体内容参考这里 使用浏览器插件Redux DevTools可以协助进行开发在src目录下创建store文件夹，其中存放创建redux仓库的代码。storeindex.tsimport legacy_createStore from redux;import reducer from ./reducerconst store = legacy_createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ window.__REDUX_DEVTOOLS_EXTENSION__())export default storestorereducer.ts// 默认状态const defaultState = num: 20// let reducer = (state = defaultState) = const newState = JSON.parse(JSON.stringify(state)) return newStateexport default reducer还需要在根组件main.tsx中，添加一个全局数据提供组件对App组件进行包裹：import Provider from react-reduximport store from @/storeReactDOM.createRoot(document.getElementById(root)!).render( Provider store=store BrowserRouter App/ /BrowserRouter /Provider,)在组件中使用仓库数据，需要用到useSelectorimport useSelector from react-redux;function Page1() const num = useSelector(state=( num:state!.num )) return ( divnum = num/div )export default Page1;使用useDispatch调用仓库里定义的方法,在reducer回调添加action参数，用于判断选择操作的类型，let reducer = ( state = defaultState, action:type:string ) = // 对state进行深拷贝 const newState = JSON.parse(JSON.stringify(state)) switch(action.type) case addOne: newState.num++ break case addTen: newState.num+=10 break return newState在页面使用useDispatch调用操作：const dispatch = useDispatch()const addNum = (type) = dispatch(type) 关于全局仓库ts数据类型的定义 在全局类型声明文件vite-env.d.ts中添加声明：declare module *.ts在src下创建types目录用于存放一些类型声明文件，创建store.d.ts：/** * 类型声明里面不要直接使用import... from ... * 使用行内引入import(@/) */type RootState = ReturnTypetypeof import(@/store).getStateinterface Window __REDUX_DEVTOOLS_EXTENSION__:function;引用store的数据时，将对应的数据类型定义写上：// 参数定义为RootStateconst num = useSelector((state:RootState)=( num:state.num)) 合并多个store 将多个store抽取到单独的文件夹下，在storeindex下将多个store集中返回目录结构：- store - status_1 - index - reducer - status_2 - index -reducer - index.ts使用combineReducers将2个reducer结合起来：import combineReducers, legacy_createStore from redux;import NumStatusReducer from @/store/NumStatus/reducer.tsimport ArtStatusReducer from @/store/ArtStatus/reducer.tsconst reducers = combineReducers( NumStatusReducer, ArtStatusReducer)const store = legacy_createStore( reducers, window.__REDUX_DEVTOOLS_EXTENSION__ window.__REDUX_DEVTOOLS_EXTENSION__())export default store","tags":["Web"]},{"path":"/待整理资料.html","content":"Markdown All in One常用操作汇总（for Windows） Markdown 笔记必装神器 mermaid图表官网 Google发布2023年CSS的新特性"},{"title":"SVG 可缩放矢量图形","path":"/notes/cg_svg.html","content":"svg元素转换为dataUrl参考博客使用window.btoa接口能将svg字符传转换为dataUrllet svg = svg xmlns=\\http://www.w3.org/2000/svg\\ width=\\40\\ height=\\40\\ viewBox=\\-10 -18 100 135\\circle cx=\\50\\ cy=\\50\\ r=\\40\\ fill=\\red\\ stroke=\\%23ededed\\ stroke-width=\\3\\//svg;// 前面需要加上 data:image/svg+xml;base64, 前缀let dataUrl = data:image/svg+xml;base64, + window.btoa(svg);"},{"title":"友链","path":"/friends/index.html","content":"🐱模块开发中，即将开放…"},{"title":"three.js 3D库","path":"/notes/cg_threejs.html","content":"controls滚轮滚动导致无法渲染问题描述 OrbitControls引入后，鼠标拖动事件正常，使用滚轮进行缩放操作时，整个画面无法重绘。检查了camera的剪裁面配置，也没有问题。 解决方法 threejs版本问题，使用0.160.0版本的threejs会有这个问题，改成更低版本0.133.0就解决了。 Controls没有任何反应问题描述 配置了Orbitcontrols但没有任何反应，能进controls添加的鼠标事件的断点，但就是毫无反应。 解决方法 调试了大概一个小时，终于搞清楚了，因为我把相机和OrbitControls.target都放在了原点位置：camera.position.set(0,0,0)controls.target.set(0,0,0)这会导致OrbitControls的旋转矩阵计算出现问题，需要移动相机或者controls.target的位置：camera.position.set(-0.001,0,0)这样就解决了 移动端uniapp中使用threejs问题描述 想在用uniapp搭建的app端写一个用到threejs的项目，但是在第一步就卡壳了，先是真机测试，啥都渲染不出来，连个报错都没有，浏览器控制台也看不到，只有HBuilder的控制台上面，时不时的给我报出来一个错，大概意思是说获取不到render.domElement需要被append上去的那个dom元素。 解决方法 PC端调试Android手机的方法参考文章文章作者的总结非常简单易懂：vue本身不支持直接通过原生JS操作DOM，于是在uniapp里，可以通过renderjs来实现逻辑层(vue的template或者说虚拟dom)与视图层(原生dom)之间的通讯，或者说操作。在内联render中写需要操控dom的代码，问题顺利解决：template view view class=renderjs id=renderjs-view/view /view/templatescript module=render lang=renderjs import * as THREE from three import OrbitControls from three/examples/jsm/controls/OrbitControls export default mounted() const view = document.getElementById(renderjs-view) const renderer = new THREE.WebGLRenderer() renderer.setSize(window.innerWidth, window.innerHeight) view.appendChild(renderer.domElement) const scene = new THREE.Scene() const camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.01, 10000 ) scene.add(camera) camera.position.set(30,30,30) camera.lookAt(0,0,0) const controls = new OrbitControls(camera, renderer.domElement) controls.update() const axesHelper = new THREE.AxesHelper(5) scene.add(axesHelper) const boxGeometry = new THREE.BoxGeometry(3,3,3) const boxMetarial = new THREE.MeshBasicMaterial( color:0x00ff00 ) const box = new THREE.Mesh(boxGeometry, boxMetarial) scene.add(box) renderer.setAnimationLoop(animate) function animate() renderer.render(scene,camera) , ;/script PostprocessingUnrealBloomPass无法渲染透明通道问题描述 大屏项目中有个模块，需要绘制背景透明的3D场景，里面还有泛光效果，因此我使用setOpacity+UnrealBloomPass的方式来实现，但是实际渲染出来发现场景背景始终是黑色的，关闭UnrealBloomPass发现透明背景恢复正常。看来问题出在UnrealBloomPass上 解决方法 参考：UnrealBloomPass makes background blackUnreal Bloom and Renderer Transparency issue当前版本的three中，UnrealBloomPass确实不支持透明通道渲染，但是这个老哥改了几行UnrealBloomPass.js里的代码：改动详情实际上就是把材质的transparent打开，计算纹理的时候加入alpha通道的数值，但是这老哥也在底下说了：unrealBloomPass的泛光效果和html元素无法很好的融合在一起，不建议使用。这个issues底下还有个解决方案，用到的是shaderPass的方式：selective bloom example我一开始也想到用这个方法，即unrealBloomPass只渲染到指定图层部位，看来是可行的"},{"title":"Github","path":"/notes/devOps_github.html","content":"GitHub托管个人网站个人博客搭建利用GitHub搭建个人博客主要参考此篇博文：https://pdpeng.github.io/2022/01/19/setup-personal-blog/#%E5%BA%8F%E8%A8%80https://pdpeng.github.io/2022/01/19/setup-personal-blog/#%E5%BA%8F%E8%A8%80 静态网站托管利用GitHub可以托管静态网站https://www.youtube.com/watch?v=gyAdWWZRNBY&list=PLjcjAqAnHd1EIxV4FSZIiJZvsdrBc1Xho&index=49https://www.youtube.com/watch?v=gyAdWWZRNBY&list=PLjcjAqAnHd1EIxV4FSZIiJZvsdrBc1Xho&index=49在知乎上还发现一篇介绍github网站托管的文章，写的不错：https://zhuanlan.zhihu.com/p/76063614https://zhuanlan.zhihu.com/p/76063614 Git报错error: RPC failed; HTTP 400 curl 92 HTTP2 stream 5 was not closed cleanly: CANCEL (err 8)报错信息 在执行hexo deploy的时候报错：Total 129 (delta 121), reused 0 (delta 0), pack-reused 0error: RPC failed; HTTP 400 curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8)fatal: the remote end hung up unexpectedlyEverything up-to-dateFATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failedat ChildProcess.anonymous (D:\\HelloWorld\\Code\\Project_Indie\\Project_Web\\hexo_blog ode_modules\\hexo-util\\lib\\spawn.js:51:21)at ChildProcess.emit (node:events:519:28)at cp.emit (D:\\HelloWorld\\Code\\Project_Indie\\Project_Web\\hexo_blog ode_modules\\cross-spawn\\lib\\enoent.js:34:29)at ChildProcess._handle.onexit (node:internal/child_process:294:12) 处理方式 看报错信息，是由于网络速度慢导致连接关闭挂VPN再部署一遍就行了"},{"title":"🐱BlobCat Emoji","path":"/notes/emoji_BlobCat.html","content":"copy copy"},{"title":"🐧QQ Emoji","path":"/notes/emoji_qq.html","content":"emoji copy emoji copy"},{"title":"备忘录","path":"/notes/index.html","content":""},{"title":"JavaScript 语言","path":"/notes/lang_javascript.html","content":"Blob文件流的下载function blobDownload(value, fileName, type) let blob = new Blob([value], type: type) let downloadElement = document.createElement(a) downloadElement.href = window.URL.createObjectURL(blob) downloadElement.setAttribute(download, fileName) document.body.appendChild(downloadElement) downloadElement.click() document.body.removeChild(downloadElement) window.URL.revokeObjectURL(downloadElement.href) // 释放blob对象revokeObjectURLwindow.URL.createObjectURL 实际上是创建了一个对象URL字符串，指向指定的资源，在资源使用结束后最好通过revokeObjectURL手动释放，防止内存泄露"},{"title":"Python 语言","path":"/notes/lang_python.html","content":"python pip安装超时Python pip安装超时的几种解决办法"},{"title":"Web开发 网络相关","path":"/notes/net_webDev.html","content":"Axiosaxios传递FormData类型数据参数为空问题描述 通过axios上传文件，数据为FormData类型，但是通过浏览器看到传递的实际参数总是只有一个uuid，文件内容缺失 解决方法 前端通过axios和FormData实现文件上传功能遇到的坑这是因为传递FormData类型的数据时，Content-Type必须要是multipartform-data，但是在对axios文件的配置中，添加了默认头：’applicationjson;charsetutf-8’，所以将默认头去掉就行，如果不加默认头，axios检测到传递数据类型为FormData时，会自动去掉Content-Type，意思就是叫浏览器去转换这个的意思。但是低版本的axios就算是加了默认头也会对FormData的Content-Type进行去除操作，虽然这一步都是在axioslibadaptersxhr.js中实现的，但是不同版本对去除Content-Type的条件不同：低版本axios：// 直接判断数据类型if (utils.isFormData(requestData)) delete requestHeaders[Content-Type]; // Let the browser set it高版本axios：// 判断是否为FormDataif (utils.isFormData(requestData)) // 是否可以抛给浏览器做 if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it else if ((contentType = requestHeaders.getContentType()) !== false) // fix semicolon duplication issue for ReactNative FormData implementation const [type, ...tokens] = contentType ? contentType.split(;).map(token = token.trim()).filter(Boolean) : []; requestHeaders.setContentType([type || multipart/form-data, ...tokens].join(; )); 在高版本的axios中，对axios配置默认头会对浏览器造成干扰，因此传输的Content-Type没有被正确设置，需要将默认配置头去除 webChannel问题描述 浏览器网络监控网络层日志 net logchrome net log 参考博客chrome 地址栏输入:点击Start Logging to Disk按钮录制net log录制结束后，在 netlog-viewer 上查看网络日志的具体内容"},{"title":"npm 插件","path":"/notes/npm_npm.html","content":"🌉项目工程化插件PrettierPrettier | 文档https://www.prettier.cn/ Prettier.js在项目中配置无效，如何解决？ 问题描述 编译器：Cursor 0.49.6Prettier版本：3.0.0项目根目录下配置的.prettierrc.js如下.prettierrc.jsmodule.exports = semi: false, // 无分号 printWidth: 100, // 每行最多宽度 singleQuote: true, // 单引号 endOfLine: auto, // 保持现有的行尾 importOrder: [^@/(.*)$, ^@yige/(.*)$, ^[./]], importOrderSeparation: true, importOrderSortSpecifiers: true, plugins: [ require(@trivago/prettier-plugin-sort-imports), require(prettier-plugin-tailwindcss), ], tailwindConfig: ./tailwind.config.js,发现当格式化的时候，Prettier的控制台报错：Prettier Error resolving prettier configuration for x:\\xxx\\.prettierrc.js根据报错信息可以看出格式化时，配置文件确实使用的是根目录下的.prettierrc.js文件，但是文件的配置内容似乎不对。 解决方法 导致Prettier格式化失效+报错，一共有两个原因：原因1：prettier版本与plugin配置的语法不匹配主要是其中有个配置项plugins，在prettier 3.x.x版本中和2.x.x版本中的语法是不同的，3.x.x中，使用字符串进行定义：module.exports = // ... plugins: [@trivago/prettier-plugin-sort-imports, prettier-plugin-tailwindcss],2.x.x中，使用引用方式进行定义：module.exports = // ... plugins: [ require(@trivago/prettier-plugin-sort-imports), require(prettier-plugin-tailwindcss), ],原因2：.prettierrc.js 修改后需要重启编译器才能生效 （参考来源）prettier提供很多种配置模式：.prettierrc.jsonyamlymljson5toml.prettierrc.jstsmjsmtscjsctsprettier.config.jstsmjsmtscjscts但是不同配置文件，修改后生效的方式不同：.prettierrc.json：无需重启编译器就能重新生效.prettierrc.jscjsmjsts：必须重启编译器才能生效这个项目的 prettier 版本是3.0.0，对应的plugins不应该使用require引入，因此导致报错，再加上一直都没发现必须要重启编译器配置才能生效，所以一直没法解决这个问题😭最终有2种解决方式：方式1：将prettier版本退回到2.x.x版本（比如2.8.8）方式2：使用字符串的方式引入plugins npm包实现各种npm包的封装 基于vue的组件包封装工具函数包封装npm中文文档 npm install报错：Certificate has expired错误描述 E:\\register\\other\\threejs-factorynpm install -g cnpm -registry=https://registry.npm.taobao.orgnpm ERR! code CERT_HAS_EXPIREDnpm ERR! errno CERT_HAS_EXPIREDnpm ERR! request to https://registry.npm.taobao.org/cnpm failed, reason: certificate has expirednpm ERR! A complete log of this run can be found in: C:\\Users\\Administrator\\AppData\\Local pm-cache\\_logs\\2024-01-23T01_39_23_371Z-debug-0.log看错误应该是缺签名证书 问题解决 原Bloghttps://blog.csdn.net/qq_42761482/article/details/121018086当 strict-ssl 设置为 true 时，npm 会对连接的服务器的 SSL 证书进行严格的校验，并要求它是由可信的认证机构颁发的。如果校验失败，npm将无法连接到服务器并会报错。当 strict-ssl 设置为 false 时，npm 将不会对服务器的 SSL 证书进行校验， 并且即使证书是由不可信的认证机构颁发的也不会报错。这可能会导致安全风险，因为网络流量可能被劫持或篡改。如果短期内因为缺少SSL证书无法install依赖，可以现将strict-ssl设置为false，安全起见，下载完后尽快修改回truenpm set strict-ssl false 后续补充 https://blog.csdn.net/m0_74802419/article/details/135832868?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170625330016800184187977%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170625330016800184187977&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135832868-null-null.142https://blog.csdn.net/m0_74802419/article/details/135832868?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170625330016800184187977%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170625330016800184187977&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135832868-null-null.142我是用的是淘宝镜像域名：registry.npm.taobao.org自2024.1.22日开始，淘宝原镜像域名的HTTPS证书正式到期，这也是报缺少签名证书错误的原因，需要将npm源切换到新的源才行：registry.npmmirror.com npm install 报权限错误：npm EPERM: operation not permitted问题描述 在安装cnpm时，npm报错：npm EPERM: operation not permitted看来是操作权限问题，但是cmd是以管理员身份运行的，环境变量一个不缺，文件权限也全有 解决方法 最后发现是npm版本太低（npm6 + node14），换成高版本npm就好了（npm9 + node18） npm install 依赖版本冲突npm install --legacy-peer-deps cnpm install 导致vue项目启动后 @vueruntime-core 报缺错问题描述 安装npm包为了更快，用的cnpm进行安装，但是项目运行的时候报错：Failed to resolve import @vue/runtime-core 解决方式 单独安装@vueruntime-core用npm重装一遍（简单粗暴版）参考文件：pnpm 导致d.ts中@vueruntime-core 申明失效问题解决方案 parcel.jsparcel命令报版本不匹配错误问题描述 [ThrowableDiagnostic [Error]: The plugin @parcel/reporter-dev-server is not compatible with the current version of Parcel. Requires ^2.11.0 but the current version is 2.10.3.] diagnostics: [ message: The plugin @parcel/reporter-dev-server is not compatible with the current version of Parcel. Requires ^2.11.0 but the current version is 2.10.3., origin: @parcel/core, codeFrames: [Array] ]提到 @parcelreporter-dev-server 和当前 parcel 的版本不匹配需要2.11.0版本的，但是当前是2.10.3版本的，但是package.json里的parcel版本明明是2.11.0 问题解决 启动项目的是全局parcel不是项目里安装的parcel，因此需要更新全局parcel才行：npm i -g parcel@2.11.0 SheetJSSheetJS官方文档https://docs.sheetjs.com/docs/ 导入excel表格时间格式错误问题描述 正在修复一个几百年前的祖传项目，其中牵扯到一个导入excel表格的操作，结果发现excel里面被规范化为日期的字段导入网页就全变成了一个很离谱的数字，我猜想可能是格式转换导致的错误，下面就是修改方法：参考博客https://blog.csdn.net/m0_60694178/article/details/126389187 node-sass安装报错问题描述 虽然在这个库已经大部分的被sass取代，但是很多老项目还在使用，node-sass这个库安装10次，10次报错，真的很烦。 问题解决 排查1：检查node版本node和node-sass有严格的版本对应关系，如果版本不对应就会报错：官方文档我安装1.14.0版本的node-sass，因此就需要安装14版本的node排查2：Error: EPERM: operation not permitted字面意思上似乎是说：操作不被允许。这种报错一般情况下都能用 这篇博客 中提供的解决方式解决如果是安装速度慢的话可以参考 这篇博客 先是降低npm版本到5.3.0，安装卡在了\\vendor\\win32-x64-83\\binding.node上unlink E:\\wsy\\register\\fork\\vue3-drag-resize-rotate ode_modules\\.node-sass.DELETE\\vendor\\win32-x64-83\\binding.node刚看这一行，我以为是这个文件下载不下来，但是仔细看的话就会发现报的是unlink错，并且还伴随operation not permitted，后来才发现原来是在我试图install node-sass包的时候，项目竟然还一直启着（npm run dev），这个文件一直都在被占用（之前安装过一个高版本的node-sass，想要直接把它替换），所以在安装新版本包的时候一直都提示不允许（npm remove没有清理干净，忽视了被占用的文件），把项目关闭后，就能正常安装node-sass了。 vis-timeline中文zh-ch本地化参考博客import moment/dist/locale/zh-cn.jslet opiton = // ... locale:zh-cn, // 本地化配置let timeline = new vis.Timeline(targetDom, itemData, groupData, option)这里似乎只能用moment的zh-cn，引入dayjslocalezh-cn.js无效"},{"title":"ECharts 图表库","path":"/notes/npm_echarts.html","content":"echarts中文官网https://echarts.apache.org/zh/index.html echarts的custom类型实现的甘特图甘特图案例地址https://echarts.apache.org/examples/zh/editor.html?c=custom-profile ToolTip触发时对图例进行排序操作 关键代码 tooltip.formatter 配置为回调函数，回调函数参数为包含所有series的数组series数组中的每一个元素都有如下属性 seriesItem.seriesIndex series的绘制索引seriesItem.seriesName series的名称seriesItem.value series的值seriesItem.marker echarts的原生图例前彩色原点html元素seriesItem.axisValueLabel 触发tooltip的坐标轴值tooltip: trigger: axis, axisPointer: type: shadow , // 重组代码 formatter: function (params) if(!Array.isArray(params)) return params = params.sort((a, b) = (b.value - a.value)).map((i,index) = i.seriesIndex = index return i ) let axis = params[0].axisValueLabel let head = `div style=margin-bottom:10px;font-size:14px;color:#666;font-weight:400;line-height:1;$axis/div` return head+ params.map(i = let name = `span style=font-size:14px;color:#666;font-weight:400;margin-left:2px$i.seriesName/span` let value = `span style=float:right;margin-left:20px;font-size:14px;color:#666;font-weight:900$i.value/span` return i.marker+ name +value ).join(br/); , axisPointer: type: shadow 多折线图相互堆叠的emphasis样式问题 多折线图堆叠本来能够让被触发series以外的其他series淡出，如下配置： emphasis: focus:series 但是客户不想要淡出的效果，非得不淡出改变series的层级，那怕不是要动态改变series的zLevel，可太麻烦了。这里的思路是利用eCharts原生的高亮事件，但是对series的淡出样式进行控制，代码如下： emphasis: focus:series ,blur: , // 规范淡出样式 itemStyle: opacity: 1, lineStyle: opacity: 1 , label: opacity: 1 虚线实线混合使用的折线图 问题描述 折线图展示各个月份某项数值的变化，但是有的月份没有数据，客户希望没有数据的月份数据假定为上个月的数据 ，上个月如果也没有数据再假设为上上个月的数据，以此类推，假数据要用虚线标出，真数据用实线。 实现思路 这里当然就不指望ECharts原生的折线图能实现这个需求，因此需要隐藏折线图的连线，可以把线宽设置为0，也可以把颜色配置为透明，然后使用 markLine 依次连接前后两点，判断月份是否为空，如果存在月份数据，使用实线连接， 如果缺失月份数据，使用虚线连接"},{"title":"TypeScript 语言","path":"/notes/lang_typescript.html","content":"tsconfig.jsonimport第三方库时报错：不存在指定文件参考博客在threejs + ts的项目中，使用threeexamplesjsm下的文件，编译器报错，报错信息如下：一般这种情况都是没有安装第三方@type库，但是这回我安装了@typesthree，但是编译器就是找不到这个文件，因此需要手动在tsconfig.json文件中配置一下，手动指定类型解释文件的位置 compilerOptions: paths: three/examples/jsm/postprocessing/EffectComposer: [./node_modules/@types/three/examples/jsm/postprocessing/EffectComposer] ts报错: 不允许使用其它参数承接this报错信息Unexpected aliasing of ‘this’ to local variable.(@typescript-eslint/no-this-alias)解决方法参考博客修改eslintrc.json的配置 rules: @typescript-eslint/no-this-alias: [off] 其它ts项目热更新失败问题描述 在vue+ts的项目中，对ts文件进行修改，浏览器端运行无效，查看浏览器source中ts文件源码，发现代码确实已经被修改过，但运行的结果全是修改前的结果。 解决方法 遇到这种问题，无论是清浏览器缓存，还是换浏览器都是没用的，因为问题不出在浏览器端，而是服务端ts没有重新生成js，浏览器运行的始终是修改前的ts生成的js代码，而且webstorm项目的目录还自动屏蔽了ts生成的js文件，所以需要手动删除并重新生成编译后的js文件：也可以直接通过命令的方式（src目录下），删除生成的*.js和*.js.map文件：git rm -r *.js *.js.map参考博客"},{"title":"Node","path":"/notes/server_node.html","content":"nvmnvm的安装配置 参考博客简单的总结下步骤：官网下载安装nvm修改settings.txt，添加镜像脚本：node_mirror: https://npmmirror.com/mirrors/node/node_mirror: https://npmmirror.com/mirrors/npm/修改nvm安装文件的控制权限为完全控制修改文件执行权限配置环境变量有关环境变量和npm的配置nvm命令安装切换node版本最后，对于使用webstorm但是发现新更的node版本无论如何都无效的：Windows nvm 安装后webstrom vue项目编译报错，无法识别node修改Setting中Node的版本后，用Fileinvalidate cache重启npm install报错一条龙操作：删node_modules删package-lock.json清空npm包缓存：npm cache clean –force换node版本 nvm切换版本失败问题描述 用nvm use x.x.x命令，命令行打印切换成功，但是打印node版本时发现还是原来的版本。 解决方式1：直接删占用的node版本 一开始还觉得是版本切换有问题，一气之下干脆到nvm主目录里要把这个版本给删掉，结果发现它始终被占用，根本删不掉，后来发现是webstorm服务一直占用node（就算没开前端服务）把占用node的那个进程关了就能正常切换版本了。 解决方法2：检查是否是node版本号的问题 安装了node@14.0.0版本，但是无法切换过去：但是使用node@14.16.0版本时，切换就没有问题，因此有可能是因为node版本号的问题。"},{"title":"npm 插件推荐","path":"/notes/npm_packages.html","content":"VDR（vue3-drag-resize-rotate）技术简介 demo地址VDR是一个基于vue框架，能够快速实现dom元素的拖动、缩放、旋转、图层控制等操作的插件，更高级的功能还有网格对齐、位置冲突检测、元素吸附、辅助线等等，提供了大量的事件和自定义接口，非常灵活，官网文档写的很完备，非常好的插件 实际使用：canvas-base-vdr 未填坑：画布的缩放最初使用滚轮控制画布zoom值，能够实现画布收缩的效果，并且不改变dom的原始尺寸。问题在于zoom与 vdr 的拖拽和缩放计算有冲突。导致如下问题：放大后，物体移动距离比鼠标实际的移动距离要大，缩小后，物体移动距离比鼠标的实际移动距离要小vdr原作者是提供dom缩放功能的，但是使用的是scale变换，会改变元素的原始尺寸，因此这部分后面还有待实现。 vue-print-nb 页面分页指定元素打印能够快速实现页面dom元素打印的Vue扩展，非常方便。代码库地址npm install vue-print-nb --save"},{"title":"Vite 前端构建工具","path":"/notes/npm_vite.html","content":"Vite配置Network: use --host to expose问题描述 npm run dev之后，不能通过IP + 端口的方式访问到服务页面。控制台有提示信息：Network: use --host to expose 解决方法 参考csdn博主“勇敢的阿呆”博客在 vite.config.js 中加入 server 配置：...server: port:xxxx, // 端口号 host:true..."},{"title":"VSCode 编辑器","path":"/notes/tool_VSCode.html","content":"控制台VSCode控制台无法使用某些命令在用VSCode控制台激活conda环境时总是失败，但是使用cmd在同一目录下可以成功激活，解决方法：https://blog.csdn.net/weixin_44566432/article/details/131155615https://blog.csdn.net/weixin_44566432/article/details/131155615VSCode默认使用PowerShell脚本环境，需要在command prompt脚本环境下执行conda命令PowerShell脚本具有跨平台特性，Command Prompt脚本则主要在Windows平台运行 快捷键 单词选中快捷键"},{"title":"Browser 浏览器","path":"/notes/web_Browser.html","content":"控制台输出样式修改 console.log( + %c Stellar v + stellar.version + %c + stellar.github + , color:#e8fafe;background:#03c7fa;padding:8px;border-radius:4px, margin-top:8px); windowwindow.openMDN对window.open的说明https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open 问题描述 兼容性相关博客https://www.codenong.com/cs105814578/window.open()参数及浏览器兼容 window.topWindow.top 现在手上是一个BS端表格编辑器项目，支持表格的编辑、自动生成等功能，使用了大量的iframe标签用于对组件进行模块划分，因此当子窗口需要访问父窗口的属性或对象时，就不得不通过window.top进行访问。获取上级窗口的APIwindow.top 获取顶层窗口对象window.parent 获取父级窗口对象 性能Chrome超级卡问题描述 参考博客：解决 chrome打开多个视频页会卡顿的问题Chrome Edge 浏览器卡顿变慢视频掉帧问题正在做一个大屏项目，一个页面上需要渲染8个监控视频，再加上频繁的dom动画echarts图表渲染threejs渲总的来说：就是对浏览器的性能要求非常高我一开始是用 chrome 开发的，开发到后面 8个监控视频+6个背景视频直接卡到我怀疑人生 （裂开）于是就各种优化，无外乎就是Light House测试性能不该渲染的dom不渲染但是无论怎么优化都很卡，后面干脆视频都加载不出来了。于是我开始怀疑是浏览器的问题，换了edge加载之后，网页加载果然流畅很多，看到网上有很多说 关闭浏览器硬件加速 之后就好很多的，但是我的电脑关闭硬件加速后CPU直接飙到80%、90% 后面试着用了用 firefox 加载，也很快但是firefox的样式兼容上面是硬伤， Edge性能监视器工具 官方文档而且Edge的issue检测比chrome也灵敏一些，很多chrome检测不出来的issue，Edge都会在调试台里打印出来。 跨域CORS Web性能权威指南Web性能权威指南在前后端分离开发环境中，后台服务器响应头中 Access-Control-Allow-Origin 会一直设置为 * 状态（部分开发环境下的特例），但在上线后，CSR模式的页面作为静态资源，这时要和后台服务在同源策略下一起被提供，接口请求的方式也由绝对路径变为相对路径，也就是说，此时的静态资源是整个后台服务的附属资源，和接口资源处于同源之下，所以不用担心跨域的问题。但是如果A应用的页面要调用B应用的X接口，并且B应用没有将X接口的资源设置为可跨域请求，这时就会造成跨域，两种常用的解决跨域的方式：jsonPcors代理服务器 JsonP原理 JsonP需要服务器配合修改接口返回数据的方式，客户端请求分为：动态请求：XHR或Fetch发送的Http请求可能包含敏感信息由脚本控制静态页面资源：script标签引入的资源完全由浏览器运行不受脚本干预不包含敏感信息所以，浏览器会对动态请求实行严格的跨域限制，对静态页面资源会更加宽松JSONP的方式，就是将动态资源转化为静态资源请求 使用 **客户端：**需要将回调函数作为请求参数，将接口当做静态资源请求script function success(data) alert(JSONP请求成功) console.log(data) function getJsonP() const script = document.createElement(script) script.src = http://10.5.6.88:4060/jsonpGet?callback=success document.body.append(script) document.getElementById(test-jsonp).onclick = getJsonP/script**服务器：**手动包装一个函数调用，将数据作为参数传入函数中// jsonpapp.get(/jsonpGet,(req,res)= console.log(接收到jsonp请求) const callback = req.query.callback // 回调函数 console.log(req) const resData = code:200, message:收到了你的请求 console.log(callback) if(callback) let data = JSON.stringify(resData) res.end(callback+`($data)`) // 手动包装 else res.send(resData) ) Cors原理 Cors方法需要服务器修改响应头如果服务器主动表态：可以接受跨域获取资源，那么跨域请求也能够实现。这种方式就是服务器通过配置access-control-allow-origin主动开放跨域请求 实现 客户端：正常请求script function getCors() fetch(http://10.5.6.88:4060/corsGet,method:GET).then(res= if(res.ok) return res.json() ).then(res= alert(`请求成功：$res.messasge`) ) document.getElementById(test-cors).onclick = getCors/script服务器：将响应头中的access-control-allow-origin开放：app.get(/corsGet,(req,res)= res.setHeader(access-control-allow-origin,*) res.send( code:200, messasge:我允许你跨域请求资源 )) 代理服务器原理 同源策略是浏览器限制的，那只要不经过浏览器发送请求就行，这时候加入一个第三方代理服务器，也能够绕过同源策略 实现 客户端：正常向代理服务器发起请求script function getCors() fetch(http://10.5.6.88:4060/third,method:GET).then(res= if(res.ok) return res.json() ).then(res= alert(`请求成功：$JSON.stringify(res)`) ) document.getElementById(test-third).onclick = getCors/script服务器：向第三方发起请求，返回数据const proxy_url = www.third.com // 第三方地址// 代理app.get(/third,(req, res)= res.setHeader(access-control-allow-origin,*) axios.get(proxy_url) .then(data= console.log(转发成功) res.send(data.data) ).catch(err= console.log(转发失败,err) res.send(err) ))"},{"title":"好用的软件工具","path":"/notes/tool_tools.html","content":"加速器Github加速器推代码到github上总是时断时续的找到一篇知乎博主的文章：https://zhuanlan.zhihu.com/p/437818581https://zhuanlan.zhihu.com/p/437818581其中最后一条fastgithub真的很好用，软件原仓库已经被删了，但是被热心网友给提前打包到其他仓库了https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4"},{"title":"CSS 魔法","path":"/notes/web_css.html","content":"Css光标 caretcaret-color 光标颜色 caret-color可以用来修改光标颜色caret-color: red; 背景backdrop-filter 毛玻璃效果 参考博客： CSS简易毛玻璃效果backdrop-filter用于给背景添加滤镜效果backdrop-filter: blur(5px); TEXT 文字文字末端添加省略号 参考：CSS多行文本省略号单行末端添加省略号.box width:200px; /* 设置宽度 */ white-space: nowrap; /* 禁止换行 */ overflow: hidden; /* 超出隐藏 */ text-overflow: ellipsis; /* 设置省略号 */ 此处文字后添加省略号此处文字后添加省略号此处文字后添加省略号多行末端添加省略号.container display: -webkit-box; /* 设置webkit流体布局 */ -webkit-line-clamp: 2; /* 希望展示的行数 */ -webkit-box-orient: vertical; /* 垂直排列的效果 */ overflow: hidden; text-overflow: ellipsis; /* 设置省略号 */ 此处文字后添加省略号此处文字后添加省略号此处文字后添加省略号 定位fixed无法相对父元素定位参考博客fixed定位仅仅能相对于浏览器窗口，可以通过设置fixed元素的margin来实现div class=wrapper-box div class=scroll-box div class=inner-fix-boxFix Box/div /div/div.wrapper-box width:100px; height:100px; background: #ffaa00; overflow-y:scroll ;.scroll-box width:100%; height:300px; position:relative; z-index:99;.inner-fix-box width:100%; position:fixed; color:#000; color相对颜色语法Google专栏：CSS相对颜色语法 修改不透明度 color: rgb(from #00800080 r g b / alpha); /* alpha=50% */color: rgb(from rgba(0,128,0,.5) r g b / alpha); /* alpha=50% */color: rgb(from rgb(0 128 0 / 50%) r g b / alpha); /* alpha=50% */ 布局grid阮一峰：CSS Grid网格布局教程 响应式媒体查询 @mediaMDN"},{"title":"HTML","path":"/notes/web_html.html","content":"WebAPIshadow dom ShadowRoot 公司的项目用的是jquery框架，组件封装用的是HTMLElement，组件内部的结构全部使用shadowRoot进行包装。HTMLElement自定义组件class MyHello extends HTMLElement constructor() super(); // 创建组件的 Shadow DOM this.attachShadow(mode:open) // 创建组件内部的元素 const container = document.createElement(div) container.setAttribute(class, container) const content = ` img width=100px src=./img/toby_dog.jpg alt= div class=li-content p class=li-titleList Tag/p p class=li-contentList Content/p /div ` container.innerHTML = content // 样式设置 const style = document.createElement(style) style.textContent = ` .container border:1px solid #000; display:flex .li-content border:1px solid #000; .li-title font-weight:bold .li-content ` // 将元素添加到Shadow DOM中 this.shadowRoot.appendChild(container) this.shadowRoot.appendChild(style) // 注册自定义组件customElements.define(my-hello, MyHello)head script src=components/my_hello.js/script/headbody my-hello/my-hello/body FullScreen 全屏API MDN：全屏API 实现网站自动全屏目前还没有找到可以实现的方法，网站要想进入全屏必须得要交互触发，否则在调用requestFullscreen时会返回报错：TypeError: Permissions check failed at HTMLHeadingElement.toggleFullscreen (index.html:68:31) at index.html:79:50看了几个stackoverflow的高赞回答，主要也是劝放弃这种需求：Run a website in fullscreen modeFailed to execute ‘requestFullScreen’ on ‘Element’ [duplicate]这种设计是出于安全和交互性的考虑， 也有回答说如果真的想要实现这种强制全屏显示的页面，可以使用类似SPA网站的设计，用户点击页面后通过全屏同一页面的iframe模仿假页面切换并全屏显示交互效果 API实现和键盘全屏冲突问题问题描述 屏幕上有个按钮控制页面全屏，非全屏状态下点击变为全屏，全屏状态下点击退出全屏，按钮的样式显示当前页面是否是全屏状态，同时也要兼顾浏览器按F11和Esc切换全屏的功能。设置了一个变量记录当前是否全屏，在非全屏状态下，可以通过keydown事件监听F11的键入，但是在全屏状态下，浏览器无法监听到keydown事件（？？？）如何解决？ 解决方式 参考博客当然也可以直接在监听keydown事件，F11键入时，执行e.preventDefault()，阻止F11的全屏，只用单一入口控制是否全屏，但是如果同时要保留F11和Esc的功能，要如何解决 标签imgimg标签图片自适应问题描述 使用img标签展示图片时，一直不知道如何实现调整图片尺寸的同时保持原始长宽比。以往都是用css里的background-img来实现这一功能， 这个问题一直都没解决。之前听说如果在img标签上只设置width，即可保持长宽比，但是好像没什么用。 解决方法 https://blog.csdn.net/z2181745/article/details/114919271https://blog.csdn.net/z2181745/article/details/114919271使用css中的object-fit属性，类似于background-size属性可以控制img标签展示图片的模式，可选值有：fill|contain|cover|scale-down|none|initial|inherit; inputinput:file上传同一个文件时，change不触发问题描述 在使用input:file时，一般会绑定一个onChange事件，用来监听文件上传事件，但是如果反复上传同一份文件，只有第一次上传会触发change事件。 解决方法 https://blog.csdn.net/chelen_jak/article/details/89358075https://blog.csdn.net/chelen_jak/article/details/89358075上传的文件路径会被存储在 $event.target.value中，因此需要每次都将 $event.target.value 清空：function change(e) e.target.value = null videovideo标签无法自动播放问题描述 video标签已经设置了autoplay属性，视频依旧无法自动播放 解决方案 参考博客：video 标签无法自动播放需要把muted属性和autoplay属性一起配置上去:video src=./citywalk.mpp4 autoplay muted/video video加载blob格式视频问题描述 meta常用HTML Meta标签大总结 移动端浏览器如何去掉头部导航栏是谁还在做浏览器上运行的移动端网页，这个问题真的有解决的必要吗？而且不同的浏览器的去除方式还都有可能不一样，放弃这个功能吧。https://blog.csdn.net/hbcui1984/article/details/8350107https://segmentfault.com/a/1190000018559886https://www.jianshu.com/p/61e324e0efa2 Page-EnterPage-Exit 控制页面进入退出效果插入Page-EnterPage-Exit无效 Meta http-equiv=Page-Enter Content=blendTrans(Duration=10.5) /Meta http-equiv=Page-Exit Content=blendTrans(Duration=0.5) /Meta http-equiv=Page-Enter Content=revealTrans(duration=3, transition=9)Meta http-equiv=”Page-Enter” Content=”revealTrans(duration=x, transition=y)”Meta http-equiv=”Page-Exit” Content=”revealTrans(duration=x, transition=y)” 移动端浏览器自定义导航栏目前似乎只能设置颜色，通过设置页面meta头的theme-color：meta name=theme-color content=#ff0000/"},{"title":"React 框架","path":"/notes/web_react.html","content":"创建新的React项目npx create-react-app new-app-name 推荐安装的库： 常用工具库：lodash 类名书写简化库：classNames 生成唯一标识库：uuid 接口请求：axios 状态管理：@reduxjstoolkit 路由：react-router-dom"},{"title":"uniapp 开发","path":"/notes/web_uniapp.html","content":"uniapp中使用echarts在uniapp中使用echarts可以参考这一篇：uniapp中使用threejs uniapp中echarts.tooltip功能失效问题问题描述 在uniapp中使用echarts时，发现通过pc端通过click触发的tooltip在移动端不生效。 解决方法 参考博客https://blog.csdn.net/weixin_53791978/article/details/127111456echarts 引入的时候，会优先判断当前的环境。由于uni app 中有一个 ‘wx’ 全局变量污染了echarts中的 wx 变量，导致这里的判断直接走第一个，echarts 部分功能无法生效。因此需要再main.js中，将全局变量重新赋值：window.wx = 当然这会导致uni-app中的wx全局变量无效，不过如果开发的不是wx环境下的程序， 应该不用担心这一点 uni-app 路由跳转跳转到绝对路径问题描述 uniapp中进行页面跳转时，使用如下方式跳转：// 当前的路由为pages/manager/indexuni.navigatorTo( url:pages/error/AuthError)跳转报错，错误信息提示路由跳转到了 pagesmanagerindexpageserrorAuthError 解决方法 https://ask.dcloud.net.cn/question/78943https://ask.dcloud.net.cn/question/78943需要在uni路由跳转接口的url参数中用 斜杠开头：uni.navigatorTo( url:/pages/error/AuthError)斜杠开头后跳转成功。 钉钉小程序开发钉钉免登报错问题描述 开发钉钉H5微应用，调用钉钉免登api报错,调用的api是这个：runtime.permission.requestOperateAuthCodehttps://open.dingtalk.com/document/orgapp/obtain-the-temporary-authorization-code-for-micro-application-feedback-operationhttps://open.dingtalk.com/document/orgapp/obtain-the-temporary-authorization-code-for-micro-application-feedback-operation报错信息如下： method:runtime.permission.requestOperateAuthCode, err: errorMessage:1002, 跳转的URL不是安全URL, errorCode:3 , success:false沾点边的帖子：https://developer.aliyun.com/ask/245659https://developer.aliyun.com/ask/245659 解决方法 最后问题解决了，不清楚怎么解决的，最先我还以为是ip权限的问题，最后后台告诉我他把key刷新了一下，就不报错了最终免登用的是另外一个接口，获取小程序免登授权码用的：https://open.dingtalk.com/document/orgapp/mini-program-free-login#https://open.dingtalk.com/document/orgapp/mini-program-free-login# 钉钉免登报错（后续）问题描述 钉钉免登成功之后，过了大概一个多月的一天，测试突然反馈免登失效了，报错信息如下：dd error:[message.权限校验失败 Code:52011-Message;jsapi ticket 读取失败errorCode:3 问题解决 官网有关jsapi ticket读取失败的原因解释：https://www.dingtalk.com/qidian/help-detail-1060077225.htmlhttps://www.dingtalk.com/qidian/help-detail-1060077225.html根据官网的说法，经过排查后，发现原因是由于放在后端的jsticket缓存时间过长导致过期 uv-uiuv-tab实现横向滚动功能问题描述 uv-tab横向滚动选项卡必须要通过切换tab页的方式，不能通过拖拽直接滚动tab选项卡 将包裹tab-item的容器的scroll-y打开，然后将滚动条隐藏即可:deep .uv-tabs__wrapper__nav overflow-y: scroll; ::-webkit-scrollbar width: 0; height: 0; background-color: transparent;"},{"title":"Vue 框架","path":"/notes/web_vue.html","content":"Vue CLInpm run build 报错Syntax Error: Thread Loader(Worker 0) Syntax Error: Thread Loader(Worker 0)The “from” argument must be of type string. Received undefined. 解决方法参考博客https://blog.csdn.net/weixin_62277266/article/details/128437519 npm run server 报错Component provided template option but runtime compilation is not supported in this build of Vue. Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias “vue” to “vuedistvue.esm-bundler.js” 问题描述 最近有个原本用 vue2+webpack 的项目，需要用 vue3+vite 进行重构，原项目里用了很多使用字符串template构建的组件：export const SearchResetGroupButtons = template: ` div组件/div `, props: [prop1, prop2], data:()=return , // ...;将这些代码重写到vite构建的新项目里时，报了上述的错误。 解决方法 https://blog.csdn.net/huangpb123/article/details/122753934https://blog.csdn.net/huangpb123/article/details/122753934 vite.runtimeCompiler实现template动态渲染Configure your bundler to alias “vue“ to “vue/dist/vue.esm-bundler.js“ VueRouter动态加载组件的vue项目打包后报错问题描述 在写一个纯demo展示类的项目时（vite+vue3），因为demo和demo之间彼此没什么关系，父子也毫无关系，因此这些demo组件都能批量自动导入，因为我懒得在页面上一个一个把组件写进去，所以就用如下代码根据路由参数自动导入：script setup import getCurrentInstance, defineAsyncComponent from vue; const proxy = getCurrentInstance() const ThreeComp = defineAsyncComponent( loader:()=import(proxy.$route.query.router) )/scripttemplate!-- 动态组件 -- ThreeComp/ThreeComp/template这么写在本地运行时没出任何问题，但是打包部署后发现程序运行时报组件引入的错误：Failed to load module script: Expected a JavaScript module script but the server responded with a MIME type of text/html. Strict MIME type checking is enforced for module scripts per HTML spec. 问题解决 这是因为在vite打包时没有检测到这些动态引入的组件，因此这些组件实际上没有被打包进去，所以这里我就放弃了动态引入组件的方式，选择批量引入路由，在vite中批量引入可以通过import.meta.glob的方式：Vite Glob导入参考博客在routerindex.js中添加批量引入的代码：function addRouter() const modules = import.meta.glob([ @/components/GSAP/**.vue, @/components/three/CSS3D/**.vue, ]) for (const path in modules) modules[path]().then((mod) = const file = mod.default router.addRoute( path: / + file.__name, name: file.__name, component: file, ); ); addRouter()"},{"title":"待整理杂项","path":"/wiki/CG/other_01_unclassified.html","content":"Shading 着色最常见的着色算法Flat shading 平面着色根据每个三角形法线计算着色效果Gouraud shading 逐顶点着色针对每个顶点计算颜色，再进行线性插值得到片元颜色Lambert Shading 光照着色与Gouraud shading非常相似的模型，同样使用逐顶点计算光照，再进行片元差值的方法Phong shading 逐片元着色针对三角形每个片元进行着色计算PBR Shading 物理渲染Physically Based Renderingthreejs中的Shading算法threejs中不同的材质使用的光照模型可能有所不同：MeshPhongMaterial使用的是Phong Shading可以通过开启flatShading属性，使用平面渲染MeshStandardMaterial使用PBR模型（Cook-Torrance反射模型）Physically Based Rendering 基于物理渲染更真实模拟现实中光照和材质的相互作用考虑了光的漫反射、镜面反射、金属度等物理属性MeshLambertMaterial 使用的是 Lambert Shading几种材质的比较"},{"title":"Knova介绍","path":"/wiki/Canvas/Konva-01-intro.html","content":"Konva文档 Konva特点： 高性能动画、补间、节点嵌套（甚至包含数千个图形） 布局、滤镜、缓存、事件绑定 结构： 树结构 Stage舞台 → Layer图层 → Group组 → Shape图形 根节点为Stage 叶子节点为Shape 所有结构都是虚拟节点，类似于Html的DOM节点 每个layer有2个canvas渲染器（QA） 场景渲染器：输出所看内容（类似GPU） 图形命中检测渲染器：在隐藏的canvas里用于高性能检测事件 概念： 基本图形： 支持Rect矩形、Circle圆形、Ellipse椭圆、Star星形、Polygon多边形、Regular Polygon等边多边形 Line直线、Spline样条曲线、Blob团型 Image图片 Text文字、TextPath路径文字、Label标签 SVG Path矢量路径、custom Shape自定义图形 样式 fill填充（solid color实色、gradients渐变、images图片） stroke线条（color线条颜色、width线宽） shadow阴影（color颜色、offset偏移、opacity透明度、blur模糊） opacity透明度 事件 输入事件 click、dblclick、mouseover、tap、dbltap、touchstart attributes变化事件 scaleXChange、fillChange 拖放事件 dragStart、dragmove 滤镜 动画 选择器 可以根据type、id、name进行选择 序列化反序列化 将对象保存为Json格式 通过json创建对象 性能 缓存Caching，允许在buffer canvas里绘制元素，然后将buffer canvas中的元素绘制到场景（QA） 图层控制"},{"title":"性能控制","path":"/wiki/Canvas/Konva-02-Performance.html","content":"http://konvajs-doc.bluehymn.com/docs/performance/All_Performance_Tips.html Shape Cachinghttp://konvajs-doc.bluehymn.com/docs/performance/Shape_Caching.htmlhttps://konvajs.org/api/Konva.Node.html#cache 通过cache，可以将node转变成图片，再渲染到场景中 适用于需要大量绘制重复元素的场景 实现原理： 将目标节点（ShapeGroup）绘制到一个离屏的canvas上，生成一个静态图像快照（静态位图）以提高性能 之后渲染时直接复用这张位图，避免重复计算和绘制，从而提高性能 类似于蛋糕模具的功能 跨域问题： 如果目标节点上使用了图片，那这张图片不允许跨域获取 Canvas污染 https://developer.mozilla.org/zh-CN/docs/Web/HTML/How_to/CORS_enabled_image 当canvas绘制使用到跨域图片时，浏览器会标记该Canvas为“污染”状态 受污染的Canvas无法读取像素数据 cache无法自动检测到节点的尺寸，因此需要指定xywidthheight等变量 使用cache绘制大量重复图形 Layer Management 层级管理http://konvajs-doc.bluehymn.com/docs/performance/Layer_Management.html konva中每个layer对应独立的canvas元素 在更新、移动、动态变化指定layer的元素时，不会重绘其它图层的元素 在konva中，stage对应一个DOM容器，layer则对应一个canvas元素 建议：一般不会创建过多元素，最多3-5个 使用layer区分动态画布和静态画布： layer分层 Optimize Animation Performance 优化动画性能使用animation函数控制动画帧的时候，如果在某一帧没有需要更新的内容，可以通过返回false的方式禁止画布刷新 优化点：减少帧刷新次数 // 振幅const amplitude = 100// 周期const period = 2000const centerX = stage.width() / 2const anim = new Konva.Animation(function (frame) if (frame.time % (period * 2) period) // 第一个period周期内更新 hexagon.x( amplitude * Math.cos((frame.time * 2 * Math.PI) / period) + centerX ) else // 第二个周期停止刷新 return false , layer)anim.start() 通过减少动画帧实现优化 Batch Draw 批量绘制http://konvajs-doc.bluehymn.com/docs/performance/Batch_Draw.html 典型场景 监听鼠标位置更新单个元素时，会引起整张画布频繁地更新 这种情况可能会导致极度密集的重绘 可以通过batchDraw，将重绘系统挂载到动画引擎上 // 整体重绘layer.draw()// 批量重绘layer.batchDraw() Shape Redraw 图形重绘// 画布重绘layer.draw()// 节点重绘shape.draw() Konva支持单独重新绘制某个图形，并且不会刷新整张画布，但重绘节点必须满足如下条件： 节点不能是半透明的 节点不需要与其他节点重叠 重绘的节点会覆盖在其他节点的上层 节点绘制结果不需要依赖下层内容（比如没有混合模式） 重绘单个节点"},{"title":"D3 - Zoom","path":"/wiki/Canvas/d3-01-zoom.html","content":"d3-zoom官方文档https://d3js.org/d3-zoom#zoom Zoomable bar chart 官方代码地址 关于zoom 要实现一个可以实现滚动、平移的柱状图，ECharts中用到的一般都是datazoom组件，d3中提供了zoom类d3-zoom经常用于d3-scale和d3-axis的交互操作 核心代码 和普通柱状图一样，创建svg、横纵坐标系、柱状图g后，需要给svg标签添加zoom功能:function zoom(svg) let extents = [ [marginTop - width/2], [width/2 - marginTop] ] svg.call( d3.zoom() .scaleExtent([1,8]) // 缩放级别 .translateExtent(extents) // 平移范围 .extent(extents) // viewBox尺寸范围 .on(zoom,zoomed) // 绑定zoom事件 ) function zoomed(event) // 更新x轴配置 x.range([marginLeft-width/2, width/2-marginLeft].map(d= event.transform.applyX(d) )) // 重绘柱子宽度和位置 svg.selectAll(.bars rect) .attr(x,d=x(d.letter)) .attr(width,x.bandWidth()) // 重绘x轴 svg.select(.x-axis) .call(d3.axisBottom(x).tickSizeOuter(0)) svg.call(zoom)本例为svg指定的d3.zoom()配置了4个属性：scaleExtent 缩放级别translateExtent 平移范围extent viewBox视口范围zoom事件在d3.zoom()绑定的zoom事件中，做了三件事：更新x轴生成器函数将x轴的范围通过zoom.transform.applyX 函数进行变换applyX的加工函数为xk + tx重新绘制柱子，改变柱子的x坐标和width宽度根据更新的x轴生成器函数，重新绘制x轴"},{"title":"D3 - Selection","path":"/wiki/Canvas/d3-02-selection.html","content":"d3-selection Selection elementsModifying elementsJoining dataHanding eventsControl flowLocal variablesNamespaces Selection elements dom选择器d3.selection()选中根dom在原型链上添加自定义方法 d3.select(selector)选中第一个selector可以是字符串，也可以是指定的dom元素 d3.selectAll(selector)选中所有selector可以使字符串，也可是一个包含指定dom元素的可迭代对象 selection.select(selector)selector可以是字符串、dom、函数函数类型必须返回domElement或null selection绑定的数据会向下传递到被选中的元素中 selection.selectAll(selector)selector可以是字符串、dom、函数函数类型必须返回domElement组成的可迭代对象或空数组 selectionAll.selectionAll返回的元素会被自动分组 selection.filter(filter)过滤器filter可以是字符串或者函数 selection.selectChild(selector)选中第一个selector匹配到的孩子，selector可以是字符串、函数没指定selector返回第一个孩子 selection.selectChildren(selector)选中每一个selector匹配到的孩子，selector可以是字符串、函数没指定selector返回所有孩子 selection.selection()返回对应选中元素 d3.matcher(selector)返回一个函数，函数指向的this如果满足selector返回true是d3在selection.filter中用到的内部方法 d3.selector(selector)返回一个函数，函数指向的this是第一个满足selector的元素selection.select用到的内部方法 d3.selectorAll(selector)返回一个函数，函数指向的this是所有满足selector的元素selection.selectAll用到的内部方法 d3.window(node) node是dom节点，返回所在document的默认窗口 node是document，返回所在的默认窗口 其它，返回node d3.style(node, name)获取指定node元素的指定name样式属性值 Modifying elements 修改元素selection.attr(name, value)修改获取选区指定属性 selection.classed(names, value)selectiohn.classed(foo,false) .classed(bar,true) 添加去除类名 selection.style(name, value, priority)修改获取样式属性 selection.text(value)将selection下的所有内容替换成value文本无参数时返回selection下第一个子元素的文本内容 selection.html(value)修改获取selection的innerHTML，对svg或其他不支持html的元素不适用 selection.append(type)新增的元素从后面插入 type可以是字符串或函数，字符串可以带前缀 selection.insert(type, before)将type类型的元素插入到before之前 selection.remove()移除selection selection.clone(deep)在selection后插入一个复制元素，deep为false时，不会复制子元素 selection.sort(compare)选区数据排序，默认升序 selection.order()如果selection绑定了data数据，data数据的顺序重排后需要根据新顺序重新处理selection元素，可以使用selection.order() selection.raise()selection的每个子元素从队尾顺序推入 selection.lower()selection的每个子元素从队首顺序推入 create(name)创建一个name名称的元素 creator(name)指定元素生成器， selection.append和selection.insert创建新元素的内部方法 Joining data 数据绑定 By passing separate functions on enter, update and exit,you have greater control over what happens.And by specifying a key function to selection.data,you can minimize changes to the DOM to optimize performance. 在数据驱动变化的可视化图表中通过控制selection.data的key值，可以最小化dom变化的开销，通过指定join的enter、update、exit，可以对数据绘制的过程有更多的控制。 selection.data(data, key)data是一个可迭代对象key是data用于排序的凭据，可以是函数类型 selection.join(enter, update, exit)对绑定的数据进行处理enter、update、exit是三个生命周期，可以对数据进行不同的处理 svg.selectAll(circle) .data(data) .join( enter = enter.append(circle), update = update, exit = exit.remove() ) .attr(fill, none) .attr(stroke, black); selection.enterupdateexit如果有这么一个data序列：[2,3,4,5,6]把data与某一selection绑定，那么在enter时，data就是[2,3,4,5,6] 之后对data做一定的修改，data变成了[4,5,6,7,8,9]那么enter、update、exit接收到的数据依次如下： enter：[7,8,9] update：[4,5,6] exit：[2,3] 一般在这三个步骤中做一些动画过渡操作，在enter中初始化元素，在exit中remove对应元素 selection.datum(value)为选中的所有区域提供完全相同的value数据 selection.merge(other)合并selection与ohter selection，selection.join中enter和update合并时使用的内部方法 Handling events 事件监听selection.on(typenames, listener, options)typenames不仅可以是单个事件名，也可以是由空格分隔的多个事件名：”input change”同时可以添加后缀：”click.foo click.bar” selection.dispatch(type, parameters)调用selection绑定的type事件，parameters可以配置的项有： bubbles：允许向上冒泡 cancelable：允许event.preventDefault detail：event参数和自定义数据关联 d3.pointer(event, target)获事件event触发时，相对target元素的坐标位置 event可以是MouseEvent、PointerEvent、Touch或者其他涉及到坐标位置的操作 event 事件类型 target 目标点 d3.pointers(event, target)涉及到多个点位触发的事件，比如Touch事件返回的是由多个点位坐标组成的数组 Control flow 流向控制selection.each(function)遍历一个可迭代的选中区域对象中的每一个选中区域。 selection.call(function, …arguments)一般用于对生成器函数进行封装后，可重复调用：生成器函数： function name(selection, first, last) selection .attr(first-name,first) .attr(last-name,last) 之后可以批量调用该函数： d3.selectAll(div).call(name,John,Snow) 相当于： name(d3.selectAll(div),John,Snow) selection.empty()用于判断selection是否为空 selection.nodes()获取selection选中的一个数组 selection.node()返回selection选中的元素 selection.size()返回选中区包含元素的数量 Local variables 本地标识d3.local()生成一个独一无二的变量名 d3.local.set(node, value)一般d3.selection.each配合使用，用于给每个节点赋予value标示值 d3.local.get(node)获取节点的唯一标示值 d3.local.remove(node)删除节点存储的标示值"},{"title":"flatten介绍","path":"/wiki/Canvas/flatten-01-intro.html","content":"flatten-js：Javascript 几何坐标系库 flatten-js官方文档 Observable教程"},{"title":"Polygon","path":"/wiki/Canvas/flatten-02-Polygon.html","content":"官方文档：https://alexbol99.github.io/flatten-js/Polygon.html observable相关教程：https://observablehq.com/@alexbol99/flattenjs-tutorials-polygons Polygon 多边形模型flatten的Polygon被由2个部分组成： edges：segment（线段）或者arc（弧线） faces：封闭的面 面中的边形成的是环形的双向链表，因此可以向前和向后遍历这些边 Polygon顶点的方向可以通过addFace在一个Polygon中添加多个face， 如果每个face彼此间都没有交点，那么都算作独立的完整部分 如果face之间存在交叉区域，需要考虑到顺逆时针 重叠路径的填充一般有2种规则（https://www.zhangxinxu.com/wordpress/2018/10/nonzero-evenodd-fill-mode-rule/）： nonzero 从任意点O射出一条射线，取射线和路径（AB）的交点P，如果OP和APBP组成顺时针方向+1，逆时针方向-1, 最终得分不是0，点在内部，是0，点在外部 evenodd 从任意点O射出一条射线，取射线和所有路径的交点 交点数是单数，在内部，交点数是偶数，在外部 flatten中一律选用evenodd规则 部分路径重叠的图形 最终图形去除掉重叠区域 对于包含关系的图形，分为island和hole区域 包含图形为island，被包含图形为hole 构造函数 通过segarc组成的数组创建 通过点数组创建 通过boxcircle实例创建 通过代表点的数字对数组创建 new Polygon() 属性 edges 边集合 PlanarSet类型 faces 面集合 PlanarSet类型 vertices 顶点集合 edges faces box vertices addFace addVertex area cut contains cutWithLine deleteFace distanceTo dpath findEdgeByPoint intersect isEmpty isValid reacreateFaces removeChain removeEndVertex reverse rotate scale splitToIslands svg toArray toJSON transform translate 方法"},{"title":"简介与开发工具安装","path":"/wiki/Cocos/creator_01_intro.html","content":"教程资源 野生程序君-Paul Cocos引擎简介官方网站 cocos引擎简介 Cocos核心产品包括：Cocos2d-xCocos3d编辑器 Cocos Creator游戏加速框架 Cocos Runtime智能座舱解决方案 Cocos HMI互动课件编辑器 Cocos ICEXR方向各创作工具 Cocos Creator XR什么是游戏引擎？对于大部分游戏都包含的近似的内容，比如：基础Sprite类资源加载器ResourceLoader其它的各种方法物体移动碰撞检测子弹发射…将这些基础内容组合起来的类库，就是基础的游戏引擎比较著名的游戏引擎团队大型开发引擎DOOM引擎，《毁灭战士》，1993年，第一个商业授权的游戏引擎Quake引擎，《雷神之锤》，第一款真正意义的3D引擎Unreal引擎，1998年，《荒野大镖客》，Epic Games开发，专注于微软DirectXSource起源引擎，2004年，Valve自研引擎，《CS：GO》CryEngine引擎，CryTech，《孤岛惊魂》独立游戏开发引擎Unity，C#，跨平台优势Cocos引擎，跨平台，JsTs Cocos Creator安装新项目 首先下载Cocos Dashboard，cocos版本管理器下载链接这里安装了2种版本的cocos：2.4.103.6.2项目目录assets 游戏资源audio 音频images 图片scenes 场景scripts 脚本internal 引擎自带类库scripts脚本的添加鼠标右键创建新的ts脚本，主要目的，是控制界面label组件显示的文件内容：const ccclass, property = cc._decorator;/** * cc 命名空间 * Component 组件 */@ccclassexport default class HelloWorld extends cc.Component // 将当前Label组件的显示内容string修改为Hello World start () console.log(Hello World) this.getComponent(cc.Label).string = Hello World 游戏运行用浏览器打开的结果 配置代码编辑器点击Cocos Creator左上角：文件设置，在弹出的Editor Window中，进入【数据编辑】菜单进行配置：外部脚本编辑器官方推荐使用VSCode外部图片编辑器up主还介绍了几个比较实用的VSCode快捷键：Ctrl+Space 进行代码快速提示：和操作系统输入法快捷键冲突解决方案Alt+Shift+F 进行代码格式化"},{"title":"Node的属性与操作","path":"/wiki/Cocos/creator_02_oop_cop.html","content":"Node节点OCP（面向组件开发）是Cocos的核心开发方式，根据每种组件创建的示例就是一个Node单位，Node具有以下一些属性：基本属性坐标旋转缩放尺寸…Node编辑的快捷键： WERT渲染属性Sprite组件所具有的特殊属性 层级管理器具有父子嵌套关系的节点，父节点基础属性的变化会影响到子节点（没什么特别的）绑定在父节点的脚本中可以直接获取到子节点的数组：// 直接修改子节点的属性this.node.children[0].opacity = 255cc.log(this.node.children.length) Sprite属性Sprite组件参考Cocos中支持创建2种渲染模式下的Sprite：精灵Sprite：2D3D游戏内最常见的显示图像的方式纯色Sprite：常用于空气墙Sprite属性Atlas使用拼贴类型图片和plist进行贴图定位Sprite Frame贴图TypeSimple 普通模式 根据原始图片渲染SpriteSliced 九宫格模式一般用于UI资源中间格自由变换，边缘格沿边缘方向拉伸Tiled 平铺模式瓦片平铺，常用于制作地形Filled 填充模式沿固定方向比例切割原始图片常用于数值条的动态显示Size ModeBlend 混合模式Material 材质"},{"title":"Event 交互事件","path":"/wiki/Cocos/creator_04_interactions.html","content":"事件系统 事件监听监听事件 eventTarget.on(type, func, target?);type：事件注册字符串func：事件回调函数target：事件接收对象on和once的区别on监听的事件每次都会触发once监听的事件首次响应后就会关闭监听取消监听事件eventTarget.off(type, func?, target?)指定卸载的响应事件和卸载事件对象都是可选的 自定义事件 自定义事件一般很少用到，因为大部分时候，都能直接获取到目标Node并调用其中的方法。自定义事件有两种主要的定义方式：emitdispatchEvent使用on来自定义节点事件，emit来触发事件// 事件的定义eventTarget.on(self_event,(arg1, arg2)=)// 事件的触发eventTarget.emit(self_event, arg1, arg2)使用EventCustom自定义事件dispatchEvent触发事件// 参数1：事件名 参数2：是否冒泡let event = new cc.Event.EventCustom(self_event, true)// 给自定义事件添加detail属性，作为传递参数event.setUserData(hello)this.node.dispatchEvent(event) 事件系统Cocos提供几种事件系统：输入事件系统对象：systemEvent（旧版）| input（新版）监听对象为全局节点事件系统对象：EventTarget监听对象为Node同样也提供了一些内置事件：鼠标事件触摸事件event.getID 可以获取到触控的手指编码键盘事件键盘事件是游戏全局事件cc提供键盘编码全局变量： cc.macro.KEY设备重力传感事件全局与节点触摸和鼠标事件 API"},{"title":"Script 脚本","path":"/wiki/Cocos/creator_03_scripts.html","content":"官方脚本介绍 修改模版 点击右上角【编辑器】按钮，打开本地资源文件，进入Creator\\2.4.10\\resources\\static\\template文件夹中，修改初始化脚本文件：new-script.jsnew-script.ts 注释器decorator 双斜杠和单斜杠的区别一般来说：双斜杠是注释，一般给人看单斜杠是注解，一般给编译器看const ccclass, property = cc._decorator;// 使用@ccclass标注类@ccclassexport default class HelloWorld extends cc.Component // 使用@property标注属性 @property(cc.Label) label: cc.Label = null; 生命周期Life Cycle Callbacks 下面是按照执行顺序进行排序的生命周期钩子方法：onLoad组件被加载时调用onEnable当做键可用时执行start初始化时调用update(dt)dt表示帧间隔时间刷新每一帧时执行lateUpdate(dt)update执行完后马上执行onDisable组件不可用时执行onDestroy组件被销毁时调用 脚本的使用脚本使用官方文档常用API// 获取当前节点this.node// 获取节点子节点数组node.children// 通过名称获取子节点node.getChildByName(name)// 根据节点路径获取节点cc.find(parentNode/rootNode)// 获取父节点node.getParent()// 将当前节点设置为nodeA的子节点node.setParent(nodeA)// 移除节点的所有子节点node.removeAllChildren()// 移除节点的子节点nodeAnode.removeChild(nodeA)// 将节点移除出它的父节点node.removeFromParent()// 获取当前节点的组件this.getComponent(cc.Component)// 从当前节点的子节点中获取组件this.getComponentInChildren(cc.Component) 实际使用 暂停按钮退出游戏按钮玩家效果Pause按钮点击时显示菜单创建PauseButton的Node，在上面添加PauseButton脚本，并将菜单的Node和PauseButton的menu关联：const ccclass, property = cc._decorator;@ccclassexport default class PauseButton extends cc.Component @property(cc.Node) menu: cc.Node = null; isPause: boolean = false start () if(!this.menu) console.log(没有指定Menu节点) return; this.node.on(cc.Node.EventType.MOUSE_DOWN, () = this.isPause = !this.isPause if (this.isPause) // 执行暂停 this.menu.active = true // 直接获取子节点中的Label组件，并进行修改 this.getComponentInChildren(cc.Label).string = Continue else // 暂停解除 this.menu.active = false this.getComponentInChildren(cc.Label).string = Pause ) Quit按钮点击时退出游戏在Quit按钮上绑定DestroyBtn脚本，在按钮的MOUSE_DOWN事件被触发时，销毁游戏主界面：@ccclassexport default class DestroyBtn extends cc.Component @property(cc.Node) GameWindow: cc.Node = null @property(cc.Node) MainTitle: cc.Node = null isEnd: boolean = false start () if(!this.GameWindow || !this.MainTitle) console.log(没有指定游戏窗口或结束页面) return this.node.on(cc.Node.EventType.MOUSE_DOWN,()= if(!this.isEnd) // 将游戏主界面销毁 this.GameWindow.destroy() this.getComponent(cc.Button).interactable = false const back = this.MainTitle.children[0] back.height = 844; back.y = 0 const titleShadow = this.MainTitle.children[1] const titleInner = this.MainTitle.children[2] titleShadow.getComponent(cc.Label).string = Game Over titleInner.getComponent(cc.Label).string = Game Over titleShadow.y = titleInner.y = 500 this.isEnd = true ) 在update中更新Player位置@ccclassexport default class Player extends cc.Component @property speed: number = 5 @property rotateSpeed: number = 1000 update (dt) // 玩家向上移动 this.node.y += this.speed * dt; // 围绕玩家的特效 this.node.children[0].angle += this.rotateSpeed * dt; 获取和设置资源Asset Bundlecocos中，固定使用assets下resources文件夹作为动态加载资源文件夹，使用cc.resources获取到指定资源：cc.resources.load(img/target, cc.SpriteFrame,(error:Error, assets: cc.SpriteFrame) = // assets为获取到的资源) 定时器cocos提供了定时器方法：schedule( callback:function, interval:number, repeat:number, delay:number);callback 定时器回调带参数dt，表示间隔时间interval 间隔时间单位：秒repeat 执行次数delay 延迟时间单位：秒"},{"title":"Collision 碰撞检测","path":"/wiki/Cocos/creator_05_collision.html","content":"2D碰撞组件官方碰撞文档cocos中提供3种2D碰撞检测组件：Box Collider 方形盒检测器Circle Collider 圆形检测器Polygon Collider 多边形检测器检测器属性：Threshold 快速生成碰撞边界Editing 开启可编辑Tag 用于标记碰撞体类型Offset 碰撞体偏移Points 碰撞边界多边形顶点碰撞回调函数添加碰撞检测的组件，会多出3个碰撞回调函数：onCollisionEnter(other, self) 碰撞发生时触发onCollisionStay(other, self) 碰撞持续时触发onCollisionExit(other, self) 碰撞结束时触发回调函数的2个参数：other 碰撞到的另一个物体：cc.Colliderself 碰撞者自己：cc.Collider其它API要想让碰撞检测生效，必须执行下面代码，表示碰撞管理器启用cc.director.getCollisionManager().enabled = true;CollisionManager.enabledDebugDraw是否绘制碰撞边界线CollisionManager.enabledDrawBoundingBox是否绘制碰撞组件包围盒 碰撞检测实例 子弹击中敌人效果物体收集这里涉及到子弹Prefab的制作，制作好子弹的预设体之后，在发射子弹的主体Player的类中，添加新的可赋值属性：@property(cc.Prefab)bulletPre: cc.Prefab = null;监听全局的键盘事件，当空格被点击时，发送子弹：cc.instantiate 创建预设体const bullet = cc.instantiate(this.bulletPre)bullet.setPosition(this.node.position)bullet.setParent(this.node.getParent())为Enemy对象添加碰撞回调：onCollisionEnter(other: cc.Collider, self: cc.Collider) // 判断碰撞物是否是子弹类型 if(other.tag == 3 ) // 销毁子弹和自身 other.node.destroy() self.node.destroy() 需要判断Player和收集目标的碰撞：/* 碰撞发生时触发 */onCollisionEnter(other: cc.Collider, self: cc.Collider) :void this.isCollision = true switch(other.tag) // 碰撞到草莓 case 5: this.strawberry_value ++ this.strawberry_label.getComponent(cc.Label).string = this.strawberry_value.toString().padStart(2,0) other.node.destroy() break; // 碰撞到西瓜 case 6: this.melon_value ++ this.melon_label.getComponent(cc.Label).string = this.melon_value.toString().padStart(2,0) other.node.destroy() break; default:break;"},{"title":"向量 Vector","path":"/wiki/Cocos/creator_07_vector.html","content":"计算公式向量 向量指具有大小和方向的量在笛卡尔坐标系中，向量可以分散为沿x轴和y轴的两个分量，假设向量V方向和x轴正方向之间的夹角角度 a则V沿x轴和y轴的分量分别是：x = |V|cos(a)y = |V|sin(a)在js中提供了一些三角函数的方法，使用的基本都是弧度制，弧度制和角度制的公式关系如下：1° = Pi/180const radian = this.node.angle * Math.PI / 180 实现 这里要实现的功能是：俯视角角色跟随鼠标位置旋转鼠标右键控制子弹沿角色正前方发射出去子弹Bullet类玩家Player类每一帧的更新都要涉及到2个计算子弹Node的旋转角度转弧度计算子弹移动分量export default class NewClass extends cc.Component @property speed:number = 100 update (dt) // 角度制转弧度制 const radian = (this.node.angle + 90) * Math.PI / 180 // 计算分量 this.node.x += this.speed * dt * Math.cos(radian) this.node.y += this.speed * dt * Math.sin(radian) 首先实现玩家跟随鼠标旋转：监听鼠标移动事件，记录鼠标点位每帧对玩家Node的angle进行更新export default class Player extends cc.Component mousePosition = [] start() cc.find(scene).on(cc.Node.EventType.MOUSE_MOVE, (event:cc.Event.EventMouse)= // 记录当前鼠标点位 this.mousePosition = [event.getLocationX(),event.getLocationY()] ) update (dt) let dx = this.mousePosition[0] - this.node.x let dy = this.mousePosition[1] - this.node.y // 计算旋转角度 let radian = - Math.atan(dx/dy) let angle = radian * 180 / Math.PI if((dx 0 dy0) || (dx0 dy 0)) angle += 180 this.node.angle = angle 实现子弹超前发射：监听鼠标点击事件创建子弹节点初始化子弹角度界面加入子弹 cc.find(scene).on(cc.Node.EventType.MOUSE_UP, (event:cc.Event.EventMouse)= // console.log(event) let type = event.getButton() switch(type) case 0: // 移动 this.targetPosition = [event.getLocationX(),event.getLocationY()] break; case 2: // 发射子弹 // load用于控制子弹间隔时间 if(this.load) return // 散弹：一发3枚子弹 for(let i = 0;i3;i++) let bullet = cc.instantiate(this.bulletPre) // 计算子弹角度 bullet.angle = this.node.angle + (1 - i) * 10 // 注意：这里的BulletPosition是Player下的一个子空节点 // 表示子弹发出的位置 // 将子弹坐标系放置在全局坐标系下 bullet.setPosition(this.node.getChildByName(BulletPosition).convertToWorldSpaceAR(cc.Vec2.ZERO)) //根组件加入子弹 bullet.setParent(cc.director.getScene()) // 添加音效 cc.find(Canvas/Sound).getComponent(cc.AudioSource).play() // 间隔控制 this.load = true setTimeout(()= this.load = false ,this.loadTime * 1000) break; )"},{"title":"Resources 图片与音频资源","path":"/wiki/Cocos/creator_06_resources.html","content":"resources 资源管理Asset Manager概述cocos中默认resources文件夹为动态加载资源的文件夹，使用cc.resources.load方法可以动态获取到资源// url：相对于resources的url路径// type：资源类型resources.load(url, type, (err, asset)=)动态加载SpriteAtlas资源：// 动态加载cc.SpriteAtlas资源cc.resources.load(imgs/character/PinkMan/pinkman_idle,cc.SpriteAtlas,(error: Error, assets: cc.SpriteAtlas) = this.idle_atlas = assets // 定时器控制逐帧播放 setInterval(()= this.node.getComponent(cc.Sprite).spriteFrame = this.idle_atlas.getSpriteFrame(this.cur_idle_atlas_index.toString()) this.cur_idle_atlas_index += 1 this.cur_idle_atlas_index %= this.idle_atlas.getSpriteFrames().length ,this.idle_speed)) AudioSourceAudioSource AudioSouce组件参考Cocos音频资源参考AudioSource是Cocos中用于控制音频的组件，cc.AudioSource组件中提供一些API，用于音频的基本控制：play() 从头开始播放stop() 结束播放pause() 暂停播放resume() 从上次暂停处继续开始isPlaying 是否在播放全局音频全局音频管理器cocos2.x版本提供cc.audioEngine，进行全局音频控制，其中提供多个声道：playMusic 背景音乐playEffect 音效play 音频cc.audioEngine在3.x版本中弃用，官方推荐使用cc.AudioSource封装全局音频控制器下面这段视频需要打开声音： 加入玩家飞机 鼠标控制位置 进行边界检测 制作子弹预设件 子弹前进 出界删除 添加碰撞 玩家发射子弹 定时器 预加载子弹音效 创建玩家碰撞盒 创建敌机预设件 创建碰撞组件 敌机脚本 初始化位置（随机） 向下移动 边际检测 被击中播放音效，播放死亡动画，销毁子弹 碰撞玩家扣血死亡 结算画面 结算音乐"},{"title":"UI 组件","path":"/wiki/Cocos/creator_08_UI.html","content":"官方文档3.8官方文档2.4 常用UI组件 关于组件事件的绑定面板中的事件绑定可以指定任意目标组件上的指定脚本类的指定方法，还可以指定参数，一般制定方法的第一个参数都是event参数，第二个参数则为指定参数Label文字标签组件RichText富文本组件string属性使用的是一种类似HTML的BBCode标签语言富文本：color=#ffaa00Click Link ↓/coloron click=getPunishment param=YES!!!!uiwww.cantlivewithoutsm.com/i/u/onimg src=0/Button 按钮按钮存在几种状态：NormalPressedHoverDisabledDurationLayout 布局三种布局方式：HORIZONTALVERTICALGRIDEditBox 文本输入框支持对背景、placehold label、文本label进行自定义支持一些事件的绑定：Editing Did BeganText ChangedEditing Did EndedEditing ReturnMask 遮罩根据Node的size确定组件有效的范围滚动容器 ScrollView支持横向、纵向滚动条支持对滚动惯性和弹性惯性进行设置scrollEvent有三个参数：ScrollView本身ScrollView事件类型CustomEventData进度条 ProgressBar滑动条 Slider支持对滑动轨迹和把手进行自定义样式可以监听Slide事件复选框 Toggle和button一样，transition支持几种类型：SPRITE 贴图COLOR 纯色SCALE 缩放动画单选框 ToggleContainer单选项为Toggle组件画布 Canvas播放器 VideoPlayer支持local、remote加载视频网页视图 WebView常用于页游中登录界面"},{"title":"场景管理及动态加载","path":"/wiki/Cocos/creator_09_Scene.html","content":"切换场景场景切换 cocos中场景文件的后缀是firecc.director.loadScene( sceneName:string, onLaunched:function )参数：sceneName 要加载的场景名称onLaunched 回调函数loadScene调用后进行如下操作：加载新场景销毁当前场景切换新场景 预加载场景预加载场景 当游戏场景比较大时，直接进行场景加载和切换，加载时游戏可能会卡住一段时间，影响游玩体验，所以需要对较大的场景进行预加载，预加载的时机可以选在玩家移动到某一范围内时，对其可能触发切换的场景进行预加载，cocos中，使用preLoadScene进行场景预加载，加载后需要手动进行切换：cc.director.preLoadScene( sceneName:string, onProgress:function, onLoaded:function)参数：sceneName 目标场景名称onProgress 加载进度发生改变的回调函数，可以在这里操作场景预加载的进度条参数1：completedCount:number 已经加载的资源个数参数2：totalCount:number 场景总资源个数参数3：item:any 流出加载管道的最新项目onLoad 加载完成的回调函数唯一参数： error:Error 加载出错时的信息 常驻节点常驻节点 cocos中scene的切换会摧毁旧场景中的所有节点，不会保存旧场景中的任何数据，实际上，有些数据是需要在多个场景之间常驻存在，这些数据一般都由一个数据存储组件进行保留，这种组件一般称为“常驻节点”，常驻节点在场景切换时不会被自动销毁。常驻节点的操作使用到下面2个API：cc.game.addPresistRootNode(node) 添加常驻节点cc.game.removePresistRootNode(node)清理常驻节点属性清理之后几点依旧会存在于当前的场景中"},{"title":"Particle 粒子系统","path":"/wiki/Cocos/creator_12_Particle.html","content":"粒子系统 ParticleParticle ParticleSystem文档ParticleSystem属性Preview 编辑器内选中粒子是否自动播放PlayOnLoad 自动发射粒子AutoRemoveOnFinish 自动销毁粒子节点File 粒子配置文件Custom 自定义粒子属性，详情见文档粒子系统的效果需要进行实时计算，因此在移动设备上运行时可能出现消耗资源的问题，在使用前可以和Animation、Atlas等方法放在一起比较一下"},{"title":"Animation 动画系统 && Action 动作系统","path":"/wiki/Cocos/creator_11_Animation.html","content":"动画系统Animation 动画系统动画一般分为2种：关键帧动画自动计算2帧之间的中间数值序列帧动画每帧都有不同的SpriteFrame快速翻动帧，产生帧动画AnimationClip要控制某个节点的动画，需要为组件添加Animation动画控制器组件，Animation组件中需要添加AnimationClip作为操作动画的源文件，AnimationClip文件需要再动画编辑器中进行编辑：按帧修改动画节点的属性，作为关键帧。 AnimationClip编辑器 包含以下属性：取样率 Sample影响可设置帧的最小精度单位播放速度 Speed循环模式 WrapMode可以设置循环播放、正放倒放交替等等模式时间曲线双击编辑动画速率函数帧事件支持添加帧事件，事件名和参数都可定制会从添加到组件中的脚本内找到与定义的帧事件同名的方法脚本控制动画播放脚本控制动画文档播放动画 play可选参数1：动画名可选参数2：开始时间anim.play(test, 1) 暂停 pause恢复 resume停止 stop设置动画的当前时间 setCurrentTime动画事件回调play 开始动画stop 停止动画pause 暂停动画resume 恢复动画lastframe 存在循环的动画播放到最后一帧时finished 动画播放结束事件回调的配置：var animation = this.node.getComponent(cc.Animation);// 注册animation.on(play, this.onPlay, this);animation.on(stop, this.onStop, this);animation.on(lastframe, this.onLastFrame, this);animation.on(finished, this.onFinished, this);animation.on(pause, this.onPause, this);animation.on(resume, this.onResume, this);// 取消注册animation.off(play, this.onPlay, this);animation.off(stop, this.onStop, this);animation.off(lastframe, this.onLastFrame, this);animation.off(finished, this.onFinished, this);animation.off(pause, this.onPause, this);animation.off(resume, this.onResume, this); 动作系统Action 动作系统官方文档cc.Node存在以下支持进行动作的API：runAction 执行动作参数action：cc.Action，指定执行的动作stopAction 停止指定动作参数action：cc.Action，指定执行的动作stopAllActions 停止所有动作cc.Action动作类型可以通过设置tag来完成setgetrunstop等一系列操作：action.setTag(0)this.node.getActionByTag(0)this.node.stopActionByTag(0) Action API Action APIcocos中动作系统主要分为以下几类容器动作用于组织单个或多个动作的执行顺序、次数、速度即时动作无关执行时间、瞬间实现的动作时间间隔动作基础动作从开始执行到结束执行之间，存在一系列中间值计算的动作缓动动作时间间隔动作的附属属性，操作一系列中间值与时间变化的方式容器动作即时动作基础动作缓动动作sequence 顺序执行动作let seq1 = cc.sequence(act1, act2)let seq2 = cc.sequence(actArray)repeat 重复指定次数的某个动作let rep = cc.repeat(cc.sequence(jump2, jump1), 5)repeatForever 永远重复一个动作let repeat = cc.repeatForever(act)spawn 并行执行多个任务let action = cc.spawn( cc.jumpBy(2, cc.v2(300, 0), 50, 4), cc.rotateBy(2, 720))speed 速率let action = cc.scaleTo(0.2, 1, 0.6)let newAction = cc.speed(action, 0.5)show 立即显示let action = cc.show()hide 立即隐藏let action = cc.hide()toggleVisibility 显隐状态切换var action = cc.toggleVisibility();removeSelf 从父节点移除自身var action = cc.removeSelf()flipX X轴翻转var action = cc.flipX(true)flipY Y轴翻转var action = cc.flipY(true)place 放置在目标位置let action = cc.place(cc.v2(200, 200))callFunc 执行回调函数// 参数1：回调函数// 参数2：回调目标// 参数3：传递参数var finish = cc.callFunc(this.callbackFunc, this.target, true);moveTo 移动到目标位置moveBy 移动指定的距离rotateTo 旋转到目标角度rotateBy 旋转指定的角度scaleTo 缩放到指定倍数scaleBy 按指定倍数缩放节点skewTo 偏移到目标角度skewBy 偏移指定的角度jumpBy 跳跃指定距离jumpTo 用跳跃的方式移动到目标位置follow 追踪目标节点位置bezierTo 按照贝塞尔曲线轨迹移动到目标位置bezierBy 按照贝塞尔曲线轨迹移动指定距离blink 闪烁（基于透明度）fadeTo 渐隐（给予透明度）fadeIn 渐显fadeOut 渐隐tintTo 修改颜色到指定值tintBy 按照制定增量修改颜色delayTime 延迟指定的时间量reverseTime 反转目标动作时间轴运动函数，详情参考 官方文档cocos的文档里竟然还有知乎页面的引用跳转到的知乎页面还都是吐槽cocos文档的评论，双向奔赴了这属于…2.4版本后，引入的缓动系统，使用cc.Tween代替了cc.Action动作系统，cc.Tween采用的是链式创建，比cc.Action要简洁得多"},{"title":"物理系统","path":"/wiki/Cocos/creator_10_Physical.html","content":"2D物理系统2D物理系统 2D物理系统官方文档（2.4版本）2.4版本cocos中需要手动开启物理引擎（需要在onLoad方法内执行）：cc.director.getPhysicsManager().enabled = true想要开启一个节点的物理系统，需要给这个节点添加两个组件：RigidBody 刚体组件Collider 碰撞组件 RigidBody 刚体RigidBody 物理属性刚体方法Enabled Contact Listener开启物理碰撞检测Bullet防止高速移动的物体穿过墙面或地面等刚体Type几种刚体类型static 静态刚体kinematic 不受外力Dynamic 动态刚体Animated 设置线速度和角速度驱动的刚体Allow Sleep允许刚体静止不动时进入睡眠状态，降低CPU占用率Gravity Scale重力倍数，1为1倍重力Linear Damping线性速度衰减系数Angular Damping角速度衰减系数Linear Velocity线性初速度Angular Velocity角初速度Fixed Rotation禁止物体旋转Awake OnLoad 是否在初始化时唤醒此刚体将AwakeOnLoad设置为false，在代码中可以通过修改刚体组件的awake为true，来开启刚体：this.getComponent(cc.RigidBody).awake = true刚体方法文档给刚体施加力参数1：force 在x、y轴上的大小分量参数2：point 作用点参数3：wake 是否唤醒刚体rb.applyForce(force:cc.Vec2, point:cc.Vec2, wake:boolean)施加力到刚体的质心上参数1：force 在x、y轴上的大小分量参数2：wake 是否唤醒刚体rb.applyForceToCenter(force:cc.Vec2, wake:boolean)施加扭力参数1：torque 扭力大小参数2：wake 是否唤醒rb.applyTorque(torque:number, wake:boolean)施加冲量参数1：impulse 冲量在x、y轴上的大小分量参数2：point 作用点参数3：wake 是否唤醒rb.applyLinearImpulse(impulse:cc.Vec2, point:cc.Vec2, wake:boolean)施加角速度冲量参数1：impulse 角速度冲量大小参数2：wake 是否唤醒rb.applyAngularImpulse(impulse:number, wake:boolean) 力与冲量 cocos中主要有两种方式移动一个物体：力 Force物体本身移动的内力力会随时间修改物体的坐标和旋转角度添加物体内在力的API：applyForceapplyForceToCenterapplyTorque冲量 Impulse从外界推动物体的外力冲量会立刻改变物体的坐标或旋转角度冲量（如线性初速度、角初速度），会根据衰减系数而逐渐减弱，直到物体的变化完全停止添加物体外力的API：applyLinearImpulseapplyAngularImpulse Collider 物理碰撞体碰撞组件 RigidBody必须在组件上存在Collider碰撞体的情况下才能生效，Collider碰撞组件具有以下的基础属性：Density 密度Sensor 是否是传感器类型设置了传感器的碰撞物本身不会产生碰撞效果，但是可以监听到碰撞事件常用场景：某个特殊点监听到玩家的碰撞之后，触发事件（场景跳转交互效果）Friction 摩擦系数Restitution 弹性系数Tag和collider属性一样，tag用于在碰撞回调中识别碰撞体的类型碰撞回调碰撞回调官方文档想要触发碰撞体的碰撞回调，需要开启碰撞体RigidBody的Enabled Contact Listener属性，碰撞回调函数中有3个参数：contact 碰撞信息self 碰撞物自己other 另一个碰撞物// 开始碰撞onBeginContact(contact:cc.PhysicsContact, self:cc.PhysicsCollider, other:cc.PhysicsCollider)// 结束碰撞onEndContact(contact:cc.PhysicsContact, self:cc.PhysicsCollider, other:cc.PhysicsCollider)// 每次处理碰撞体接触逻辑前调用onPreSolve(contact:cc.PhysicsContact, self:cc.PhysicsCollider, other:cc.PhysicsCollider)// 每次处理完成碰撞体接触逻辑后调用onPostSolve(contact:cc.PhysicsContact, self:cc.PhysicsCollider, other:cc.PhysicsCollider)关于cc.PhysicsContact类型，可以获取到以下碰撞信息：参数方法colliderA 碰撞体AcolliderB 碰撞体Bdisabled 禁用disabledOnce 在当前时间步（dt）中忽略此接触信息getWorldMainfold() 获取世界坐标系下的碰撞信息获取到的碰撞信息具有以下成员：points 碰撞点数组，常见有1-2个碰撞点normal 碰撞点上的法向量，由自身碰撞体指向对方碰撞体getMainfold() 获取局部坐标系下的碰撞信息getImpulse() 获取冲量信息在onPostSolve回调中可以获取到，返回值包含2个参数：normalImpulses 向量冲量tangentImpulse 切线冲量getFrictionsetFrictionresetFriction() 获取设置重置摩擦力系数getRestitutionsetRestitutionresetRestitution() 获取设置重置弹性系数isTouching() 碰撞体是否已经解除 物理检测物理系统管理器 物理系统官方文档cocos中有3种物理检测的方法：点检测矩形检测射线检测点检测检测某个指定点位是否存在碰撞体，如果存在多个碰撞体，只会返回一个随机结果，只能用于测试dynamic刚体let pysicsCollider = cc.director.getPhysicsManager().testPoint(point)矩形检测矩形检测需要指定一个世界坐标系下的矩形，如果一个碰撞体的包围盒与矩阵存在重叠部分，会返回该碰撞体同样只能检测dynamic类型的碰撞体：let rect = cc.rect(0, 0, 300, 300)let colliders = cc.director.getPhysicsManager().testAABB(rect)射线检测射线检测根据指定的线段，来判断线段穿过的碰撞体，返回线段在穿过碰撞体的法向量、点位以及其它一些信息用法：let p1 = cc.v2(0, 200)let p2 = cc.v2(175, 300)let type = cc.RayCastType.Closestlet results = cc.director.directorgetPhysicsManager().rayCast(p1, p2, type)参数说明：p1 线段起点p2 线段终点type 射线类型，在cc.RayCastType中定义，包括以下4种All：检测射线路径上的所有碰撞体，检测到的结果顺序不是固定的AllClosest： 返回射线路径上的所有碰撞体，但是会对返回值进行筛选，只返回每个碰撞体与射线接触的第一个点Any：官方解释：检测射线路径上任意，一旦检测到任何碰撞体，立即结束检测实际使用：返回的是最远的碰撞体Closest：检测射线路径上最近的碰撞体，默认值 物理检测实现自动寻路 实现代码：@ccclassexport default class AutoFindWay extends cc.Component // 物理管理器 manager = null // 刚体 rb:cc.RigidBody = null // 方向顺序， 默认向上走 dir = [1,0] // 速度 speed = 50000 onLoad() this.manager = cc.director.getPhysicsManager() this.manager.enabled = true // 开启物理管理器 start () this.rb = this.getComponent(cc.RigidBody) testRaycast(dt) // 开始点 let startPoint = this.node.getPosition() // 结束点 let endPoint // 探测长度 let len = 100 if(this.dir[0] != 0) // 沿x轴前进 let points = this.manager.rayCast( startPoint, cc.v2(startPoint.x + len * this.dir[0], startPoint.y), cc.RayCastType.Closest) // x轴移动受阻，开始检测上下方向是否可行（排除碰撞物为重点的可能性） if(points.length0 points[0].collider.tag != 1) let hasChange = false let allDir = [-1,1] // 随机选择先上还是先下 if(Math.random() 0.5) allDir.reverse() for(let i of allDir) let points = this.manager.rayCast( startPoint, cc.v2(startPoint.x, startPoint.y + len * i), cc.RayCastType.Closest) if(points.length == 0) this.dir = [0, i] hasChange = true break; // 当前方向不可行，上下方向也不可行，此时回头 if(!hasChange) this.dir[0] *= -1 else if(this.dir[1] != 0) // 沿y轴前进 let points = this.manager.rayCast( startPoint, cc.v2(startPoint.x , startPoint.y + len * this.dir[1]), cc.RayCastType.Closest) // 检测到点的存在，开始检测左右方向 if(points.length0 points[0].collider.tag != 1) let hasChange = false let allDir = [-1,1] if(Math.random() 0.5) allDir.reverse() for(let i of allDir) let points = this.manager.rayCast( startPoint, cc.v2(startPoint.x + len * i, startPoint.y ), cc.RayCastType.Closest) if(points.length == 0) this.dir = [i, 0] hasChange = true break; // 未改变 if(!hasChange) this.dir[1] *= -1 // 添加线性速度 this.rb.linearVelocity = new cc.Vec2( this.speed * dt * this.dir[0], this.speed * dt * this.dir[1] ) update (dt) this.testRaycast(dt)"},{"title":"Element-Scrolls 元素卷轴","path":"/wiki/Cocos/creator_14_Deploy.html","content":"版本控制 一定要用git进行版本控制啊做了一天的素材因为编辑器卡死，场景全丢失（怒啊啊啊啊），没法通过BackupAssets找回来了wocao 游戏简介游戏介绍 屏幕分辨率：375 * 667操作方式：鼠标点击屏幕触控游戏类型：弹幕玩法传统玩法的弹幕游戏，敌人从屏幕上方袭来，不要让它们冲破防线， 并躲避它们的子弹，有4种可收集物品：金币：可以用来购买更加强力的子弹爱心：增加生命蓝色药水：加快射击速度饭团：进入持续5秒的散射时间一共有4种子弹：能量弹：初始子弹火焰弹：威力加强岩石弹：威力强，射速慢叶旋风：威力弱，射速快总共有5个关卡，每个关卡都有独特的敌人 游戏体验体验地址 开始游戏界面 关于游戏界面 游戏设置界面 弹幕射击界面 切换子弹 子弹商店 多重关卡 多重射击 游戏胜利 游戏结束 开发过程场景搭建背景采取2张背景图叠加循环滚动的方式：场景拼接滚动export default class BackScene extends cc.Component scrollHeight:number = 0 @property scrollSpeed:number = 100 onLoad() this.scrollHeight = cc.view.getVisibleSize().height update(dt) this.backMove(dt) backMove(dt) this.node.y -= this.scrollSpeed * dt if(this.node.y = - this.scrollHeight) this.node.y = 0 return 敌我脚本敌人和玩家具有2个最基本的机制：移动发射子弹玩家脚本移动使用TOUCH监控，这样能兼容到PC和移动端：export default class Player extends cc.Component /** 移动速度 */ @property moveSpeed: number = 100; /** 移动延迟 */ @property moveDuration: number = 8; /** 目标坐标 */ targetPosition = x: 0, y: 0, ; /** 可移动的最大y值 */ maxY:number = 0 /** 可移动的x值范围 */ minX:number = 0 maxX:number = 0; isMoving: boolean = false; start() // 初始化目标位置 this.targetPosition.x = this.node.x; this.targetPosition.y = this.node.y; // 计算可移动的范围 this.maxY = this.node.getParent().height - cc.find(CompPath.TitleMenu).height - this.node.height let xPad = 15 this.minX = xPad + this.node.width/2 this.maxX = this.node.getParent().width + xPad - this.node.width // 绑定移动事件 this.moveByTouch() moveByTouch() const touchWindow = cc.find(CompPath.MainGameWindow) const titleMenu = cc.find(CompPath.TitleMenu) const maxY = titleMenu.y - titleMenu.height touchWindow.on(cc.Node.EventType.TOUCH_START,(event:cc.Event.EventTouch)= if(globalVar.gamePause) return this.isMoving = true ) touchWindow.on(cc.Node.EventType.TOUCH_END,(event:cc.Event.EventTouch)= if(globalVar.gamePause) return this.isMoving = false ) touchWindow.on(cc.Node.EventType.TOUCH_CANCEL,(event:cc.Event.EventTouch)= if(globalVar.gamePause) return this.isMoving = false ) touchWindow.on(cc.Node.EventType.TOUCH_MOVE,(event:cc.Event.EventTouch)= if(globalVar.gamePause) return if(this.isMoving) let ex = event.getLocationX(), ey = event.getLocationY() if(ey - touchWindow.y =0 || ey = maxY) return else if(ex = this.minX || ex = (this.maxX + 15)) return // 修改移动点位置 this.targetPosition.x = ex - 15 this.targetPosition.y =ey - touchWindow.y ) update(dt) // 缓动 this.node.x += (this.targetPosition.x - this.node.x) / this.moveDuration; this.node.y += (this.targetPosition.y - this.node.y) / this.moveDuration; 至于发射子弹，一开始是打算由玩家操控子弹射击，但由于移动端操作的界面比较小，如果要操控射击，就需要单独设计操控面板，考虑到只是个边学边做的小游戏，就没设计这个（其实就是懒）后来发现让主角跟随触碰点移动，会让角色完全被手指盖住（悲）这下理解为什么手机游戏基本都是用摇杆或者指击控制角色移动了。敌人的移动方向只有前方，并且定时设计，脚本和玩家类似 物品捡拾一共设计了4种可捡拾物品：金币爱心加速射击药水散射饭团捡拾物品 换弹系统金币用于购买不同的卷轴，不同的子弹具有不同的伤害和射速：切换卷轴 粒子动画ParticleSystem 游戏胜利效果 游戏开始效果 游戏通关效果 添加音效"},{"title":"Storage 存储数据","path":"/wiki/Cocos/creator_13_LocalData.html","content":"LocalStorage 本地存储localStorage cc.sys.localStorage，是对Web LocalStorage的封装，因此只有在h5页游上可以调用localStorage API数据存储文档setItem 存储数据参数1：key 键名参数2：value 键值getItem 读取数据参数1：key 键值removeItem 移除键值对参数1：key 键名clear 清空数据"},{"title":"Socket 实时通信","path":"/wiki/Cocos/creator_15_Socket.html","content":"SocketSocket概念 Web网络请求一般常用的就是Http和WebSocket，在游戏中，常用Http请求向服务器传递获取一些无需实时更新的数据：加载游戏数据资源（玩家等级、装备、技能等信息）向服务器上传数据（分数、游戏进度、玩家当前位置…）Socket一般用于需要实时更新的一些数据，进行Socket连接一般需要3个步骤：服务器启动监听服务器端server socket，对指定端口号进行监听客户端请求连接客户端client socket，对指定的ip和端口号发送连接请求如果目标ip和端口号是服务器端对应的，则进连接继续服务器连接确认响应客户端请求，建立TCPIP通道联网游戏一般分为2种：局域网对战游戏网络游戏局域网对战游戏方式1：玩家充当局域网通信服务器一般为局域网中，其中一个玩家的主机充当服务器（房主），其他玩家通过房主进行数据共享（位置、血量等数据），此时的房主类似于路由器的功能。房主通过UDP协议向局域网内所有地址广播自己的IP地址和服务端口（公示自己的房间号），并专门建立一个端口，用于监听玩家的进入（房门端口），一旦有人与此端口建立起联系（监听到有玩家进入房门），就立刻为该玩家分配一个专项端口，并建立连接（给新用户分配一个专享通道），并关闭玩家与房门端口的连接，这样由玩家的主机充当通信服务器的局域网方式，一般都会对玩家数量进行限制，方式2：虚拟IP常见网络在线对战平台，为玩家分发虚拟IP，从而达到将广域网IP映射到局域网的目的网络游戏不需要玩家来充当通信服务器，而是由运营方提供专门的通信服务器，可以是这种结构：Web服务器：收发Http请求Socket通信服务器：专注于收发与转发数据，建立玩家间Socket连接数据存储服务器：用于存储玩家数据 Socket实例 服务器端客户端express-ws参考博客启用express框架ws无效参考博客服务器框架：express安装express-ws：npm i express-ws添加ws映射路由，创建websocket.js：var express = require(express)var expressWs = require(express-ws)var router = express.Router()expressWs(router)router.ws(/user, (ws, req)= console.log(收到连接请求) ws.send(来自服务器端推送的消息) ws.on(message,(msg)= // 业务代码 ws.send(`服务器端收到消息：$msg`) ) let timer = setInterval(()= ws.send(`服务器端定时推送消息：$new Date().getTime()ms`) , 1000) ws.on(close, e = clearInterval(timer) timer = null clients = clients.filter(client = client !== ws) ))module.exports = router;修改app.jsvar express = require(express);var expressWs = require(express-ws);var app = express();expressWs(app) // 注入wsvar webSocketRouter = require(./routes/websocket);// 映射链接app.use(/ws_api, webSocketRouter);process.env.PORT = 8201module.exports = app;如果是使用的express脚手架搭建的项目，需要在binwww中加入修改：var app = require(../app);var http = require(http);var server = http.createServer(app);// 注入var expressWs = require(express-ws)(app, server)客户端新建websocket连接：export default class WSConnect extends cc.Component start () let socket = new WebSocket(ws://127.0.0.1:8201/ws_api/user) socket.onopen = ()= console.log(与服务器端建立连接) socket.onmessage = (msg)= console.log(msg) socket.onclose = ()= console.log(CLOSE：与服务器连接断开) 常用readyState状态码：0CONNECTING正在建立连接，连接没有建立完成1OPEN连接已经建立完成，并且可以进行通信2CLOSING连接正在关闭3CLOSED连接已经关闭或不可用websocket实现广播// 存放当前所有连接let clients = []router.ws(/user,(ws, req)= clients.push(ws) ws.on(message,(msg)= broadcast(广播数据) ))function broadcast(data) clients.forEach(client = if(client.readyState === client.OPEN) client.send(data) )"},{"title":"🫀生命游戏","path":"/wiki/Cocos/game_02_LifeGame.html","content":"资源地址 Conway Life Game视频教程：阿信OLlife game demogithub源码 📖规则说明规则说明 格子代表细胞生命，生死规则如下：一个细胞周围一共有8个细胞如果一个细胞周围有3个细胞，则生（死则转生）一个细胞周围有2个细胞，状态不变其他情况，细胞为死 1️⃣步骤一：实现网格 实现思路 创建网格容器cellArea创建单个网格预制件cell双层方格，模拟边框在cellArea上，使用程序生成cell网格给预制件cell添加记录和修改状态的脚本给cellArea添加Touch事件，监听点击到的细胞网格 程序生成网格 网格容器cellArea尺寸：8000 * 600单个网格预制件cell尺寸：10 * 10@ccclassexport default class Game extends cc.Component // 游戏暂停 pause: boolean = true // 容器 @property(cc.Node) cellArea: cc.Node = null // 细胞预制件 @property(cc.Prefab) cellPre: cc.Prefab = null // 细胞尺寸 cellSize: number = 10 // 横载数量 cellW_Num: number = 0 // 列载数量 cellH_Num: number = 0 // 存放细胞节点 cells: Arraycc.Node[] = [] onLoad () this.cellW_Num = this.cellArea.width / this.cellSize // 800/10=80 this.cellH_Num = this.cellArea.height / this.cellSize // 600/10=60 for(let i = 0; i this.cellW_Num;i++) this.cells[i] = new Array() // 初始化细胞矩阵 start () this.layout() // 布置细胞 layout() for(let i = 0 ; i this.cellW_Num; i++) for(let j = 0; j this.cellH_Num; j++) let newCell = cc.instantiate(this.cellPre) newCell.x = i * this.cellSize newCell.y = j * this.cellSize newCell.setParent(this.cellArea) this.cells[i][j] = newCell 细胞状态脚本Cell 单个细胞中，只有一个信息：是否存活？所以在cell脚本中，需要实现如下功能：记录cell的state修改state，根据修改后的state修改cell的颜色暴露出一个切换state的接口@ccclassexport default class Cell extends cc.Component @property(cc.Node) cellItem:cc.Node = null // 0=存活 1=死亡 state:number = 0 setState(state = 0) this.state = state switch(this.state) case 0 : this.cellItem.color = new cc.Color(255,255,255); break; case 1 : this.cellItem.color = new cc.Color(0,0,0); break; switchState() this.setState([1,0][this.state]) 网格交互 鼠标点击网格时，可以切换细胞的存活状态，对cellArea进行鼠标点击事件监听：获取鼠标事件的世界坐标将世界坐标转换为cellArea下的局部坐标根据局部坐标，结合cell尺寸，计算当前鼠标事件触发的cell的索引坐标找到cell，切换状态@ccclassexport default class Game extends cc.Component //... start () // ... this.cellArea.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this) onTouchStart(e:cc.Event.EventTouch) let pos = e.getLocation() let n_pos = this.cellArea.convertToNodeSpaceAR(pos) let i = Math.floor(n_pos.x / this.cellSize) let j = Math.floor(n_pos.y / this.cellSize) let cell = this.cells[i][j] // 切换细胞网格状态 cell.getComponent(Cell).switchState() 2️⃣步骤二：实现细胞活动模拟繁衍速度控制 在update中累加帧间隔时间，每过0.1秒，刷新一次：@ccclassexport default class Game extends cc.Component // 游戏暂停 pause:boolean = true // 计时器 timeStep:number = 0 update (dt) if(this.pause) return this.timeStep += dt if(this.timeStep = 0.1) this.timeStep = 0; this.lifeChange() // 生命繁衍 lifeChange() //... 实现细胞繁衍死亡 实现思路：记录细胞矩阵cells当前状态快照nowStateList取出每一个cell，根据其八个方位的细胞判断其是否有必要改变生命状态记录快照，判断八方结果是否有必要改变生命状态：@ccclassexport default class Game extends cc.Component // 生命繁衍 lifeChange() let nowStateList = [] // 记录状态快照 for(let i = 0; i this.cellW_Num; i++) nowStateList[i] = [] for(let j = 0; j this.cellH_Num; j++) let state = this.cells[i][j].getComponent(Cell).state nowStateList[i][j] = state // 根据判断是否需要切换细胞状态 for(let i = 0;ithis.cellW_Num;i++) for(let j = 0; j this.cellH_Num; j++) let state = this.getCellNextState(nowStateList, x:i, y:j) if(state) this.cells[i][j].getComponent(Cell).switchState() 判断是否有必要改变细胞状态：@ccclassexport default class Game extends cc.Component // 计算在（x，y）坐标处，状态为nowState的细胞的下一步状态 getCellNextState(nowStateList, x, y) let nowState = nowStateList[x][y] let nearCount = 0 // 八个方位的偏移量 let grids = [ dx:1, dy:-1, dx:1, dy:0, dx:1, dy:1, dx:0, dy:-1, dx:0, dy:1, dx:-1, dy:-1, dx:-1, dy:0, dx:-1, dy:1, ] for(let grid of grids) let tx = x + grid.dx; if(tx = this.cellW_Num) tx = 0 if(tx = -1) tx = this.cellW_Num - 1 let ty = y + grid.dy; if(ty = this.cellH_Num) ty = 0 if(ty = -1) ty = this.cellH_Num - 1 let targetState = nowStateList[tx][ty] if(targetState == 1) nearCount += 1 // 2个活细胞，不变[nginx.conf](..%2F..%2F..%2F..%2F..%2F..%2F..%2FOneDrive%2F%D7%C0%C3%E6%2Fnginx.conf) if(nearCount == 2) return false // 3个活细胞，（死转）生 if(nearCount == 3) if(nowState == 0) return true if(nowState == 1) return false // 原先为生，死去 if(nowState == 1) return true // 不变 return false"},{"title":"🔪飞刀游戏","path":"/wiki/Cocos/game_03_KnifeGame.html","content":"资源地址 视频教程：阿信OLKnife Game Demogithub源码 📖规则说明规则说明 找到时机向木桩投出飞刀，注意：不能插在已经击中的位置 💻代码实现实现代码 @ccclassexport default class Game extends cc.Component // 木桩（投掷目标）节点 @property(cc.Node) targetNode:cc.Node = null // 小刀（投掷物示意）节点 @property(cc.Node) knifeNode:cc.Node = null //小刀预制件 @property(cc.Prefab) knifePrefab:cc.Prefab = null // 已投出的小刀列表 knifeList:cc.Node[] = [] // 当前是否可以投掷 canThrow:boolean = true // 旋转速度 rotateSpeed:number = 150 // 旋转半径（木桩半径） rotateRadius:number = 0 onLoad () // 点击屏幕，触发丢出飞刀事件 this.node.on(cc.Node.EventType.TOUCH_START, this.throwKnife, this) this.rotateRadius = this.targetNode.width / 2 onDestroy(): void // 销毁飞刀事件 this.node.off(cc.Node.EventType.TOUCH_START, this.throwKnife, this) // 每隔2s进行变速 changeSpeed() let dir = Math.random() 0.5? 1: -1 let speedNum = Math.max(200, Math.abs(this.rotateSpeed) + 150 * (Math.random() - 0.5)) if(speedNum 200) speedNum -= Math.random() * 150 this.rotateSpeed = dir * speedNum // 丢出飞刀 throwKnife() if(this.canThrow) this.canThrow = false this.targetNode.zIndex = 1 let action = cc.sequence( // 垂直飞到木桩的圆周上 cc.moveTo(0.15, new cc.Vec2(this.knifeNode.x, this.targetNode.y - this.targetNode.height / 2)), cc.callFunc(()= // 判定是否和已经插在上面的飞刀碰撞：遍历knifeList，判断是否有旋转角小于gap的小刀 let isHit = this.knifeList.some(knife= let gap = 5 let angle = Math.abs(knife.angle) return angle gap || (360 - angle) gap ) // 当检查到小刀旋转的角度小于5时，判定撞击 if(isHit) // 弹回 let action = cc.sequence( cc.spawn( cc.moveTo(0.5, this.knifeNode.x, -cc.winSize.height), cc.rotateBy(0.5, -360) ), cc.callFunc(()= // 游戏重新开始 cc.director.loadScene(game) ) ) this.knifeNode.runAction(action) else // 没有碰撞，创建一把新的小刀，代替knifeNode插在上面，knifeNode复位 this.canThrow = true let newKnife = cc.instantiate(this.knifePrefab) newKnife.setPosition(this.knifeNode.position) this.node.addChild(newKnife) this.knifeList.push(newKnife) this.knifeNode.setPosition(new cc.Vec2(0, -300)) ) ) this.knifeNode.runAction(action) start () // 定时变速 setInterval(()=this.changeSpeed(), 2000) update (dt) // 木桩旋转 this.targetNode.angle = (this.targetNode.angle + this.rotateSpeed * dt) % 360 //小刀和木桩旋转一致，要计算相对木桩圆心的位移位置 this.knifeList.forEach((knife:cc.Node)= knife.angle = (knife.angle + this.rotateSpeed * dt) % 360 let rad = Math.PI * (knife.angle - 90) / 180 knife.x = this.targetNode.x + this.rotateRadius * Math.cos(rad) knife.y = this.targetNode.y + this.rotateRadius * Math.sin(rad) )"},{"title":"2D横版角色移动-攻击-跳跃-冲刺-闪避","path":"/wiki/Cocos/game_01_MatchMan.html","content":"原视频教程 PopovStudio 准备工作将骨骼动画文件从DragonBones中导出之后，一共生成了3个文件：hero_ske.json 骨骼数据 hero_tex.json tex定位数据hero_tex.png tex拼接图片创建空节点作为hero，新增DragonBones组件，将导出的json文件赋值到对应的位置： 角色移动与相机跟随角色横向移动 角色横向移动，需要进行如下处理：角色可以横向移动相机跟随方向改变缓动@ccclassexport default class Hero extends cc.Component /** * 跟随相机 */ @property(cc.Node) camera: cc.Node = null /** * 英雄速度 */ @property heroSpeed:number = 1 /** * 移动方向 */ dir:number = 1 /** * 控制自动切换方向计时器 */ changeDirTime = 100 update(dt) // 自动切换方向 this.changeDirFunction() // 英雄移动 this.heroMove() // 相机跟随 this.cameraMove() // 自动切换方向 changeDirFunction() this.changeDirTime -- if(this.changeDirTime = 0) // 像反方向产生一个随机的力 this.changeDirTime = 50 + Math.floor(Math.random() * 101) this.dir *= -1 // 转换方向时，从0速度开始加速 this.heroSpeed = 0 // 英雄移动 heroMove() // ease-in 缓入动画 if(this.heroSpeed = 3) this.heroSpeed += 0.1 switch(this.dir) case 1: // 向右移动 this.node.x += this.heroSpeed; break; case -1: this.node.x -= this.heroSpeed break; // 摄像机跟随 cameraMove() this.camera.x = this.node.x this.camera.y = this.node.y 移动手柄创建移动手柄创建移动手柄UI组件：新建rocker.ts脚本，用于控制控制器中移动手柄的操作：@ccclassexport default class Rocker extends cc.Component /** * 移动手柄 */ @property(cc.Node) Stick: cc.Node = null /** * 最大半径 */ @property max_r:number = 100 start () // 注册触摸事件 // 开始触摸 this.node.on(cc.Node.EventType.TOUCH_START,(e:cc.Event.EventTouch) = const w_pos = e.getLocation() // 获取触摸点世界坐标 const n_pos = this.node.convertToNodeSpaceAR(w_pos) // 转化为该节点的坐标 // 控制移动距离 let len = n_pos.mag() // 返回原点到该点坐标向量的长度 if(len this.max_r) // 使用三角函数实现 n_pos.x = this.max_r * n_pos.x / len n_pos.y = this.max_r * n_pos.y / len this.Stick.setPosition(n_pos) ) // 触摸移动 this.node.on(cc.Node.EventType.TOUCH_MOVE, (e:cc.Event.EventTouch) = const w_pos = e.getLocation() const n_pos = this.node.convertToNodeSpaceAR(w_pos) // 控制移动距离 let len = n_pos.mag() if(len this.max_r) n_pos.x = this.max_r * n_pos.x / len n_pos.y = this.max_r * n_pos.y / len this.Stick.setPosition(n_pos) ) // 触摸结束 this.node.on(cc.Node.EventType.TOUCH_END, (e:cc.Event.EventTouch) = this.Stick.setPosition(0, 0) ) // 触摸取消 this.node.on(cc.Node.EventType.TOUCH_CANCEL, (e:cc.Event.EventTouch) = this.Stick.setPosition(0, 0) ) 控制玩家左右移动手柄控制移动 关键点：检测手柄移动坐标的x值正值向右移动负值向左移动检测手柄的触摸结束和取消事件取消时玩家停止行动相机设置最大跟随参数保留相机和玩家之间的一定移动距离方向移动和停止手柄每次监听到移动都触发玩家的方位判断手柄脚本：@ccclassexport default class Rocker extends cc.Component // ... /** * 手柄移动的玩家 */ @property(cc.Node) Hero:cc.Node = null heroJs = null start () this.heroJs = this.Hero.getComponent(HeroComp) this.node.on(cc.Node.EventType.TOUCH_START,(e:cc.Event.EventTouch) = // ... this.heroJs.setDir(n_pos.x) // 玩家进行方位判断 ) // 触摸移动 this.node.on(cc.Node.EventType.TOUCH_MOVE, (e:cc.Event.EventTouch) = // ... this.heroJs.setDir(n_pos.x) ) // 触摸结束 this.node.on(cc.Node.EventType.TOUCH_END, (e:cc.Event.EventTouch) = // ... this.heroJs.cancelMove() ) // 触摸取消 this.node.on(cc.Node.EventType.TOUCH_CANCEL, (e:cc.Event.EventTouch) = // ... this.heroJs.cancelMove() ) Hero脚本：@ccclassexport default class HeroComp extends cc.Component /** * 相机速度 */ @property cameraSpeed:number = 0 /** * 英雄速度 */ @property heroSpeed:number = 0 /** * 移动方向 */ dir:number = 0 // 停止移动 cancelMove() this.dir = 0 // 根据x设置移动方向 setDir(x) let preDir = this.dir if(x0) // 向左 this.dir = 1; if(this.node.scaleX != -0.3) this.node.scaleX = -0.3 else if(x0) // 向右 this.dir = -1 if(this.node.scaleX != 0.3) this.node.scaleX = 0.3 if(preDir !== this.dir) // 修改方位/停下/开始行动，hero和相机的移动速度同时置0 this.heroSpeed = 0 this.cameraSpeed = 0 相机跟随添加最大起始跟随距离，对相机跟随速度进行缓动处理：@ccclassexport default class HeroComp extends cc.Component // ... /** * 跟随相机 */ @property(cc.Node) camera: cc.Node = null /** * 相机速度 */ @property cameraSpeed:number = 0 // 摄像机跟随 cameraMove() // 相机进行阻尼式跟随 let dis = Math.abs(this.camera.x - this.node.x) if(dis 5) return if(this.cameraSpeed = 3) this.cameraSpeed += 0.1 if(this.camera.x this.node.x) this.camera.x += this.cameraSpeed else this.camera.x -= this.cameraSpeed 动画切换需要给玩家添加状态机参数进行控制:@ccclassexport default class HeroComp extends cc.Component // 龙骨组件 dbDisplay = null dbArmature = null // 状态机 0待机 1奔跑 state = 0 onLoad() this.dbDisplay = this.node.getComponent(dragonBones.ArmatureDisplay) this.dbArmature = this.dbDisplay.armature() // 播放动画 animFunction(animName) // 调用接口播放动画 this.dbArmature.animation.fadeIn(animName,-1, -1, 0, ANI_GROUP, dragonBones.AnimationFadeOutMode.All) // 停止移动 cancelMove() this.dir = 0 this.state = 0 this.animFunction(待机) // 根据x设置移动方向 setDir(x) let preDir = this.dir this.state = 1 if(x0)/*向左略*/ else if(x0)/*向右略*/ if(preDir !== this.dir) // 转换方向/由待机到奔跑状态 this.heroSpeed = 0 this.cameraSpeed = 0 this.animFunction(奔跑) 物理组件物理组件 全局开启物理引擎：@ccclassexport default class Game extends cc.Component physicDirector = null onLoad() this.physicDirector = cc.director.getPhysicsManager() this.physicDirector.enabled = true 给Hero和Ground地面添加物理碰撞检测组件，同时给项目添加Hero和Ground的分组开启2组之间的碰撞检测由于之前Hero的移动是通过直接修改坐标实现的，这里改为给Hero的刚体添加线性速度实现：heroMove() const v = this.body.linearVelocity // ease-in if(this.heroSpeed = 6) this.heroSpeed += 0.4 switch(this.dir) case 1: // 向右移动 // this.node.x += this.heroSpeed; v.x += this.heroSpeed break; case -1: // this.node.x -= this.heroSpeed v.x -= this.heroSpeed break; this.body.linearVelocity = v Hero跳跃Jump 跳跃时，添加一个向上的线性速度需要监听跳跃动画的播放跳跃开始，播放跳跃动画跳跃结束，需要回到奔跑或待机的状态增加跳跃CD的设置@ccclassexport default class HeroComp extends cc.Component // 龙骨组件 dbDisplay = null // 状态机 0待机 1奔跑 state = 0 // 跳跃间隔 jumpCD:number = 0 onLoad() this.dbDisplay = this.node.getComponent(dragonBones.ArmatureDisplay) // 绑定动画播放结束事件 this.dbDisplay.on(dragonBones.EventObject.COMPLETE, this.aniComplete, this) update(dt) // CD减少 if(this.jumpCD 0) this.jumpCD -- // 动画播放结束事件 aniComplete() // 回到状态机所在的状态 if(this.state == 1) this.animFunction(奔跑) else if( this.state == 0) this.animFunction(待机) // 播放动画 animFunction(animName) // 调用接口播放动画 this.dbArmature.animation.fadeIn(animName,-1, -1, 0, ANI_GROUP, dragonBones.AnimationFadeOutMode.All) // 跳跃 jump() // 如果跳跃cd未过，无法跳跃 if(this.jumpCD 0) return const v = this.body.linearVelocity v.y = 450 // 增加一个向上的力 this.body.linearVelocity = v this.animFunction(普通跳跃) this.jumpCD = 50 // 重置跳跃cd Hero 攻击普通攻击动画根据攻击间隔，播放攻击动画@ccclassexport default class HeroComp extends cc.Component // 攻击间隔 attachCD:number = 0; update(dt) if(this.attachCD 0) this.attachCD -- // 攻击 attack() if(this.attachCD 0) return // 播放攻击动画 this.animFunction(普攻_01) this.attachCD = 50 连招攻击使用一个数组存放连招需要用的动画名字引入一个连招CD用于判断角色每次攻击之间的时间间隔，引入一个用于记录当前连招的变量// 连招数组const attAnimList = [普攻_01,普攻_02,普攻_03,普攻_04,]@ccclassexport default class HeroComp extends cc.Component // 连招间隔 combatCD:number = 0 update(dt) if(this.attCount 0) if(this.combatCD 0) this.combatCD -- if(this.combatCD = 0) this.attCount = 0 // 攻击 attack() if(this.attachCD 0) return this.animFunction(attAnimList[this.attCount]) // 增加连招序号 this.attCount = (this.attCount + 1) % attAnimList.length switch(this.attCount) // 根据当前连招序号，修改连招CD case 1: this.combatCD = 120;break; case 2: this.combatCD = 140;break; case 3: this.combatCD = 160;break; this.attachCD = 50 攻击检测使用攻击范围和受击范围包围盒式检测，需要知道如下参数：攻击方 a当前坐标 a.x, a.y此时朝向 a.dir正面攻击范围 a.aR.x_01背面攻击范围 a.aR.x_02攻击高度 a.aR.y受击方 n当前坐标 n.x, n.y此时朝向 n.dir正面受击范围 n.hR.x背面受击范围 （此处和图不太一样，背面受击和正面受击设置一样的范围）受击高度 n.hR.y存在下面几种可能第一行：玩家朝左第二行：玩家朝右已经知道玩家攻击方向朝左，就能知道玩家的攻击包围盒存在碰撞的可能性有很多，一一判断比较麻烦，所以这里判断不会碰撞的情况let hit = !( a.x - a.aR.x_01 n.x + n.hR.x || // 正面打不到 a.x + a.aR.x_02 n.x - n.hR.x || // 背面到不到 a.y n.y + n.hR.y || // 上面打不到 a.y + a.aR.y n.y // 下面打不到)let hit = !( a.x + a.aR.x_01 n.x - n.hR.x || // 正面打不到 a.x - a.aR.x_02 n.x + n.hR.x || // 背面打不到 a.y n.y + n.hR.y || // 上面打不到 a.y + a.aR.y n.y // 下面打不到)根据上面的判断条件，创建用于检测战斗检测的方法：/** * @param aNode 攻击方Node * @param a 攻击方自定义组件类 * @param nNode 受击方Node * @param n 受击方自定义组件类 * @param _faceDir 攻击方朝向 */export const checkCollide = (aNode, a, nNode, n, _faceDir) = /** * 当受攻击方的受击盒 和攻击方的攻击盒 有交叉部分时， * 检测到攻击 */ switch(_faceDir) case -1: // 向左 return !( aNode.x - a.aR.x_01 nNode.x + n.hR.x || // 正面打不到 aNode.x + a.aR.x_02 nNode.x - n.hR.x || // 背面到不到 aNode.y nNode.y + n.hR.y || // 上面打不到 aNode.y + a.aR.y nNode.y // 下面打不到 ) break; case 1: // 向右 return !( aNode.x + a.aR.x_01 nNode.x - n.hR.x || // 正面打不到 aNode.x - a.aR.x_02 nNode.x + n.hR.x || // 背面打不到 aNode.y nNode.y + n.hR.y || // 上面打不到 aNode.y + a.aR.y nNode.y // 下面打不到 ) break; Hero中用于进行击中检测的脚本：@ccclassexport default class HeroComp extends cc.Component // 身体朝向 1=右侧 -1=左侧 bodyDir:number = 1 // 攻击距离 aR = x_01: 0, // 正面攻击距离 x_02: 0, // 背面攻击距离 y: 0, // 垂直攻击高度 onLoad() // 重置身体转向右侧 this.node.scaleX = -0.3 // 初始化碰撞盒 this.aR.x_01 = this.node.width * 0.3 * 1 // 朝前一身 this.aR.x_01 = this.node.width * 0.3 * 0.5 // 朝后半身 this.aR.y = this.node.height * 0.3 // 高度全身 // 添加一个动画帧来控制 this.dbDisplay.on(dragonBones.EventObject.FRAME_EVENT, this.frameEvent, this) // 动画中的帧事件需要在龙骨中加入 frameEvent(e) switch(e.name) // 攻击动画播放到一半，开始判定敌人受伤 case attack: let enemyNode = window.game.getComponent(Game).enemy_01 let enemy = enemyNode.getComponent(Enemy) // 判断是否击中 let hit = checkCollide( this.node, this, enemyNode, enemy, this.bodyDir ) if(hit) // 调取敌人的被击中方法 enemy.getHit() break; Enemy中用于检测被击中的脚本：const ANI_GROUP = normalGroupconst ccclass, property = cc._decorator;// 受击数组const hitAnimList = [受击_01,受击_02,受击_03,受击_04,]@ccclassexport default class Enemy extends cc.Component // 敌人受击范围 hR = x:0, y:0 dbDisplay = null dbArmature = null // 身体朝向 bodyDir = 1 onLoad() this.setFaceDir(1) this.dbDisplay = this.node.getComponent(dragonBones.ArmatureDisplay) this.dbArmature = this.dbDisplay.armature() this.dbDisplay.on(dragonBones.EventObject.COMPLETE, this.aniComplete, this) // 播放动画 animFunction(animName) // 调用接口播放动画 this.dbArmature.animation.fadeIn(animName,-1, -1, 0, ANI_GROUP, dragonBones.AnimationFadeOutMode.All) // 被击中脚本 getHit() // 随机选择被击中动画 let index = Math.floor(Math.random() * hitAnimList.length) let ani_name = hitAnimList[index] this.animFunction(ani_name) // 收到伤害后，面向hero let dir = 1 if(this.node.x window.game.hero.x) dir = -1 // 向右转 this.setFaceDir(dir) setFaceDir(dir) this.bodyDir = dir this.node.scaleX = 0.3*-dir // 动画播放结束事件 aniComplete() this.animFunction(待机) start () // 初始化敌人受伤害的范围 this.hR.x = this.node.width * 0.3 this.hR.y = this.node.height * 0.3 对全局对象的扩充由于像enemy、hero这种节点比较关键，全局都有可能会用到，所以可以将他们集中挂载到window全局对象下,先在根目录下加入global.d.ts文件用于覆写window的属性declare interface Window game?: any在全局挂载脚本game中加入如下代码：@ccclassexport default class Game extends cc.Component physicDirector = null @property(cc.Node) enemy_01:cc.Node = null @property(cc.Node) hero:cc.Node = null onLoad() // 挂载game到window上 window.game = this this.physicDirector = cc.director.getPhysicsManager() this.physicDirector.enabled = true"},{"title":"🧩拼图游戏","path":"/wiki/Cocos/game_04_PuzzleGame.html","content":"资源地址 视频教程：阿信OL拼图游戏Demogithub源码 📖实现思路实现思路 将一张完整的纹理分割成4*4的方块给每个方块随机分配位置针对每个方块的开始移动、移动中、移动结束事件执行指定操作每次移动之后，检测拼图是否完成 💻代码实现方块预制体组件Block @ccclassexport default class Block extends cc.Component startPos:cc.Vec3 = null initialIndex:row:Number, col:Number = row:0, col:0 protected onLoad(): void this.node.on(cc.Node.EventType.TOUCH_START, this.touchStart, this) this.node.on(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this) this.node.on(cc.Node.EventType.TOUCH_END, this.touchEnd, this) protected onDestroy(): void this.node.off(cc.Node.EventType.TOUCH_START, this.touchStart, this) this.node.off(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this) this.node.off(cc.Node.EventType.TOUCH_END, this.touchEnd, this) // 选中碎片开始移动，碎片透明度降低，层级升高，记录碎片初始坐标 touchStart(e:cc.Event.EventTouch) this.node.opacity = 128 this.node.zIndex = 1 this.startPos = this.node.position // 碎片移动中，= touchMove(e:cc.Event.EventTouch) this.node.x += e.getDeltaX() this.node.y += e.getDeltaY() // 碎片移动结束，透明度和层级恢复 touchEnd(e:cc.Event.EventTouch) this.node.opacity = 255 this.node.zIndex = 0 // 获取碎片当前坐标的序号坐标 let targetIndex = this.getIndex(this.node.position) let originIndex = this.getIndex(this.startPos) try // 交换2个碎片的坐标和在数组中的位置 let targetNode = window.blockArray[targetIndex.row][targetIndex.col] this.node.setPosition(targetNode.position) targetNode.setPosition(this.startPos) window.blockArray[targetIndex.row][targetIndex.col] = this.node window.blockArray[originIndex.row][originIndex.col] = targetNode window.checkOver() catch(error) this.node.setPosition(this.startPos) // 像素坐标转序号坐标 getIndex(position:cc.Vec3) return col:Math.floor(Math.abs(position.x / this.node.width + 0.5)), row:Math.floor(Math.abs(position.y / this.node.height - 0.5)) // 初始化预制体 init(picTexture:cc.Texture2D, pos:x:number, y:number) let sprite = this.node.getComponent(cc.Sprite) let width = this.node.width let height = this.node.height // 切割纹理 let frame = new cc.SpriteFrame(picTexture, cc.rect(pos.x * width, pos.y * height, width, height)) sprite.spriteFrame = frame; 游戏组件Game @ccclassexport default class Game extends cc.Component @property(cc.Prefab) // 碎片预制体 blockPrefab:cc.Prefab = null blockArray:Arraycc.Node[] = [] // 碎片尺寸 blockSize : number = 720 / 4 win:Boolean = false start () window.blockArray = this.blockArray window.checkOver = this.checkOver // 动态加载拼图图片 cc.resources.load(img/cats,cc.Texture2D,(error:Error,assets:cc.Texture2D)= if(error) console.log(error) return for(let row = 0; row 4; row++) this.blockArray[row] = [] for(let col = 0; col 4; col ++) let newBlock = cc.instantiate(this.blockPrefab) newBlock.getComponent(Block).initialIndex.row = row newBlock.getComponent(Block).initialIndex.col = col newBlock.getComponent(Block).init(assets,x:col, y:row) newBlock.setPosition(new cc.Vec2(this.blockSize * col, -this.blockSize * row)) this.node.addChild(newBlock) this.blockArray[row][col] = newBlock this.randomBlock() ) // 检查游戏是否结束 checkOver() if(this.win) return try for(let row = 0; row4; row++) for(let col = 0; col4; col++) let node = this.blockArray[row][col] let block = node.getComponent(Block) let curPos = block.getIndex(node.position) if(curPos.row != block.initialIndex.row || curPos.col != block.initialIndex.col) return this.win = true setTimeout(()= alert(You Win！) ,300) catch(err) console.log(err) // 打乱碎片顺序 randomBlock() for(let row = 0; row4; row++) for(let col = 0; col4; col++) let exRow = Math.floor(Math.random() * 4) // 0-4 let exCol = Math.floor(Math.random() * 4) // 0-4 let exNode = this.blockArray[exRow][exCol] let curNode = this.blockArray[row][col] let tempPos = exNode.position exNode.setPosition(curNode.position) curNode.setPosition(tempPos) this.blockArray[exRow][exCol] = curNode this.blockArray[row][col] = exNode"},{"title":"Trae","path":"/wiki/AI/ai-03-Trae.html","content":"简介官网：https://docs.trae.ai/ide/what-is-trae?_lang=zh Trae: The Real AI Engineer 关键功能 侧边栏智能问答 代码自动补全 代码片段生成 从0-1开发项目 基础案例案例1：MCP用例：将Figma设计稿转化为前端代码"},{"title":"Cursor参考文档","path":"/wiki/AI/cursor-01-doc.html","content":"核心 Core快速开始 Quickstart概念 ConceptsTab代码自动补全 Autocomplete with Tab操作快捷键接受建议Tab拒绝Esc逐词接受Ctrl+Arrow-Right🔍工作原理上下文窗口中的代码被加密发送到后端后端解密后读取上下文Cursor Tab模型 预测代码建议，并返回给客户端在编辑器中显示内联编辑选中内容 Inline Edit a selection操作快捷键打开内联浮窗Ctrl+K切换输入焦点Ctrl+Shift+K提交Enter取消Ctrl+Shift+BackSpace快速提问Alt+Enter发送到聊天Ctrl+L内联模式模式描述Edit Selection 选区编辑针对选中代码修改Edit Full File 全文件编辑整个文件范围的更改Quick Question 快速问答针对选中代码提问Send to Chat 发送到聊天发送到聊天，支持更高级的Agent功能默认上下文内联模式也支持使用 @符号 ，添加默认上下文。上下文类型可以是：相关文件 @Files最近查看的代码 @Code相关信息 @DocsWeb相关代码定义 @Definitions终端内联编辑在 终端 中按快捷键 Ctrl+K描述希望执行的操作，可以生成相应的命令与Agent聊天 Chat with AgentCursor上限和下限跨度最大的功能上到串通工作流下到联网查问题高到MCP上下文低到CMD控制台Agent后台处理 Handoff word to Background Agent用户和Cursor异步并行工作可以通过编辑器或外部集成（如Slack）访问目前还没有用到，有需要参考文档编写规则 Write a rule创建 mdc文件 定义一些规则，相当于通用持久记忆MCP服务器 Set up an MCP server集成外部工具的模型上下文协议连接数据库、API和文档源Tab自动补全多行和代码块在文件内和跨文件跳转到下一个自动补全建议AgentAgent相当于一个虚拟助理，能够根据目标、规则和环境做出决策和行动对于Cursor Agent，环境就是能够读取到的代码和文件内容Background Agent一边工作一边异步运行任务可以通过编辑器或外部集成（如Slack）访问Inline Edit精简版Agent针对选中代码块进行编辑Chat传统对话式智能体Rules定义AI行为的自定义指令。设置编码标准、框架偏好Memory需要持久存储的上下文和对话是另一种形式的rules记忆如何创建 Sidecar观察有一个独立的模型，观察对话并自动提取记忆在后台被动进行后台生成的记忆需要用户批准才能保存，确保对内容的信任和控制 工具调用当用户明确要求Agent记住某些内容或当它注意到应该为未来的会话保留重要信息时Agent可以直接使用工具调用创建记忆 管理记忆Cursor Setting Rules 中管理记忆Indexing当打开一个项目时，Cursor开始学习该项目的代码，即“索引”打开项目时，索引自动开始对代码库进行语义分析，支持代码搜索、引用查找和上下文感知建议MCP集成外部工具的模型上下文协议连接数据库、API和文档源模型用于代码生成不同的AI模型每个模型具有不同的速度和能力特性 核心：🤖智能体模式 Modes Agent自主探索、多文件编辑权限：所有工具 Ask只读探索、无自动更改权限：搜索工具 Manual直接文件编辑、具有明确控制权限：编辑工具只编辑明确选择的文件在确切知道要编辑什么时效果最佳，选择正确的文件并给出清晰的指令 Custom用户定义的功能对特定的工具组合和指令创建自定义模式 工具 Tools在Custom模式下，智能体的这些工具可以被自由的启用禁用应用更改 Apply Changes应用、接受或拒绝聊天中的代码建议原理简述Apply是一个专门的Cursor模型专门接收Agent生成的代码，并集成到文件中Apply不生成代码，只负责集成可以处理多个文件和大型代码库的更改审查差异 Review Diffs审查和管理由AI代理生成的代码更改逐文件审查选择性接受审查更改（review changes）查看更改的完整差异聊天标签页 Chat Tabs可以同时运行多个对话每个标签页都维护自己的上下文、历史记录和模型选择检查点 Checkpoints自动快照跟踪Agent更改，可以进行restore恢复终端集成 Terminal Integration可以使用Agent执行终端命令、监控输出并处理多步骤流程为可信工作流配置自动运行聊天历史 Chat History回顾之前讨论、跟踪编码会话、参考早期聊天上下文导出聊天 Export Chats导出为 markdown格式 与团队成员分享解决方案、或从编码会话中创建知识库规则 Rules可以使用rules，为Agent的行为定义自定义指令有助于维护编码标准、强制执行模式、个性化Agent 智能体：💬聊天 标签页 Tabs 沙盒隔离： 每个标签页的对话历史、上下文、模型选择独立冲突： 多个标签页编辑相同的文件时，系统会提示解决冲突（和git merge相似）引用其他聊天记录： 使用 Past Chats 来包含其他标签页或者之前绘画的上下文💡建议每个标签页使用一个任务，提供清晰的初始描述关闭已完成的标签页以保持工作区整洁检查点 Checkpoints 用途： 在Agent更改后保存和恢复之前的状态提示： 检查点不是版本控制，还是需要使用git来保存永久历史记录🔍工作原理本地存储仅跟踪Agent更改自动清理（在当前会话和最近的历史记录中保存）导出 Export 导出内容（Markdown格式）所有消息和响应语法高亮代码块文件引用和上下文按时间顺序的对话流程💡注意导出时请检查敏感数据：API密钥、内部URL、专有代码、个人信息等复制 Duplicate 从对话中的任意点创建分支，选择 Duplicate Chat 到该时间点的上下文会被保留，原始对话保持不变两个聊天都维护各自独立的历史记录历史记录 History 历史聊天记录可以打开、删除、重命名记录会存储在本机器 SQLite数据库 中后台代理： 不在常规的历史记录中，而是存储在远程数据库中引用过往聊天记录： @Past Chats摘要功能 Summarization 聊天中长对话的上下文管理Cursor会自动摘要和管理上下文，保持聊天的高效🔍工作原理当对话变得越来越长时，Cursor会对比较旧的消息进行摘要（压缩）对文件和文件夹，Cursor使用另一种处理方式：智能压缩Cursor会根据文件大小和可用上下文空间确定呈现它们的最佳方式文件压缩的几种情况：已压缩显著压缩未包含（警告）压缩会向模型显示关键的结构元素，如函数签名、类、方法。模型有需要时展开特定文件最大化了对可用上下文窗口的有效利用文件太大而无法完整包含，压缩也不行，模型只能获取到文件名项目太大无法包含在上下文窗口 智能体：🧾规划 Agent如何通过规划和管理复杂任务提前规划结构化的待办事项列表、消息队列 🗒️Agent待办事项将较长的任务分解为可管理的步骤建立依赖关系？结构化计划会随工作进展而更新 🔍工作原理 自动为复杂任务创建待办事项列表每个项目都可以依赖于其他任务列表随工作进展实时更新已完成的任务会自动标记为完成 可见性 方式1：显示在聊天界面中方式2：Slack集成显示？ 💡注意最好清楚地描述最终目标，让Agent了解完整范围，才能创建更准确的任务分解 使用队列 当Agent正在工作时，输入下一个指令 Enter将其添加到队列中 消息按顺序显示在活动任务下方 点击箭头可以重新排列队列消息 Agent会在完成后按顺序处理它们 覆盖队列：强制推送消息，会绕过队列立即执行 智能体：🔧工具 搜索 Search （搜索代码库网络以查找相关信息 ） 工具名描述读取文件Read files最多250行，最大模式下为750行列出目录List directory只读取目录结构，不读取文件内容代码库Codebase在已索引代码库中执行语义搜索Grep在文件中搜索确切的关键词或模式搜索文件Search files使用模糊匹配按名称查找文件网络Web生成搜索查询并执行网络搜索获取规则Fetch rules根据类型和描述检索特定的规则编辑 Edit（对文件和代码库进行特定编辑） 工具名描述编辑和重新应用Edit Reapply文件编辑并自动应用删除文件Delete file删除文件运行 Run（与终端进行交互） Cursor可以运行终端命令并监控输出Cursor使用默认的终端配置文件修改中端配置文件：Terminal:Select Default ProfileMCP 可以使用配置的MCP服务器与外部服务进行交互，例如数据库或第三方API高级选项 工具名描述自动应用编辑Auto-apply Edits自动应用编辑无需手动确认自动运行Auto-run自动执行终端命令并接受编辑,适用于运行测试套件和验证更改安全防护Guardrails一大堆允许配置，来确保哪些工具可以自动执行自动修复错误Auto-fix Errors当Agent遇到代码检查错误和警告时自动解决 核心：🚩规则规则介绍 通过可重用的作用域指令控制Agent模型的行为可以视为项目的持久上下文、偏好设置或工作流程**规则适用范围：**为Agent和内联编辑提供系统级指令（tab不适用） 规则类型 项目规则用户规则存储在 .cursorrules 中受版本控制作用于代码库可以使用路径模式进行规则限定手动调用基于相关性包含嵌套规则：子目录可以包含自己的 .cursorrules 目录，范围限定在该文件夹内嵌套规则会根据项目层级自动附加💡可以使用Rules处理的场景 编码关于代码库的领域特定知识 自动化项目特定的工作流程或模版 标准化样式或架构决策 全局应用于Cursor环境设置中定义并始终生效比较适合设置首选的沟通风格或编码约定 🔍作用原理 提供持久的、可重用的上下文应用时，规则内容会包含在模型上下文的开始部分 创建规则 规则结构 MDC 编写，支持元数据和内容格式属性 Property 属性 描述 description 规则描述 globs 作用域 alwaysApply 应用范围 规则作用类型 Rule Type 属性 描述 Always 始终包含在模型上下文中 Auto Attached 引用匹配glob模式的文件时包含 Agent Requested 由AI决定是否包含，因此必须提供描述 Manual 仅在使用@ruleName显式提及时包含 创建规则 创建方式1Cursor Settings Rules 可以看到并管理所有规则创建方式2New Cursor Rule 命令创建方式3Generate Cursor Rules 命令，根据当前和智能体的对话，生成规则 案例 这里Cursor文档里提供了几个规则标准，还挺有意思的。还有更多示例可以从提供商、框架、社区贡献的在线众包集合和储存库中找到。 ---alwaysApply: trueglobs:description: 自动化开发工作流程和文档生成---此规则自动化应用分析：当被要求分析应用时：1. 使用 npm run dev 运行开发服务器2. 从控制台获取日志3. 建议性能改进此规则帮助生成文档：通过以下方式帮助起草文档：- 提取代码注释- 分析README.md- 生成markdown文档 💡建议 规则应该是专注的、可操作的、有明确范围的 保持规则在500行以内 将大型规则拆分为多个可组合的规则 提供具体的实例或引用文件 避免模糊指导，编写规则时要像清晰的内部文档一样 在聊天中重复提示时重用规则 上下文 Context上下文不足会导致幻觉或效率低下，而过多的上下文会稀释信号。找到合适的平衡点以获得最佳效果 ❔什么是上下文 答：上下文是指提供给模型的信息 模型随后使用这些信息来预测后续信息 有两种类型的上下文： 状态上下文 State Context对当下状态的描述描述性“这是一张新的设计图纸，对现有的颜色主题做了一些调整” 意图上下文 Intent Context用户希望达到的目标规定性“我需要你按照这张图纸，修改界面的颜色样式” 缺少上下文时，Agent可能做出的反映： 反向对应：幻觉 Hallucination 模型在缺乏足够上下文情况下，生成看似合理但事实上虚构的内容User：秦始皇最近缺钱吗？AI：是的，他目前正在筹备修建新的长城项目，遇到资金短缺的情况非常正常… 正向对应：上下文感知 Agent尝试通过搜索代码库、读取文件和调用工具自行收集上下文。Cursor的核心构建理念即：上下文感知，旨在最大程度减少用户的干预 🕊️上下文使用建议 清晰表达清晰表达状态 （当下情况） 和 意图 （希望达成）精确定位使用 @符号 进行精准上下文定位总结经验重复使用的知识可以总结为规则，成为长期记忆对外交流通过 MCP 来连接外部系统 上下文：代码库索引通过为每个文件计算嵌入向量来索引代码库如果已索引代码库 6周 不活跃后会被删除检查索引状态： Cursor Setting Indexing Docs 配置项 忽略文件（ .gitignore 、 .cursorignore ） 提示： 忽略大型内容文件可以提高答案准确性 查看已索引文件： View included files 多根工作区 所有代码库都会自动建立索引 AI可用每个代码库的上下文 .cursorrules 在所有文件夹中都有效 PR搜索 通过让历史变更可搜索和通过AI访问，帮助立即代码库的演进过程 🔍工作原理 自动索引所有已合并的PR，来自仓库记录摘要会出现在语义搜索结果中通过智能过滤来优先显示最近的变更Agent可以使用@获取PR、提交、问题或分支到上下文中@[PR 编号]@[commit hash]@[branch name]支持平台有限，目前主要是 github 和 bitbucket 上下文：忽略文件配置文件 .cursorignore .cursirindexingignore 仅从索引中排除文件，文件可以被AI访问，但不会出现在代码库搜索中配置方式全局忽略文件 Settings Global Cursor Ignore List 配置.cursorignore在根目录中使用 .gitignore 语法创建 .cursorignore 文件默认忽略文件.gitignore 中的文件一些默认忽略列表（文档里有）在 .cursorignore 中可以使用 !前缀 覆盖否定模式限制以 ! 为前缀如果父目录通过 * 被排除，则无法重新包含文件 （好微妙…） 建议： 显式排除嵌套目录 阻止范围 index tab 、agent 、inline edit @💡注意Agent发起的工具调用（终端MCP）无法阻止 为什么要忽略 性能： 排除无关部分可以实现更快的索引，和更准确的文件发现 安全性： 限制对API密钥、凭据、机密信息的访问 虽然可以限制访问，但由于LLM的不可预测性，无法保证完全保护？？？ 上下文：MCPMCP（Model Context Protocol） MCP使Cursor能够连接到外部工具和数据源无需重复解释项目结构，直接与工具集成 🔍工作原理 MCP服务器通过协议公开功能，将Cursor连接到外部工具或数据源支持三种传输方式：stdioCursor管理单用户shell命令手动SSE部署为服务器多用户SSE端点URLOAuthStreamable HTTP部署为服务器多用户HTTP端点URLOAuth 上下文：@符号@描述@Files引用特定文件@Folders引用整个文件夹@Code引用特定代码片段或符号@Docs访问文档和指南@Git访问git历史记录和更改@PastChats 使用汇总的编辑器回话@Rules使用cursor规则@Terminals终端@ActiveTabs 激活的智能体@LinterErrors 引用lint错误@Web外部网络资源和文档@Link粘贴URL时，Cursor会将其自动标记为@Link，支持PDF@RecentChanges 创建指向特定代码或文档的联机#Files将文件添加到上下文中而不引用Commands将打开和活动的文件添加到上下文中"},{"title":"ai介绍","path":"/wiki/AI/index.html","content":"chatgpt 免费版使用 claude code（很强） 使用教程 trae国内版使用 相关技术概念解释MCP技术简介MCP（Model Context Protocol）模型上下文协议 gpt答案：https://chatgpt.com/c/688d6f54-7534-800a-b951-7f09a2a39c7b 上下文协议对日常生活中的人也适用，比如当前网络上出现的MEME文化，（此处贴表情包）只有结合众多网络文化和故事背景去看，MEME才有真正的意义。这点对AI模型来说也是一样，MCP能帮助模型记忆和理解对话背景，比如：用户：“我没什么朋友，平时一个人应该怎么排解孤独？”模型：“我推荐少宅在家里，多出门进行户外体育运动。”用户：“有什么推荐的户外运动类型吗？”模型（失忆版）：“我推荐三五好友结伴打羽毛球。”模型（上下文版）：“独自一人的话可以选择徒步或者单车旅行。” 所谓Protocol，即用于规范如何传递这些上下文信息。比如多轮对话后，哪些信息是有效的，哪些可以被忘记。举个例子：期末考试前，为了不挂科熬夜背的那些知识点，考完之后就可以忘记了。"},{"title":"♦️完美方块","path":"/wiki/Cocos/game_05_PerfectCubeGame.html","content":"资源地址 视频教程：阿信OL完美方块游戏Demogithub源码"},{"title":"vue","path":"/wiki/Job/front_01_vue.html","content":"关于前端面试题web前端面试-面试官系列【整理的非常全面】yyshino【一个有趣的博客，整理了不少面经】 特性相关Vue和React的区别vue使用类似html的template模板语法，react使用jsx组件通信方式不同vue组件中子组件传值给父组件，可以通过emit事件react中，则需要父组件传入一个方法，由子组件调用状态管理vue使用vuexpinia进行状态管理react使用的是redux生命周期vue组件有生命周期钩子react类组件可以使用生命周期，函数式组件一般使用hooks代替生命周期diff算法的实现不同react使用基于层级的diff算法首先比较两棵树的根节点核心思想是比较和替换节点vue使用的是双端比较diff算法 生命周期生命周期有哪些？ beforeCreate 组件实例被创建之前 create 组件实例完全创建 beforeMount 组件挂载之前 mounted 组件挂载到实例上后 beforeUpdate 组件数据发生变化，更新之前 updated 组件数据更新之后 beforeDestroy 组件实例销毁之前 destroyed 组件实例销毁之后 activated keep-alive缓存的组件激活时 deactivated keep-alive缓存的组件停用时 errorCaptured 捕获一个来自子孙组件的错误时被调用 进入组件之后会执行哪些生命周期 beforeCreate 组件实例被创建之前 data不存在，dom未渲染 create 组件实例完全创建 data存在，dom未渲染 beforeMount 组件挂载之前 data存在，dom未渲染 mounted 组件挂载到实例上后 data数据存在，dom也已经被渲染出来了 父组件引入子组件，生命周期执行顺序是？ 父组件-beforeCreate 父组件-created 父组件-beforeMount 子组件-beforeCreate 子组件-created 子组件-beforeMount 子组件-mounted 父组件-mounted 总结：父组件先准备数据，子组件接着渲染dom后，父组件渲染dom created中如何获取dom获取时机： 由于js执行代码遵循先同步后异步的机制，因此只要在异步回调中就能获取到dom 在setTimeout等宏任务中获取 $nextTick 获取方式： dom方法 ref 发送请求在created还是mounted？答： 这个问题具体要看项目和业务情况了， 因为组件的加载顺序是：父组件引入了子组件，那么先执行父组件的前3个生命周期，再执行子组件的前4个生命周期 如果需要优先加载子组件的数据，那么父组件的请求需要放在mounted中 如果组件没有依赖关系，那么请求放在哪个生命周期都是可以的。 为什么发送请求不在beforeCreate里？beforeCreate和created有什么区别？答： 在beforeCreate里，是获取不到methods里的方法的。 beforeCreate阶段，获取不到$el和$data created中能获取到$date，也能访问methods里的方法 第2次，或者第N次进入组件会执行哪些生命周期答： 如果加入了keep-alive，只执行activated 如果未加入，执行前4个生命周期 加入keep-alive会执行哪些生命周期？ activated deactivated 生命周期的使用场景有哪些？答： created 单个组件进行数据请求 mounted 获取dom 控制父子组件请求顺序 activated 组件入口携带不同的路由参数进入时，处理参数 destroyed 清理监听器和定时器 记录页面视频上次播放的时间 组件keep-alive答： 用途：缓存当前组件，提升性能，减少发送请求的数量 如果用户请求的页面组件和当前组件相同，不会发起新的请求 被keep-alive包裹的组件，再次进入时，仅会触发activated生命周期，不再执行前四个生命周期 组件传值有几种方式 父传子 方法1：父组件引用子组件，子组件使用props接收参数，缺点是父组件无法传值给孙子辈组件 不允许子组件直接修改prop传入的数据 需要通过事件或者回调的方式通知父组件，由父组件进行修改 方法2：子组件使用$parent直接获取父组件数据，孙子辈可以使用this.$parent.$parent获取，子组件可以直接修改父组件的数据 provideinject进行依赖注入，父组件直接向子代组件注入数据 传入为基本数据类型时，inject接收值为副本，子组件修改数据不会影响组件其它后代组件中的数据 传入为引用类型时，会影响 子传父 通过事件或者回调方式 通过this.$children[index].xxx，直接获取子组件实例中的数据 当存在条件渲染时，使用索引访问会变得很不可靠 绑定ref，通过this.$refs.子组件ref名称 兄弟互传 通过bus import bus from @/utils/bus.jsbus.$emit(change,new-value)bus.$on(change,val= console.log(val)) 子组件如何直接修改父组件的值 this.$parent.xxx知己修改 子组件如何找到父组件 this.$parent 如何找到根组件 this.$root provideinject 祖先组件通过provide注入数据 子孙组件通过inject接收数据 slot插槽 匿名插槽 具名插槽slot name=header/slottemplate #header/template 作用域插槽（可以传值）slot name=header :arr=[a,b,c] :brr=123/slottemplate #header=arr,brr/template 如何封装组件 组件尽量复杂，涉及到slot组件通信… 举例来说，我封装过一个2d可视化地图组件，这个组件主要作用是实时追踪卫星轨迹，对不同种类的卫星进行个性化定制展示，原本是作为独立项目进行开发的，到了后期，业务要求将这个功能嵌入到其它多个系统中，所以就需要封装成组件这个组件一共有2种模式，一种是提供精准追踪轨迹的方式，卫星会根据传入组件内的轨迹参数严格运行一种是智能推演方式，以传入组件的轨迹点位为锚点，推演各个锚点间的轨迹另外，像地图样式、卫星图例样式都是可以根据传入组件的参数进行个性化定制组件内提供一些事件回调：轨迹追踪开始、追踪结束、卫星发生碰撞、敌我卫星超过危险距离等事件另外，关于卫星图例中，像图表标题、图例、表头、表尾、工具栏等位置，都是提供插槽定制功能的，可以进行自定义操作。 props和data优先级谁高答：props的优先级高 初始化状态优先级： props methods data computed watch 为什么data是一个函数 重复创建实例时避免数据污染 保证对象独立 vuexVuex有哪些属性 state 全局共享属性 $store.state.str mapState getters 针对state数据进行二次计算 $store.getters.xxx mapGetters getters数据无法修改 mutations 存放同步方法的 在mutations中修改state actions 存放一步方法的，提交mutations modules 把vuex再次进行模块封装 vuex使用state值 this.$store.state.xxx 可以直接修改vuex的state数据的 mapState vuex的getters值修改vuex是单项数据流还是双向数据流答：单向数据流可以通过mutation进行修改 vuex的mutations和actions区别mutations: add(state) state.number += 2 ,actions: addNumber(commit,state) commit(add) mutations无返回值，功能局限在状态变更上 actions返回Promise对象，能够进行一步操作 actions用于提交mutation，不是直接变更状态 vuex持久化存储vuex本身无法实现持久化存储 方式1：localStorage 方式2：vuex-persistedstate 路由路由的模式和区别 hash url在根路径后跟随# 当请求的页面不存在时，不会向后台请求资源，自动跳转根路径 原理：基于url的hash值来实现路由，hash值变化，浏览器不会向服务器发送请求，而是触发hashChange事件，前端路由库监听该事件，根据hash值的变化动态渲染对应组件 无需服务器配置，无论hash值如何变化，服务器返回同一个页面 不利于SEO优化 用于需要兼容浏览器获不需要服务器配置的项目 打包后前台可以自测看到页面内容 history 请求页面不存在时，依旧发送请求 一般会跳转404页面 原理：基于html5的history api 需要服务器配置和浏览器兼容 用于对url美观性和seo要求较高的项目 打包后前台自测无法正常访问路由 子路由动态路由答： 常用于详情页 path:/list, name:List, children:[ path:/list:id, name:Detail, component:()=import(../views/Detail.vue) ] 路由传值 显式传值 // http://localhost:8000/about?a=1this.$router.push( path:/about, query: a:1 ) 隐式传值 // http://localhost:8000/about?a=1this.$router.push( path:/about, params: a:1 ) 导航故障 当前页跳转当前页的时候，会报导航故障错误 产生原因：在history模式下，使用html5的history api实现路由跳转，如果前端路由没有处理【同页面跳转】的情况，就可能导致导航故障 解决方法：重写VueRouter.prototype.push方法： import VueRouter from vue-routerconst routerPush = VueRouter.prototype.pushVueRouter.prototype.push = function(location) return routerPush.call(this, location).catch(error=error) $router和$route的区别 $router 包含当前路由 包含整个路由的属性和方法 $route 仅包含当前路由对象 导航守卫 全局守卫 beforeEach 路由进入之前 afterEach 路由进入之后 路由独享守卫 beforeEnter 路由进入之前 path:/about, name:about, beforeEnter:function(to,from,next) if(true) next() else next(/login) 组件内守卫 beforeRouteEnter 路由进入之前 beforeRouteUpdate 路由更新之前 beforeRouteLeave 路由离开之前 使用场景：一些只有在用户登录之后才能开发的页面，或者是需要对用户身份进行划分的组件 介绍一下SPA以及SPA有什么缺点SPA：单页面应用 缺点： SEO优化不好 性能不是特别好 router跳转和a标签跳转区别 a标签跳转回重新从服务器端请求资源，耗流量、耗性能 spa单页路由模式，router跳转只是加载中间的html代码，不会请求资源 api$set $set(target,key,value) // [1,2,3]变为[1,5,3]// this.arr[1] = 5this.$set(this.arr, 1, 5) $nextTick 传入的回调函数会被异步执行 常用于执行组件渲染后的操作 是微任务，因为使用Promise.resolve实现 class Vue $nextTick(callback) return Promise.resolve().then(()= callback() ) $refs获取dom $el获取当前组件的根节点 $data获取当前组件data数据 $children获取当前组件的所有子组件（数组格式） $parent 找到当前组件的父组件，如果找不到就返回自身 $root获取根组件 data定义数据data() this.num = 222 return str:111 使用this.xxx定义的数据，没有getter和setter劫持处理，单独修改时数据不会刷新 computed计算属性computed计算的值可以被修改吗（包括v-model双向绑定）？ 可以，通过get和set changeStr: get() return this.sre.slice(-2) , set(val) this.sre = val watch watch的初始化监听 加上配置项：immediate:true 深度监听 deep:true methods、computed、watch区别 computed有缓存机制 当参与计算的值被改变时，计算属性会监听到并进行返回 methods没有缓存机制 watch 监听数据路由的变化 监听对象发生改变时，会执行 指令如何自定义指令vue单项绑定v-if和v-show的区别 v-if 添加删除dom节点 一般用于显隐切换不频繁的渲染节点 v-show 使用display:none对元素进行显隐控制 一般用于显隐切换频繁的渲染节点 v-if和v-for优先级答： vue2中：v-for优先级高，这是vue的源码决定的 vue3中：v-if优先级高 原理$nextTick原理v-model双向绑定原理scoped原理给元素节点新增自定义属性： div data-v-xxxx class=hello-boxHello/divstyle.hello-box[data-v-xxxx] background:red/style 样式穿透 scssstylus中的样式穿透： 方式1：父元素 deep 子元素 方式2：父元素 子元素 render函数 render函数支持用js语言来构建dom vue是虚拟dom，拿到template模版也会转译成vnode函数 使用render构建dom，就直接省去了转译的过程 使用render时，使用h函数构建虚拟dom axios二次封装vue3相关vue2和vue3区别 双向绑定机制不同 vue2：Object.defineProperty() 使用循环对data返回的对象进行遍历，定义get和set 后添加的属性是劫持不到的 有些情况下需要使用$set进行数据刷新 vue3：new Proxy() 使用new Proxy对响应式数据进行包裹 既不需要循环遍历，后添加的属性也可以被劫持到 不需要$set刷新 // vue2 双向绑定原理let data = a:1, b:2let vue = for(let key in data) Object.defineProperty(vue, key, get() console.log(数据被获取) return data[key] , set(value) console.log(数据被设置) data[key] = value ) // vue3 双向绑定原理let data = a:1, b:2const vue = new Proxy(data, get(target, propKey, receiver) console.log(数据被获取) return Relect.get(targte, propKey, receiver) , set(target, propKey, value, receiver) console.log(数据被设置) return Reflect.set(target, propKey, value, receiver) ) vue2是选项式API，vue3可以向下兼容，也可以是组合式api或者是setup语法糖的形式 v-if和v-for的优先级不同了 ref和$children也不同 vue3使用Tree-shaking 打包时会对没有用到的api进行剔除，这样bundle的体积更小 创建app实例由new Vue()变为createApp suspense允许程序在等待异步组件时渲染一些后备内容 一步组件使用defineAsyncComponent进行加载 vue3使用setup怎么组织代码答：可以使用hooks对复用逻辑进行封装 也就是组合式函数，用来封装和服用逻辑的函数： import ref from vuefunction useSameLogic() let xxx = ref(123) return xxxexport default useSameLogic vue3使用setup写如何获取类似vue2中的thislet proxy = getCurrentInstance() vue3常用api有哪些createApp 创建一个应用实例 相当于Vue2的new Vue() 使用场景：写插件封装全局组件时会使用 provideinject 依赖注入，跨辈传值 父组件传值到后代组件，跨越多个层级 不好维护和查询数据来源 directive 自定义指令 使用场景：后台管理系统中的按钮权限控制，根据用户角色决定按钮操作权限 mixin 全局混入 可以添加生命周期，在小程序的分享功能会用到 不好维护和查询数据来源 app.config.globalProperties 获取vue这个全局对象的属性和方法 自己封装插件的时候需要把方法添加到对象中 nextTick 等待下一次Dom更新刷新的工具方法 返回一个Promise，回调函数参数异步执行 computed 计算属性 可以缓存返回结果 reactive、ref 来定义数据和vue2的data类似 watch 监听（vue3不需要深度监听） markRaw() 静态数据，不被new Proxy代理 defineProps() setup形式的组件，父组件传递的值，子组件需要使用defineProps接收 defineEmits() setup形式的组件，自定义事件需要使用defineEmits slot 分为匿名、具名、作用域 后台管理项目，主内容部分根据菜单的选择进行切换，这时可以使用slot插槽 介绍一下vue3常见的响应式数据类型 ref 定义基本类型 const abc = ref(10)console.log(abc.value) reactive 定义引用类型 const data = reactive( name:123, age:23)console.log(data.name) toRef 对reactive对象进行单个值解构处理 const name = toRef(data,name) toRefs 对reactive对象进行全部解构处理 const name, age = toRefs(data) 介绍一下teleport组件及其使用场景使用场景：希望指定组件渲染到根组件下，和app元素同级的位置（如弹窗） teleport to=body divHello/div/teleport 介绍watch和watchEffect的区别 watch 除非配置immediate，否则只有监听值发生变化才会执行 需要传递监听对象 能获取到更改前后的值 监听明确数据 watchEffect 会立即执行 只需要传递回调函数 无法获取更改前的值 监听能访问到的所有响应式属性 介绍vue2和vue3中watch的区别 vue3 watch简化了语法，与setup函数结合更加紧密 watch作为函数调用 能够监听对象的子属性，能通过数组组合监听 vue2 watch作为一个模块，在其中定义相应的监听事件 vue3生命周期 setup 相当于vue2中的beforeCreate、created onBeforeMount onMounted onBeforeUpdate onUpdated onBeforeUnmount onUnmounted onActivated onDeactivated onErrorCaptured 项目开发相关什么是渐进式框架vuejs只是一个核心库，可以通过补充插件的方式将应用规模化，比如通过补充vue-router实现路由跳转，补充vuex实现状态集中管理等。 vue如何设置代理答：vue.config.js，仅在开发环境下有效 module.exports = devServer: proxy:http://localhost:4000 打包路径和路由模式（vue项目打包完之后出现空白页，如何解决）答： 关于路径：打包之后，资源默认根路径为绝对路径，需要修改为相对路径： module.exports = publicPath:./ 关于路由模式 需要修改为hash模式，由前端控制路由跳转 关于模式和环境变量 开发环境 .env.development 生产环境 .env.production 什么是MVVM Model 数据 View 界面中展示的内容 View-Model 视图和数据的交互，也就是vue源码实现的功能 vue源码模板解析div id=app h1str/h1 str/divscript type=text/javascript new Vue( el:#app, data: str:hello )/script class Vue constructor(options) this.$data = options.data this.$el = document.querySelector(options.el) this.compile(this.$el) compile(node) node.childNodes.forEach((item,index)= // 元素节点 if(item.nodeType == 1) this.compile(item) // 文本节点 if(item.nodeType == 3) let reg = /\\\\(.*?)\\]|/g let text = item.textContent item.textContent = text.replace(reg,(match, vmKey)= vmKey = vmKey.trim() // 返回data上的数据 return this.$data[vmKey] ) ) 生命周期div id=app h1str/h1 str/divscript type=text/javascript new Vue( el:#app, data: str:hello , beforeCreate(), created(), beforeMount(), mounted(), )/script class Vue constructor(options) if(typeof options.beforeCreate == function) options.beforeCreate.bind(this)() this.$data = options.data if(typeof options.created == function) options.created.bind(this)() if(typeof options.beforeMount == function) options.beforeMount.bind(this)() this.$el = document.querySelector(options.el) this.compile(this.$el) if(typeof options.mounted == function) options.mounted.bind(this)() 添加事件div id=app button @click=handleClickbtn/button/divscript type=text/javascript new Vue( el:#app, data:, methods: handleClick() )/script class Vue constructor(options) this.options = options this.$data = options.data this.$el = document.querySelector(options.el) this.compile(this.$el) compile(node) if(item.nodeType == 1) if(item.hasAttribute(@click)) const event = item.getAttribute(@click).trim() item.addEventListener(click,()= this.options.method[event]() ) data劫持 vue大对象属性来自于data中 data中属性与vue大对象属性保持双向（劫持） div id=app button @click=handleClickstr/button/divscript type=text/javascript new Vue( el:#app, data: str:hello , methods: handleClick() console.log(this.str) )/script class Vue constructor(options) this.options = options this.$data = options.data this.proxyData() this.$el = document.querySelector(options.el) this.compile(this.$el) proxyData() for(let key in this.$data) Object.defineProperties(this,key, get() return this.$data[key] , set(value) this.$data[key] = value ) 更新视图 通过一个监听表来存储对数据进行订阅的视图元素 // 监听对象类型class Watch constructor(vm, key, node, attr) // 对象 this.vm = vm // 属性名称 this.key = key // 节点 this.node = node // 字符串 this.attr = attr update() this.node[this.attr] = this.vm[this.key] class Vue observer() for(let key in this.$data) let value = this.$data[key] let thiat = this Object.defineProperty(this.$data,key, get() return value , set(value) value = val // 更新每个订阅器 if(that.$watchEvent[key]) that.$watchEvent[key].forEach(item= item.update() ) ) v-model双向绑定原理 通过Object.defineProperty劫持数据发生的改变 set中数据被改变，触发对数据进行监听的节点的update方法更新节点内容 在上面对vue模版进行解析的方法里，继续判断是否存在v-model属性： class Vue compile() if(item.hasAttribute(v-model)) let vmKey = item.getAttribute(v-model) if(this.hasOwnProperty(vmKey)) item.value = this[vmKey] item.addEventListener(input,(event)= this[vmKey] = item.value ) diff算法 功能：提升性能 虚拟dom：把dom数据化 通过h函数传入到vnode生成的数据结构 snabbdom 虚拟节点操作库 通过数据（虚拟dom）来操作dom /** 创建一个虚拟节点 children: undefined, data:, elm:h1, key: undefined, sel:h1, text:你好h1 对应的真实节点： h1你好h1/h1**/const vnode = h(h1,,你好h1) 节点替换规则： 没有用key进行标识的节点，每次都要删除后重新创建 即便是用key进行过标识，节点类型也需要相同 不能越级比较 手写生成虚拟dom的h函数h函数（生成vnode对象）： /** * h(h1,,你好h1) * @param sel 标签类型 * @param data 数据 * @param params */export default function(sel, data, params) if( typeof params == string ) return vnode(sel, data, undefined,params,undefined) else if(Array.isArray(params)) // 存在子元素 let children = [] for(let item of params) children.push(item) return vnode(sle,data,children,undefined,undefined) 手写patch调用形式： patch(oldVNode, newVNode) patch执行之前，必须确保2个节点都是虚拟节点 如果旧节点不是虚拟节点，需要重新创建虚拟节点 判断新旧虚拟节点是同一个节点 如果不是，则暴力替换 判断新节点内容是文本还是子节点（不是同一个节点） 是文本，直接替换为文本内容 判断旧节点内容是文本还是子节点（新节点内容是子节点） 是文本，直接替换为新节点的子节点 非文本，需要使用diff核心算法 export default function(oldVnode, newVnode) if(oldVnode.sel == undefined) // oldVnode不是虚拟节点时 oldVnode = vnode( oldVode.tagName.toLowerCase(), ,[],undefined,oldVnode ) if(oldVnode.sel === newVnode.sel) // 新旧虚拟节点是同一个节点 if(newVnode.children === undefined) // 新节点没有children if(newVnode.text !== oldVnode.text) // 文本不同时，仅替换文本 oldVnode.elm.innerText = newVnode.text else // 新节点有children if(oldVnode.children !== undefined) // 旧节点有children else // 旧节点没有children oldVnode.elm.innerHTML = for(let child of newVnode.children) let childDom = createElement(child) oldVnode.elm.appendChild(childDom) else // 不是同一个节点，暴力替换，删除旧节点，创建插入新节点 // 创建新节点 let newVnodeElm = createElement(newVnode) // 插入新节点 oldVnode.elm.parentNode.insert(newVnode) // 删除旧节点 oldVnode.elm.parentNode.removeChild() diff算法 diff算法是个深度优先算法 当patch中，需要对新旧元素的子节点进行比较替换时，就需要使用到核心diff算法，diff算法首先在新旧节点数组头尾处分别设置指针，然后按照下面顺序进行比较： 旧节点头指针和新节点头指针元素比较 如果匹配，新旧头指针后移 新旧尾指针比较 如果匹配，新旧尾指针前移 旧头指针和新尾指针比较 如果匹配，旧头指针后移，新尾指针前移 旧尾指针和新头指针比较 如果匹配，旧尾指针前移，新头指针后移 以上都不满足，进行查找 创建或删除 掘金回答 原贴首先，我们拿到新旧节点的数组，然后初始化四个指针，分别指向新旧节点的开始位置和结束位置， 进行两两对比，若是 新的开始节点和旧开始节点相同，则都向后面移动，若是结尾节点相匹配，则都前移指针。若是新开始节点和旧结尾节点匹配上了，则会将旧的结束节点移动到旧的开始节点前。若是旧开始节点和新的结束节点相匹配，则会将旧开始节点移动到旧结束节点的后面。若是上述节点都没配有匹配上，则会进行一个兜底逻辑的判断，判断开始节点是否在旧节点中，若是存在则复用，若是不存在则创建。最终跳出循环，进行裁剪或者新增，若是旧的开始节点小于旧的结束节点，则会删除之间的节点，反之则是新增新的开始节点到新的结束节点。"},{"title":"uniapp","path":"/wiki/Job/front_03_uniapp.html","content":"uniapp谈谈uni-app的理解一个使用vuejs开发的前端应用框架，开发者只要编写一套代码，就可以发布到IOS、Android、Web、小程序等平台 uniapp如何为不同平台设置不同代码使用条件注释：###ifdef ###ifndef uniapp中封装接口请求相较于微信小程序有什么要注意的uniapp和微信小程序都提供了网络请求apiuniapp为了实现夸端兼容，需要注意网络请求跨域问题微信小程序不会出现跨域问题uniapp的跨域问题可以通过在vue.config.js中配置proxy代理解决 uniapp中的生命周期应用生命周期onLaunch 初始化完成时触发，只触发一次onShow uniapp从后台进入前台时显示onHide uniapp从前台进入后台显示onError 报错onExit 监听应用退出onUNiNViewMessage 对nvue页面发送的数据进行监听onUnhandleRejection 对未处理的Promise拒绝事件监听函数onPageNotFound 页面未找到onThemeChange 监听系统主题页面生命周期onInit 监听页面初始化onLoad 监听页面加载，参数为上个页面传递的数据onShow 监听页面显示onReady 监听页面初次渲染onHide 监听页面隐藏onUnload 监听页面隐藏onResize 监听窗口尺寸变化onPullDownRefresh 监听用户下拉动作onReachBottom 监听页面滚动到底部onPageScroll 监听页面滚动组件生命周期beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestroydestroyed uniapp的配置文件部分 uniCloud 云空间目录 componnets 组件目录 hybrid App端存放本地html文件的目录 platforms 存放各平台专用页面的目录 pages 业务页面存放目录 static 本地静态资源 uni_modules 存放uni_modules的规范插件 wxcompnents 存放小程序组件的目录 main.js vue初始化入口文件 App.vue 配置全局样式及监听 manifest.json 配置应用名称，appid、logo、版本等打包信息 page.json 配置页面路由，导航条，选项卡等页面类信息 uni.scss uni-app内置的常用样式变量 uniapp中的本地缓存 同步存储 uni.setStorageSync uni.getStorageSync 异步存储 uni.setStorage uni.getStorage uni-app路由与跳转 uni.navigateTo 跳转页面 uni.redirect 销毁当前页面跳转到指定页面 uni.switchTab 跳转至tab页面 uni.reLaunch 销毁所有页面跳转至指定页面 uni.navigateBack 返回上一页 exit 推出小程序，target”miniProgram”时生效 uniapp中，如何使用原生SDK以及插件 可以通过uni-app plus的方式来集成原生SDK和插件 实现的具体方法是：在manifest.json文件中添加对应的插件设置 并在代码中调用相关API使用内置的SDK和插 微信小程序小程序如何实现支付以公司身份注册一个小程序绑定商户号小程序填写合法域wx.login()code调用wx.requestPayment 小程序调用微信接口服务 wx.login获取codewx.request发送code通过appid、appsecret、code校验接口获取到返回的session_key和openId等自定义登录态，与openid、session_key关联返回自定义登录态自定义登录态存入storagewx.request发起业务请求，携带自定义登录态通过自定义登录态查询openid和session_key返回业务数据"},{"title":"react","path":"/wiki/Job/front_04_react.html","content":"React特性react有什么特点 使用虚拟dom 可以进行服务器端渲染 遵循单向数据流或数据绑定 受控组件和非受控组件有什么区别？受控组件：只能通过React修改数据或状态的组件非受控组件：如input、textarea、select等表单组件控件自身就能控制数据和状态 React 组件中绑定一个事件跟直接操作 DOM 绑定一个事件有什么差别参考博客 绑定方式不同React使用事件委托机制，将所有事件监听器挂载在根节点或顶层的容器上，通过事件冒泡捕获事件只有一个事件处理器负责监听由React自行分发事件并调用相对应的事件处理逻辑Dom的事件监听器直接绑定到特定的dom元素上对多个元素绑定事件，系统会创建多个独立的监听器性能不同React：减少事件监听器，更节省内存原生dom：内存消耗较高事件对象React：合成事件对象dom：原生事件对象跨平台与兼容性React：跨平台统一接口dom：仅限web浏览器生命周期管理react：自动清理事件dom：需要手动清理事件优先级react：高优先级事件可以优先处理dom：按事件触发顺序逐一处理 组件的生命周期方法有哪些？constructor 初始化状态和绑定事件处理程序在函数组件中，可以将useState钩子用于类似的目的render负责渲染jsx标记并返回要在屏幕上显示的内容componentDidMount组件在Dom中渲染后立即执行此方法常用于初始化任务componentDidUpdate当组件的props或state改变时调用此方法允许执行副作用componentWillUnmount组件从dom中删除之前，调用此方法用于清除事件侦听器或者取消计时器等操作 React性能优化React源码React Hook常用的React Hook有哪些？ useState 管理组件状态 useEffect 执行组件副作用，比如获取数据或者订阅事件 useContext 获取组件上下文值 useRef 获取组件dom实体 useCallback 对函数缓存，防止不必要的重新渲染 useMemo 对值缓存，防止不必要的重新渲染 useReducer 通过reducer函数管理状态，类似于Redux工作原理 useLayoutEffect 对useCallback、useMemo这2个hook的立即，有什么样的区别，适合在什么样的场景下使用参考博客 是不是所有变量或函数都需要用到这两个hook进行包裹 不是所有变量或函数都需要使用这两个hook进行包裹，它们的作用主要是优化性能，主要针对那些性能损耗的计算或函数，没有损耗的变量或者函数是不需要包裹 包裹后性能一定会好吗？ 不一定，取决于具体情况useCallback用于缓存函数，避免每次渲染都创建新的函数实例当函数被父组件作为参数传递到子组件时，函数实例的重新创建会触发子组件重新渲染useCallback可以确保相同的函数实例在相同的依赖项下保持不变useMemo用于缓存值，避免每次渲染都重新计算在依赖项不变的情况下，返回值的缓存结果，避免重复计算，提高了性能无需使用useMemo和useCallback的情况：依赖频繁变化值或函数轻量且不频繁变化组件不会频繁重渲染计算量本身较小 有没有更底层一点的理解？ 更底层的理解是，useCallback 和 useMemo 的原理都是基于 memoization（记忆化）技术。它们在渲染过程中会根据依赖项的变化，判断是否重新计算函数或值。当依赖项不变时，会直接返回缓存的结果，从而避免了不必要的重复计算，提高了性能。 ReduxReact-Router"},{"title":"面试技巧","path":"/wiki/Job/front_05_trick.html","content":"面试准备如何准备好前端面试，如何记忆庞大的前端面试题库？ 理解原理 建立知识体系 笔记整理 实战演练 模拟练市 持续迭代 归纳总结 心理建设，更看重思路技巧 自我介绍（业务技术面）面试官你好，我叫XXX，XX年毕业于XXX计算机专业，有3年前端开发经验，熟练掌握vue、react等主流框架，并且在PC端、移动端和桌面应用开发中积累了不少项目经验，涉及可视化、2d3d交互、数据分析、后台管理等领域。在过去的工作中，我参与了多个从0到1的项目开发。其中，有像【高轨卫星轨道监控系统】这类复杂交互可视化软件，也有【徐矿集团人才中心一体化】这类比较大型的项目，最近做的项目是一款社交媒体类App的开发，我主要负责后台系统和h5小游戏个人优势是能够将数据分析和可视化相结合，为用户提供更好的交互体验我平时会有维护技术博客的习惯，是我自我学习的一种方式，能让我不断地总结和分享经验，非常期待能够加入贵公司，在优秀的团队中继续提升自己，谢谢 HR问题自我介绍自我介绍公式 参考文章自身背景项目与岗位的匹配度选择公司的原因 面试官你好，我叫XX，XX年毕业于XXX大学计算机专业，有3年前端开发经验，在过去的工作中，我主要负责PC端、移动端和桌面应用的前端开发，参与了多个从0到1的项目，积累了丰富的项目开发和团队协作经验。平时有书写技术博客的习惯，是我自我学习、和团队分享经验的一种方式我的上一份工作是参与一款社交媒体类交友App的开发，主要负责后台系统，App端3d交互、h5小游戏的开发对我个人影响最深的，是在北京国遥任职webgis前端工程师的经历，在这段期间，我跟着前辈学习了一些图形学基础与3d技术，发现了自己对web3d与可视化方面的兴趣之后在广联科技主要负责公司内可视化项目的组织和开发我了解到咱们公司主要是做家具行业软件的，并且产品的口碑都相当不错，在web3d软件开发方面也是国内比较成熟的，所以非常希望能够加入贵公司，在优秀的团队中提升自己，我的自我介绍结束，谢谢 离职原因 年轻外地公司： 出于个人职业规划考虑，因为当时公司节奏比较慢，觉得应该追求更具挑战的项目 看到了新的机会，可以接触到更前沿的技术和业务领域 本地传统公司： 工作地点搬迁，由软件园搬到了xx安全谷 原本在外地工作，因为家庭原因需要回到XX本地工作 通用： 公司团队解散 需要安排长期异地出差，个人不太能接收大幅度长期的工作地点调动 项目相关可以介绍一下【高轨卫星态势】这个项目吗答：这个项目主要是面向航天指挥部门开发的一套军工软件我在其中主要负责的是2d高轨卫星地图系统的开发需要将后台实时推送的卫星轨迹，返显到2d地图上，系统会根据这些轨迹，推算出可能发生的意外情况：比如会面卫星碰撞、卫星变轨，并且进行预警，指挥员需要根据预警进行3d仿真，上报等一系列应急操作这个项目使用Vue框架进行搭建、可视化地图使用ECarts渲染，3D交互使用Cesium实现，与后端和桌面端的联动使用Websocket实现开发周期半年左右 可以介绍一下【徐矿集团人才中心一体化解决方案】这个项目吗这个项目主要是为徐矿集团培训安全生产人员服务的培训类型多种多样，比如有重工业机器操作、电气操作、煤矿挖掘主要分为多个系统首先有一个面向学员的门户网站（react），用于介绍课程相关信息，以及集团新闻然后App端主要是面向学员的，支持线上教学、模拟答题、教师联系、考试报名缴费等功能考试系统，则是考试时使用的机器，有一套考试界面，对用户进行视频监控通过人脸比对，确保用户不会作弊后台系统，面向几个主要角色：管理员、教师管理员负责系统数据监控、新闻发布、数据清理等基本工作教师负责课程管理、班级管理被赋予线上考官身份的教师，还可以通过系统监控考试情况，防止考生作弊最后还有展示用的可视化大屏，对教学数据进行统计展示。 实际开发中遇到了哪些技术挑战或者困难呀？在徐州广联科技公司时，我是可视化开发组的负责人，当时公司里有一个监控大屏项目，在即将上线时，发现了一个比较严重的bug由于大屏页面需要同时展示8个实时监控但是实际效果是8个监控只能显示6个我和团队交流后，一开始以为是浏览器性能的原因后面控制台调试过之后，通过监控network面板，发现当前8个网络请求发出之后，后面2个请求总是被置空通过实际调试和资料收集之后，最终这是由于浏览器只允许6个异步请求并行发出，是网络协议的一种规则监控视频是持续的数据流，会长时间的占用一个请求通道那么要解决这个问题，就需要将http升级到http2.0，这样就没有并行通道数的限制了找到这个解决方案后我们就立刻执行了，赶在服务上线之前解决了这个问题之前因为公司也遇到过6路以上的监控出现bug，但当时没有从技术层面解决这个问题从这之后，经过和技术团队的讨论，我们认为以后的项目尽量使用http2.0，提高网络性能 如何对学员的信息安全和数据进行保护自动排课系统，是基于什么算法或者规则来运作的呢？开放性问题价值观：贴近公司文化、正直稳定性技术深耕职业规划潜力学习能力发展潜力专业性性价比工作热情和能力个人价值回答要有条理，有逻辑，忌说罗圈话用1、2、3点首先、其次、最后 你的职业规划是什么我的职业规划是成为资深的web3d工程师短期内：首先我们的项目是基于vue层构建的，并且使用的是面向对象编程模式那么我就需要花半个月左右的时间去研究vue底层实现原理和面向对象编程模式然后我们web3d使用的技术栈主要是babylonjs那么我比较熟悉的3d库是threejs，这两个技术栈比较相似我需要花1个月左右的时间去学习babylonjs其次web3d开发对图形学算法方面的要求很高这方面的学习也是最困难的，需要我花上半年的时间去上网自学、阅读这方面的相关书籍和源码长期内：能够在3年内全面的掌握web3d开发相关的技术能够在5年内，成为web软件性能、优化、3d交互方面的技术专家并且在未来能实时关注3d技术的发展方向，不断地学习 如何回答 使用具体的时间点，比如几年内的职业规划技术层面深耕xxx时间点可以掌握xx技术到xxx层面xx时间点可以达到xx技术水平为公司作出更大贡献我的职业计划是成为资深的高级前端开发工程师，短期内：首先我最大的兴趣点在于前端可视化领域（1年）为此需要继续学习webgl、canvas、svg等前端图形技术、以及一些图形学的基本算法然后呢为了提高用户的使用体验依旧需要花2个月的时间，学习js这门语言的深入原理花半年时间深入了解计算机网络的相关原理，希望能更清晰地认识http协议需要半年的时间去了解人工智能相关知识python语言的基础我是有的人工智能是目前计算机领域的一个趋势，我认为花时间去了解这门技术是比较有必要的长期内：（3年内）能够独立负责一款复杂软件的前端开发（5年内）成为web软件性能、优化、交互方面的技术专家 你还有什么想要了解的吗？ 可以讲讲这个岗位的机会跟挑战有哪些吗？ 这个岗位对员工的期待是什么呢？期待招一个什么样子的人呢？ 可以再详细介绍一下这个岗位的具体职责吗？ 可以介绍一下公司的团队组成吗 就前端而言用到的技术栈是哪些呢 试用期多长 岗位稳定性如何 工作到现在，项目中遇到的最难的问题（挑战）是什么？如何解决？在参与【项目管理协同表格编辑系统】桌面软件开发的时候，需要实现这样一个功能： 需要支持excel表格导入软件，解析成统一的内部模版 但是用户导入的表格无法统一格式 因为这份业务表格，不同省份有不同的标准 还有可能存在表格行列合并的格式不同、表头标记不同等情况 所以需要对几种不同的数据标准进行解析，从中提取有效的数据，输出为统一格式的数据 当时的解决方案是： 先使用sheetjs库将excel中的数据统一读入 分析各个省份不同的标准，写出一份解析的算法，能够对数据进行解析，花了一周的时间，才将各种情况进行兼容 当然，考虑到复杂性和政策的变化性，现在如果再实现这个功能，训练ai进行解析的可实现性应该更高一些 你收获到最多的一次经历是什么？在北京国遥工作的时候，做的第一个项目，一个知识图谱功能模块，是项目中最复杂的亮点模块，在分工会议时，我自告奋勇要做这个模块，拿到模块之后，非常兴奋，当时非常认真的在做这块内容，也向前辈请教了很多知识，最终把这个模块开发完成，客户对此的反馈很好，个人非常有成就感，对可视化技术的兴趣加深了很多 你在过去的工作中，最喜欢做什么，最不喜欢做什么？你认为自己最擅长的技能是什么？举例说明你是如何处理与同事之间的冲突的，青分享一次具体的经历你最近与团队合作完成的一个重要项目是什么？你在其中扮演了什么样的角色你最大的缺点是什么？优点是什么你最近失败的一件事是什么？你有没有分析过失败的原因？有复盘过吗？行为事件类项目类问题介绍一个你觉得很成功很失败感受很深刻耗时最久的项目经历STAR法则 situation 情境task 任务action 行动result 结果例子：背景和任务：我在XXX期间，所负责XX项目遇到了一个XX问题信息收集：在处理问题之前，首先我们需要了解是什么原因造成这种情况的发生行动1：于是我做了XXX措施，与团队内人员进行交流，我负责的是XXX部分结果1：调查到导致问题的原因是XXX行动2：于是我们团队采取了XX措施，从XX部分做了工作结果2：最终在XX期间实现了XXX目标，解决了XX问题 JD业务问题SaaSSaaS系统：软件即服务（Software as a Service）通过互联网提供软件应用的服务平台，通过订阅的方式获得对云端软件的访问权限，SaaS平台提供商负责软件的部署、维护和安全性等方面的工作 CRM客户关系管理系统主要功能客户管理销售过程推进售后管理 BIMBuilding Information Modeling建筑信息模型通过3d数字化技术，把建筑工程中各专业、各阶段与工程相关的信息纳入数据模型之中通过BIM软件进行建模、分析、模拟、演示、检测等对工程的进度、成本、质量进行管控 面试结束追问面试结果很高兴在上周二能参加贵公司的面试，与面试官沟通过后我对岗位有了更深的认识，我自己也是非常感兴趣的，方便问一下岗位招聘这几天陆续收到了2家公司给我的offer，要我在这周进行答复，但我对咱们公司还是非常感兴趣的，所以一直在等您这边的回复"},{"title":"git","path":"/wiki/Job/front_06_git.html","content":"git常用命令有哪些参考博客"},{"title":"2025/02/07 鹧鸪云","path":"/wiki/Job/log_01_20250207_ZheGuYun.html","content":"面试公司：徐州鹧鸪云 面试岗位：前端工程师 面试时间：2025020711:00 面试时长：20分钟左右 面试体验：一般 如何看待加班，上家公司忙吗？上个项目的团队规模多大？答： 合理加班没有问题，完全可以接收， 上家公司工作节奏不是很快，赶版本节点的时候比较忙，平时不忙 团队规模不大，2个移动端，3个后端，2个测试，1个web前端，1个ui 介绍一下你在上一个公司做的项目答： 一款自研社交媒体类交友APP 问：这个项目中你用到了哪些技术栈答： 我做的主要是后台管理部分，使用的是若依框架，技术栈是ts+vue3 使用到cocos制作App端的h5小游戏 使用Echarts、threejs制作App端的可视化图表h5静态页面问：你是如何实现直播功能的答： 直播功能主要是App端实现的，对接的是融云的SDK问：所以你是没有参与直播功能的开发了？ 我主要负责开发审核员在后台对直播进行审核的部分 有开发过微信小程序吗？答： 在公司中有维护微信小程序项目的经验，但从0-1开发微信小程序项目是没有的 当时使用的是uniapp框架进行开发的 问：那移动端项目中，如何获取到用户的手机号码答：不太清楚呢 补充回答： 获取用户手机号需要提交商家信息 必须是企业账号才能有权限获取用户手机号码，需要appid和小程序密钥 通过uni.login()获取到用户的code值 获取到code值后调用uni.request()请求微信服务器，拿到用户的session_key值 通过微信提供的方法：getPhoneNumber拿到encryptedData、iv 所有值都拿到之后，通过微信提供的解密方案WXBizDataCrypt，拿到最终手机号 用过websocket吗，使用场景是什么答： 卫星2d轨迹项目中使用过呢，因为需要后台实时推送卫星轨迹数据到页面上 卫星2d轨迹页面和3d桌面qt软件之间的交互，也是使用websocket进行传递的问：仔细介绍一下这个项目答： 一个能够实时监听卫星轨迹的2d可视化地图，与3d桌面软件进行联合仿真 能够通过监听卫星的位置，仿真模拟卫星碰撞、变轨等事件问：那这个3d部分是用什么技术实现的呢？答：c++的Qt写的桌面软件问：所以不是你做的是吗？答：是的，不是问：有用过wss吗，就是一个和websocket和ssl相关的协议答：不是很清楚呢 补答：ws和wss协议都是webSocket协议，但是ws是非安全协议，wss是安全协议，相当于http和https的差别，ws不需要证书，wss需要ssl整数ws：TCP + WSwss： TCP + TLS + WS 3d相关的技术只用过threejs吗答： 基本上threejs用的比较多 地图相关的项目有用过Cesium库 对WebGL的3D渲染也有了解 总结 面试官没怎么问技术问题，基本都是和项目相关的问题"},{"title":"js","path":"/wiki/Job/front_02_js.html","content":"2024前段高频面试题数据类型1.js基本数据类型以及它们的区别javascript共有8种数据类型原始数据类型undefinednullbooleannumberstringsymbolbigint引用数据类型（对象、数组、函数）objectsymbol和bigintsymbol和bigint都是es6新增的数据类型symbol代表创建后独一无二且不可变的数据类型主要为了解决可能出现的全局变量冲突问题bigint可以用来表示任意精度格式的整数可以安全的存储和操作大整数原始数据类型和引用数据类型的区别是什么？区别是：存放的位置不同原始数据类型直接存放在栈（stack）中占据空间小，大小稳定，需要频繁使用引用数据类型存放在堆（heap）中占据空间大，大小不稳定在栈中存储指针，指针指向堆中该实体的起始地址解释器首先寻找栈中存放的地址，再从堆中获得实体栈和堆的区别是什么？操作系统中，内存被分为堆区和栈区栈中数据为先进后出内存由编译器自动分配释放堆是一个优先队列，按照优先级进行排序，优先级可以按照大小来规定一般由开发者分配释放 2.数据类型检测的方式有哪些typeof判断null数组对象类型时，结果都会是objectinstanceof机制：判断在原型链中是否能找到该类型的原型可以用来测试对象原型链中是否存在指定的prototype属性仅对引用类型有效，无法判断原始数据类型constructor可以使用constructor来判断数据类型，但是如果修改对象的原型就行不通了Object.prototype.toString.call()可以获取属性类型名称字符串问：为什么obj.toString()和Object.prototype.toString()的返回值不一样答：因为后者调用的时Object的原型方法，而使用实例进行调用，toString方法都被重写了 数组3.判断数组的方式有哪些Array.isArray(obj)obj.proto Array.prototypeObject.prototype.toString().call(obj).slice(8,-1) ‘Array’obj instanceof ArrayArray.prototype.isPrototypeOf(obj) 9.数组有哪些原生方法toStringjoin，将数组元素连接成字符串pushpopshiftunshiftreversesort 回调函数返回值为整数时，交换两个参数的位置concat，不影响原数组slice，不影响原数组splice，影响原数组indexOf、lastIndexOfeverysomefilterforEachreducereduceRight 11.数组的遍历方法有哪些forEachmapfilterfor…of返回数组元素对象的属性值everysomefindfindIndexreducereduceRight 12.forEach和map的区别都是用来遍历数组的forEach主要是针对每一个元素执行提供的函数，返回值没有意义map会根据回调函数的返回值得到一个新的数组 语法特性4.请简述JavaScript中的thisthis指向当前执行上下文中的对象调用模式函数调用模式：全局定义函数直接被调用，this指向全局对象方法调用模式：函数作为对象的方法被调用，this指向对象构造器调用模式：函数作为构造器被new调用，执行前会新建一个对象，this指向对象apply、call、bind：可以指定this的指向apply：传入2个参数参数1：this绑定对象参数2：其它参数（数组格式）call：参数1：this绑定对象其它参数（必须逐个例句出来）bind参数1：this指向返回值：新函数调用模式优先级：构造器 applybindcall 方法 函数 箭头函数和普通函数的区别 箭头函数的写法更加简洁 箭头函数的this指向函数定义的上下文 箭头函数继承的this指向不会改变 箭头函数不能作为构造函数使用 箭头函数没有自己arguments对象 箭头函数没有prototype 箭头函数不能用作generator函数，不能使用yield关键字 5.AMD和CommonJs的区别都是实现模块化的方式Commonjs同步加载，由于运行在服务器端，从本地磁盘读取数据，速度很快更适合服务器，nodejs使用commonjsmoduleexportsrequireglobalmodule.exports输出，require加载AMDrequire.js异步方式加载模块，模块加载不影响后面语句运行更适合浏览器使用require.config()指定引用路径define()定义模块，require()加载模块 6.ES6模块与CommonJs模块有什么异同两者都能对引入的对象的内部属性值进行改变ES6模块语法简单，适用浏览器和服务器export导出，import导入是对模块的引用，模块本身指向不能改变commonjs是对模块的浅拷贝模块本身可以被重新赋值 7.let、const、var的区别块级作用域let、const具有块级作用域，var没有块级作用域使用花括号包裹，用于解决2个问题：内层变量可能覆盖外层变量用来计数的循环变量泄露为全局变量变量提升变量只能在声明后使用，否则会报错var存在变量提升letconst不存在变量提升全局添加属性浏览器全局变量：window，Node全局变量globalvar声明变量会成为全局对象的属性let和const不会重复声明var可以重复声明，后声明的变量会覆盖前声明的const、let不允许重复声明暂时性死区letconst声明之前无法使用初始值设置varlet可以不设置初始值const必须设置初始值指针指向letvar创建的变量都可以更改指针指向const不能 10.for in 和 for of的区别for_of遍历对象的键值，遍历数组元素值只遍历当前对象上的属性for_in遍历对象的键名，遍历数组索引会遍历对象的整个原型链，性能比较差 23、ES6有哪些新特性箭头函数解构赋值模版字符串promisesymbol，用于创建一个独一无二的值，不能与其他数据类型进行运算letconst模块化（importexport）for..of循环刻碟带对象扩展运算符…MapSetProxy，允许在对象和函数调用等操作前后添加自定义的行为Class类函数默认参数 24、匿名函数的典型应用场景是什么？需要立即调用执行的函数，封装局部作用域的代码，避免声明的变量暴露到全局作用域(function())()用于一些函数作为参数的情况，比如setTimeout或者forEach 引用类型8.new操作符的实现原理首先创建了一个新的空对象将对象的原型设置为函数的prototype对象让函数的this指向这个对象，执行构造函数的代码判断函数返回类型，如果是值类型，返回创建的对象，如果是引用类型，返回引用类型的对象 13.原型和原型链js中的构造函数内部存在一个prototype属性新建的对象内部存在一个指针，指向构造函数的prototype属性的对应值，即原型浏览器中能够通过proto属性访问这个值当访问一个对象的属性时，对象内部不存在这个属性，那么就会沿着原型链向上寻找该属性方法原型链的终点：Object.prototype.proto，也就是null可以通过hasOwnProperty方法判断属性到底是原型链上的还是本身定义的 全局变量作用域14.对执行上下文、作用域链、闭包的理解闭包指的是有权访问另一个函数作用域中变量的函数最常见的方式：在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量比如A函数内有B函数，B函数能访问A函数中的变量，B函数就是闭包用途：在函数外部访问函数内部的变量（间接访问函数内部的变量）使运行已经结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用作用域全局作用域window对象的属性拥有全局作用域最外层函数和变量都拥有全局作用域函数作用域函数内部的变量块级作用域es6的新特性letconst有效循环比较适合块级作用域作用域链在当前作用域查找不到变量时，就去父级作用域查找，直到全局作用域为止保证对环境中的变量和函数进行有序访问 15.实现call、apply及bind函数 16.call、apply函数的区别区别在于传参不同：apply：第二个参数为数组或类数组，作为函数的参数call，第一个参数往后全是函数的参数 闭包什么是闭包（内层函数中访问到外层函数的作用域）一个函数与其内部创建的函数的作用域的连接阻止了函数调用结束时对函数内部变量的销毁，因为变量被闭包函数引用解决的问题内部函数可以访问到外部函数的内容使用场景防抖节流创建私有变量方法延长变量的生命周期闭包的缺点：变量驻留在内存中，造成内存损耗问题解决方法：手动清空闭包函数 异步模式17.异步编程的实现方式回调函数Promise方式generator（不熟）async，promise的语法糖 18、setTimeout、Promise、AsyncAwait的区别 19、Promise.all和Promise.race的区别以及使用场景Promise.all 将多个promise实例包装成一个新的promise实例成功：返回结果数组失败：返回最先被reject失败状态的值使用场景：需要多个ajax请求全部回来之后才能正常显示，且返回数组顺序和传入时的顺序一样Promise.race传入的请求中，返回请求响应最快的结果 20、对asyncawait的理解是promise的一种语法糖，能够解决回调地狱async修饰的函数，返回值是promise对象await用于修饰一步操作async函数中，会等待await代码执行结束后，才会继续执行下面的语句 宏任务和微任务 js是单线程语言 js代码会先执行完同步任务，再进入事件循环 事件循环：请求、定时器、事件 检测是否有可执行的微任务 有可执行的微任务，执行微任务 微任务清空后执行宏任务 任务类型 宏任务 setTimout、setInterval 执行前提：清空了所有的微任务 微任务 promise 性能优化21、浏览器的垃圾回收机制 22、哪些情况会导致内存泄漏 原理相关25、你能举出一个柯里化函数的例子吗？它有哪些好处 26、什么是事件循环？调用堆栈和任务队列之间有什么区别事件循环是一个单线程循环用于监视调用堆栈并检查是否有工作即将在任务队列中完成如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行 js设计模式有哪些 几个比较要命的问题： 如何解决跨域问题 http握手 如何区分null和空数组 Map的定义方式 Object哪些方法用的比较多 防抖节流 同源策略"},{"title":"2025/02/11 广盛房地产","path":"/wiki/Job/log_03_20250211_GuangSheng.html","content":"面试公司：徐州广盛房地产 面试岗位：前端工程师 面试时间：2025021111:00 面试时长：20分钟 面试体验：比较顺利 技术栈：vueuniappant design of vue微信小程序 公司介绍 国企，负责建设及管理运行维护信息化系统业务方向：移动互联网传统互联网大数据服务信息化系统建设反问环节方便问一下公司前端使用的技术栈吗可以问一下公司开发团队规模吗岗位的主要职责和期待人选吗岗位是否稳定 一面（技术）css如何实现居中块布局、行布局、行内块元素区别是什么如何解决浮动布局单行如何实现换行时显示省略号介绍一下box-sizing属性vue2computed和watch的区别vue3谈谈你对组合式api的理解ref和reactive有什么区别watch和watchEffect的区别是什么路由钩子有哪些vue3的生命周期TypeScripttypescript如何区分null和undefined定义和来源null表示空值，是一个字面量，可以直接将其赋值给变量undefined表示变量已声明但未被赋值，或根本不存在当声明一个变量未赋值时，其默认值就是undefined类型null和undefined各自有自己的类型用途null常用于表示一个预期对象不存在或为空undefined与变量的状态有关比较null和undefined使用是相等的，三等号则不相等 type和interface的区别是什么关键区别：扩展性type别名本身无法添加新的属性interface是可以扩展的继承不同interface继承时，如果重写类型会导致编译错误type交叉类型不会定义不同接口使用interface定义类型使用type定义定义方式不同interface可以通过扩展其他接口来定义新的接口类型也可以通过声明合并来扩展已有的接口type通常用于定义具体的类型别名，可以基于其它类型创建新的类型兼容性检测interface会进行属性的兼容性检查，检查该类型是否具有接口中定义的所有属性和方法type并不会进行严格的兼容性检查，只是简单的将类型进行替换扩展能力不同interface可以使用关键字extends扩展type可以用于定义各种类型别名 uniappuniapp中如何设置全局变量定义一个专用模块，用来管理全局变量将项目中用的比较多的变量，挂载到Vue.prototype上每个vue对象都会去继承这些方法变量使用globalDatavuex 进行状态管理 uniapp中如何获取domuniapp如何实现路由传参生命周期有哪些uniapp几种页面跳转的方式有什么不同uniapp通过setStorage和setStotageSync的区别是什么"},{"title":"2025/02/09 上海云简业财","path":"/wiki/Job/log_02_20250209_YunJian.html","content":"面试公司：上海云简业财 面试岗位：前端工程师 面试时间：2025020913:30 面试时长：（笔试 1道题） +（一面技术 40min）+（二面hr 40min） 面试体验：一般 线上笔试一面：技术（40min） 自我介绍 项目相关提问 技术问题 项目提问我看到你简历上介绍了一些可视化内容，能说一说具体是哪些项目用到了可视化呢答：高轨卫星态势项目中，需要实现一个能够实时追踪卫星轨迹的可视化地图是用到ECharts进行渲染在广联科技公司里主要负责可视化项目的组织和开发其中比较有代表性的有：徐矿智慧校园驾驶舱系统、企业工时监控大屏选择的技术栈大多为ECharts、Threejs，对一些要求比较特殊的图表，会用到D3进行实现在最近的一个App项目中尽管是Android和IOS原生开发的App，可视化和游戏部分依旧由我负责开发，通过webview的方式嵌入到app中 在以往的项目中，哪一个让你觉得收获最大呢那就这个项目可以展开说说吗，说说具体的功能点那在这个系统中，是如何进行权限管理的呢那么能谈谈这个系统的登录是如何实现的吗？技术问题如何加快首屏加载的速度呢？如何获取首屏加载时间呢？ DOMContentLoadperformancechrome控制台的performance性能监听 加载慢的原因 网络延时资源文件体积过大重复请求加载资源文件加载脚本时，渲染内容堵塞 解决方法 减小入口文件体积网络请求次数路由懒加载图片懒加载，只加载用户视口可见的数据script标签资源异步加载，使用async和defer加载静态资源本地缓存采用http缓存，设置cache-control、last-modified、etag等响应头UI框架按需加载按需引入UI库图片资源的压缩进行适当压缩icon可使用字体图标小图标可以使用雪碧图的方式合并到同一张图上组件重复打包A.js文件被多个路由引用时，造成了重复下载webpack的config文件中，设置CommonsChunkPlugin的minChunks，打包数量大于等于minChunks的包会被抽离到公共依赖文件中开启GZip压缩安装compression-webpack-plugin插件，进行包体积压缩服务器端也要做相应配置cssjshtmlimage等文件都是可以压缩的使用CDN进行加速利用webpack的splitChunks进行代码分割，对js进行分片SSR，服务器端渲染相当于后台将页面结构和数据准备好，浏览器端只需要进行渲染即可体验方面增加骨架框增加loading动画效果 script的async标记的使用条件是什么使用条件适用于独立脚本、第三方脚本脚本之间无依赖关系脚本不操作dom或不依赖其他脚本因为脚本可能在dom完全加载之前执行如果是对于需要操作dom的脚本，可使用deferdefer和async的区别async执行顺序不确定defer执行顺序确定 display:inline 和 display:inline-block的区别答：不清楚block元素独占一行宽度自动填满父元素宽度可以设置width、height可以设置margin、padding属性inline不会独占一行设置widthheight无效水平方向的marginpadding有效，垂直方向无效inline-block将对象呈现为inline对象对象的内容作为block对象呈现可以使一个元素既具备inline的同行特性，又有block的宽高特性问：所以你用的都是flex、grid之类的布局方式吗答：也有float方式的布局 absolute和translate的区别是什么translate动画性能更优保留文档流，不会影响元素布局，对需要保持元素之间相对位置的场景有用根据自身定位支持3d变换absolute相对于祖先元素（非静态定位）进行定位使用topleft等属性进行定位需要通过z-index设置堆叠顺序完全从文档流中移除 html中，如何使用label和checkbox，实现文字和多选框同时绑定呢label标签添加for属性能绑定for属性值为checkbox的iddiv input type=checkbox id=check1 label for=check1 id=lab1123/label/div property和attribute的区别是什么一个html标签在浏览器中解析为dom元素时，生成的dom元素上定义的属性及property，其中有一个attributes属性，包含了所有的特性attribute特性值永远是字符串null大小写不敏感不存在时返回null操作特性的apihasAttributegetAttributesetAttributeremoveAttributeproperty属性值可以是任意合法js类型大小写敏感不存在时返回undefined当标准特性attribute更新时，属性property也会更新input.value只能由attribute修改propertyattribute的value更像是defaultValue这个property使用data-开头的attribute会映射到DOM的dataset中，划线格式会变成驼峰格式 checkbox勾选和未勾选的标记是什么答：勾选上value为true问：那value是property还是attribute呢答： 可能是property吧补充回答：回答错了checked属性：反映checkbox是否被选中checked属于propertyvalue是checkbox对应的值，用于表单数据的提交value属性attribute css如何解决不同浏览器样式兼容的问题使用normalize.css标准化样式库使用浏览器私有属性使用css兼容工具，比如Autoprefixer使用postcss可以进行css后处理，自动添加浏览器前缀postcss-px2rem能够实现 可以将代码里的px单位转换为rem单位，在vue.config.js中作为插件引入 有一个异步数组，如何让这个异步数组中的请求能够顺序执行const list = []// 装载异步请求let num = 0async function fetchAll() while(num list.length) await(list[num]().then(res= num+=1 )) fetchAll() 那么如果想使用4个线程池同时执行这个异步数组的话，如何实现？const list = []// 装载异步请求let num = 0async function fetchAll() while(num list.length) await(list[num]().then(res= num+=1 )) for(let i = 0; i 4;i++) fetchAll() 问：如果我想用8个呢？ 答：循环数换成8 问：浏览器可以同步执行8个请求吗？ 答：最多6个 问：uniapp实现的App中有调用过原生SDK吗 可以说一下下面2种定义函数的区别吗foo()// 第一种 自定义函数function foo()foo() //Error// 第二种 表达式，给foo赋值一个匿名函数var foo = ()=console.log(123) 第一种写法会被解析器自动提升到代码的头部（函数声明提升）第二种，虽然var定义可以进行变量提升，但赋值不会被提升，所以会报错 你平常常用的部署工具有哪些使用nginx时部署常用的配置项有哪些使用nginx部署单页面应用时，会做哪些特殊配置SPA应用只有一个html文件index.html需要将所有路由请求重定向到index.htmltry_files $uri $uri index.html即当请求文件不存在时，返回index.htmlMPA应用路由由服务器端处理每个页面对应一个html文件请求资源不存在，返回404文件try_files $uri $uri -404 使用git比较多还是svn，是习惯用命令行还是第三方工具？常用git指令有哪些？常用git指令 git clone 初始仓库git checkout test切换分支git checkout放弃分支修改git status查看当前git状态git add .将修改加入缓存区git commit -m “备注修改”提交内容到本地仓库git reset HEAD撤销加入缓存区的文件git reset HEAD~撤销提交到本地仓库的文件git pull拉取远程仓库代码git log查看提交日志git reset 回滚操作 如果我已经git push上去了，想要修改push的信息应该如何做方法1：再次提交，修改提交信息使用git commit –amend，修改提交信息方法2：回退commitgit reset –softhardsoft：保留工作目录hard：工作区和暂存区的内容都被抹掉git reset HEAD || git reset –mixed HEAD改变的差异在工作区 二面：hr（40min）可以简单的介绍一下过去的工作经历吗在北京的工作经验中有吸取到什么经验吗？那你为什么会想到上海来工作呢？能具体说说是什么原因导致你有了“业务比技术更加重要”的感悟吗？问：我没听懂，可以再详细的说说吗 那你未来的职业规划是什么呢？可以谈一谈你上一个项目，以及在上一个项目中的角色吗说一说你上一个项目中遇到的最难得问题，以及你是怎么解决它的你上一份工作的工作节奏如何答：非常快 问：有多快呢？比如说具体是什么样的呢？ 答：晚上基本都7、8点下班，赶版本的时候9、10点常态 那你对这种节奏体验如何呢？ 答：我个人是比较能适应这种快节奏的工作的 你对未来工作的期待是什么呢，请说具体一些"},{"title":"2025/02/11 小西科技","path":"/wiki/Job/log_04_20250211_XiaoXi.html","content":"面试公司：小西科技集团 面试岗位：前端工程师 面试时间：2025021114:00 面试时长：线上笔试（80道逻辑题） + 1面（30min） 面试体验：一般 技术栈：htmlcsses6vue 公司介绍 技术创新类旗下业务板块灵狐数据：移动应用数据分析平台莫邪互娱：卡牌和休闲游戏研发与发行神龙云：云计算解决方案反问环节方便问一下公司前端使用的技术栈吗可以问一下公司开发团队规模吗岗位的主要职责和期待人选吗岗位是否稳定 项目介绍你做过的最完整的一个项目css说一下vmvhremempx之间的区别可以说一下什么是重绘和回流（不会）是什么回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置重绘：当计算好盒模型的位置、大小和其他属性后，浏览器根据每个盒子特性进行绘制浏览器渲染机制：解析html，生成dom树，解析css，生成cssom树将dom树和cssom树结合，生成渲染树（render tree）layout回流：根据渲染树，进行回流，得到节点的几何信息（位置、大小）painting重绘：根据渲染树记忆回流的几何信息，得到节点的绝对像素display：将像素发送给gpu，展示在页面上如何触发回流触发时机添加或删除可见的dom元素元素位置发生变化元素尺寸发生变化（外边框、内边框、边框大小、高度、宽度）元素内容发生变化，文本变化、图片被另一个不同尺寸的图片所替换页面一开始渲染浏览器窗口尺寸变化这些属性都有一个共性：需要通过即时计算得到getComputedStyle重绘触发时机颜色修改文本方向修改阴影修改触发回流一定会触发重绘浏览器优化机制浏览器会将操作放入对列表中，批量执行优化重排过程当需要获取正确的布局信息时，会强制队列刷新，这样offsetTop等方法都会返回最新的数据如何减少想要设置元素样式，通过改变元素的class类型避免设置多项内联样式对于复杂的动画，设置position:fixedabsolute，使其脱离文档流避免使用table布局，table中每个元素的大小以及内容改动，都会导致整个table的重新计算css3硬件加速，让transform、opacity、filters这些动画不会引起回流重绘 css选择器的优先级css中的常用选择器 id选择器 #box类选择器 .one标签选择器 div后代选择器 #box div子选择器 .oneone_1相邻同胞选择器 .one+.two群组选择器 div,p伪选择器 :hover伪元素选择器 :first-letter :before属性选择器 [attributevalue]伪类选择器 :nth-child 优先级 内联样式id选择器类、伪类、属性选择器标签、伪元素选择器通配符、子类选择器、兄弟选择器 flex布局如何居中一个元素什么情况下要用的grid布局写原生css还是预处理器css会阻塞界面的渲染吗可以说一下absolute和relative的区别吗，absolute是相对于谁定位的html说几个行内元素、块级元素块级元素div、p、h1、ul、li行内元素span、a、img、input 什么是语义化标签根据内容的解构，选择合适的标签，让浏览器的爬虫和机器能够更好地解析这是为了使页面在没有css的情况下，也能很好的展示出页面结构有利于seo提高代码可读性 js当在浏览器输入一个url链接之后，执行的操作是怎么样的呢url解析，分析协议、域名、端口、路由、传参dns查询，获取目标服务器的ip地址tcp连接，经历3次握手建立tcp连接发送http请求响应请求页面渲染解析html，构建dom树解析css，构建css规则树合并dom树和css规则，生成render树布局render树，负责个元素尺寸、位置计算绘制render树浏览器将各层信息发给GPU，GPU将各层合成，显示在屏幕上 session、cookie、localstorage区别是什么cookie大小限制4kb左右一般由服务器生成，可以设置失效时间浏览器生成Cookie，默认关闭浏览器后失效每次都会携带在http头中常用：验证用户登录是否过期localStorage持久化本地存储一般为5mb仅在客户端浏览器保存存放tokensessionStorage数据只有在同一个会话中的页面才能访问绘画：浏览器窗口没有关闭一般为5mb 深拷贝和浅拷贝的区别说一下js有哪几种数据格式如何判断一个数据类型是函数类型query和params区别是什么有用过防抖和节流吗Array常用方法有哪些vue说一下vue的生命周期computed和watch的区别watch和watchEffect的区别如何防止用户没有登录，就进行路由跳转如何动态添加路由（不会）使用router.addRoutes方法动态添加路由router.addRoute还可以动态添加嵌套路由 router和route的区别是什么如何实现路由传参说一下slot是做什么用的如何进行权限控制（重点）路由权限用户登录后只能看到自己有权访问的导航菜单，只能访问自己有权访问的路由地址，否则跳转404提示页面方式一：初始化挂载全部路由，在路由上标记权限信息，每次路由跳转在路由钩子里做校验没必要加载所有路由，消耗性能大全局路由守卫里，每次路由跳转都要做权限判断菜单信息写死在前端路由跟菜单耦合在一起方式二：初始化时先挂载不需要权限控制的路由（登录、404等页面），如果用户通过url强制访问，直接进入404登录后，获取用户权限，筛选有权限访问的路由，在全局路由守卫里调用addRoutes添加路由按需挂载，路由就需要知道用户的路有权限全局路由守卫里每次路由跳转都要做判断视图方面用户只能看到自己有权浏览的内容和有权操作的控件按钮权限方式一：v-if判断用户权限role方式二：自定义指令进行按钮权限判断菜单权限路由和菜单都由后端返回接口权限越权请求将在前端进行拦截采用jwt进行验证，没通过返回401，跳转登录页面重新登陆登录完拿到token，放到localstorage存起来，axios请求携带token pinia有哪些属性呢state 数据存放地可以直接修改state里面的值vux需要通过mutation进行修改actions 异步getters 计算属性 vuex页面刷新之后数据能保留吗说说你对nextTick的理解在下次dom更新循环结束之后执行延迟回调在修改数据之后，立即调用这个方法，可以获取更新后的dom react门户网站是用ssr吗门户网站是如何优化的呢"},{"title":"2025/02/12 领雁","path":"/wiki/Job/log_06_20250212_LingYan.html","content":"面试公司：领雁-外包宁波银行 面试岗位：宁波-前端开发工程师 面试时间：2025021214:00 面试时长：12分钟左右 面试体验：一般，没有反问环节 技术栈：vue23、elementUI、vant、webpack、es6 公司介绍 浙江宁波银行一周以内可以到岗期待薪资8k反问方便问一下公司前端使用的技术栈吗可以问一下公司开发团队规模吗可以问一下岗位的主要职责和期待人选吗岗位是否稳定 vuevue传值的方式vue2和vue3的区别讲一下自己做过的最复杂的组件封装echarts常用的api有哪些echarts的restore用过吗restore是echarts中的一个事件类型用于重置option事件 echarts的自定义事件有用过吗echarts中主要是通过on方法添加事件处理函数click鼠标事件highlight 高亮事件downplay 取消高亮事件selectchanged 选中状态发生变化时触发的事件finished 渲染完成事件rendered 渲染结束事件 webpack一个项目打包部署之后，用户发现服务界面白屏，你如何进行调试呢路由配置问题刷新之后找不到资源，服务器静态资源文件加载失败vue-router配置中设置mode为history资源缓存问题需要清除缓存数据nginx配置资源设置缓存过期时间"},{"title":"2025/02/12 新格尔","path":"/wiki/Job/log_05_20250212_XinGeEr.html","content":"面试公司：新格尔 面试岗位：南京-web3d开发工程师 面试时间：2025021209:30 面试时长：技面（30min）+ hr面（30min） 面试体验：良好，虽然回答的不咋样，但是面试官比较有耐心，会纠正和提示你，2场面试面试官都会认真回答问题 技术栈： 几何算法3D技术数理逻辑算法优化后端技术 canvaswebglelectrontsthreejsbabylonjs 微信小程序uniappvue3 公司介绍 期待薪资：8k定制家具产业互联网企业BIM软件软件：柜柜App画门窗老板良四合院门窗CC测量大师技术面反问方便问一下公司前端使用的技术栈吗可以问一下岗位的主要职责和期待人选吗总重要的是态度吧，需要端正态度，愿意学习web3d技术可以介绍一下成为一名在web3d领域比较专业的程序员大概需要多长时间吗？需要掌握哪些技能呢？这个主要看个人的兴趣和行动吧，如果有足够的驱动力的话，大概1年多就能掌握的比较熟练了掌握技能首先，我们是要和vue层进行交互，需要对vue的实现原理非常熟悉其次，使用的图形库中的api需要足够熟悉，在什么场景下采用什么方案要有自己的判断最后，我们是门窗行业的，你至少需要知道这个行业对技术层面的实现有什么要求吧hr面反问可以了解一下岗位是否有考核标准和上升空间吗？可以介绍一下我所应聘的岗位，部门人员怎样组成的呢我个人的理解是：咱们这个岗位对软件开发、图形学、数理逻辑以及业务理解能力要求都比较高我个人是非常感兴趣的，也愿意积极的了解和学习方便问一下，您认为要在这个岗位上做的非常出色，需要具备哪些特质呢？ 技术问题jssession、localstorage、cookie区别是什么说一下宏任务和微任务，宏任务和微任务哪个先执行说一下堆和栈的区别堆和栈是2种不同的内存管理方式，用于存储不同类型的数据堆（Heap）用于动态分配内存的数据存储引用类型数据，如对象和数组栈（Stack）用于存储基本类型数据，以及函数执行上下文分配固定大小的内存内存管理由系统自动处理，通过栈指针的移动来分配和释放内存在堆中分配的内存不会自动释放，需要垃圾回收机制 说一下浅拷贝和深拷贝区别 浅拷贝创建新的数据，这个数据有着原始数据属性值的一份精确拷贝如果属性是基本值，拷贝的就是基本类型的值如果属性是引用类型，拷贝的就是内存地址深层次的引用类型则共享内存地址浅拷贝实现方法Object.assign使用扩展运算符实现的复制sliceconcat深拷贝开辟一个新的栈，两个对象属性完全相同，对应的地址不同修改一个对象的属性，不会改变另一个对象的属性深拷贝方式_.cloneDeep()jQuery.extend()JSON.stringify()缺点：会忽略undefined、symbol、函数手写循环递归 使用JSON.parse有什么问题JSON.stringify会忽略undefined、symbol和函数 说一下es6常用的特性有哪些map和set的使用场景有哪些es6中promise常用的场景有哪些Promise是异步编程的一种解决方案使用Promise.then实现链式操作promise有三种状态pending 进行中fulfilled 已成功rejected 已失败一旦状态改变无法重新修改用法all 返回所有异步请求的结果，需要所有异步响应状态都成功race 返回最先有响应的异步请求结果allSettled 返回所有异步请求结果，不管请求成功还是失败resolve 返回一个新的Promise，实例的状态是fulfilledreject 返回一个新的Promise，实例的状态是rejected使用场景当需要同时获取到几个接口的响应，再执行下一步操作时，使用Promise.all通过Promise异步请求获取到接口数据之后，执行then操作，进行下一步数据处理 说一下null和undefined的区别css可以讲一下什么是bfc吗BFC（Block Formatting Context）块级格式化上下文（形成一个相对于外界完全独立的空间，让内部的子元素不会影响外部的元素）是页面的一块渲染区域，有一套自己的渲染规则内部的盒子会在垂直方向上一个接一个的放置对于同一个BFC的两个相邻盒子的margin会发生重叠，与方向无关每个元素的左边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此BFC的区域不会与float的元素区域重叠计算BFC的高度时，浮动子元素也参与计算BFC就是页面上的一个隔离的独立容器，容器的子元素不会影响外面的元素如何触发BFCoverflow:hiddendisplay:inline-blockposition:absolute|fixeddisplay:table-cell|flexbfc应用场景防止margin重叠解决方法，在其中一个盒子外面包裹一个div盒子清除内部浮动解决方式：父组件overflow:hidden自适应多栏布局：左边使用浮动，右边栏左侧与父盒子的左边栏相触，解决方法：给右边栏添加overflow:hidden 可以讲一下iframe的缺点吗优点 iframe能够显示嵌入的网页可以实现头部、菜单、尾部组件不变，仅仅对iframe嵌套部分修改页面内容，实现代码复用 缺点 iframe会阻塞主页面的onload事件iframe和主页面共享连接池，浏览器对相同域连接数量有限制，影响页面的并行加载使用iframe不利于seo优化对很多移动设备而言，iframe兼容性差使用iframe会增加服务器的http请求 如何实现一个宽度为0.5px的线宽边框呢使用box-shadow实现使用border+transform-scaleY缩放使用伪元素选择器:after:before + transform-scaleY缩放 大屏的响应式大小是怎么做的htmlhref和src的区别是什么请求资源类型不同href：用来简历当前元素和文档之间的链接，常用有linkasrc：会将其指向资源下载并应用到文档中，常用有scriptimgiframe作用结果不同href用于文档和资源之间建立关系src用于替换当前内容浏览器解析方式不同href：浏览器会识别文档为css，并行下载资源并且不会停止对当前文档的处理src：会暂停其他资源的下载和处理，直到该资源加载、编译、执行完毕，将所指向资源应用到当前内容，因此建议将js脚本放在尾部执行 vue了解vue的mixin吗mixin是面向对象程序设计语言中的类，其他类可以访问mixin类的方法而不必成为其子类mixin类常用作功能模块使用，在需要该功能时进行混入，利于代码复用避免多继承的复杂Vue的mixin用来分发vue组件中的可复用内容本质是一个js对象当组件使用mixins对象时，所有mixins对象的选项都被混入该组件本身的选项中vue支持局部混入和全局混入局部混入定义一个mixin对象，有options的data、methods属性，组件通过mixins属性调用mixin对象全局混入Vue.mixin({created:(){}})常用于插件的编写组件的选项会覆盖mixin的选项如果相同的选项是生命周期钩子，会合并成数组，先执行mixin的钩子，在执行组件的钩子使用场景定义一个modal弹窗组件 说一下hash和history的区别能说一下v-model的实现原理吗如果不是绑定的value，v-model是如何实现绑定的呢原生v-model：可以看成是value和input的语法糖自定义：prop传入值，在子组件中通过emit事件对prop进行更新 说一下父子组件的生命周期调用顺序项目问题有用过canvas画图的一些库吗看到你用到了若依框架，当菜单过多时有遇到过栈溢出的情况吗什么场景用到websocket了呢uniapp实现的小程序如何实现登录功能wx.login获取用户的code，判断用户是否授权读取用户信息调用wx.getUserInfo读取用户数据通过wx.request请求业务方服务器，后端把appid、小程序密钥、code一起发送到微信服务器服务器返回了openid及会话密钥session_key后端从数据库查找openid没找到，用户没注册session_key是对用户数据进行加密签名的密钥生成session返回给小程序，存入storage下次请求时，从storage里读取，发送给服务端服务端比对session记录，校验有效期 其它问题之前做的App的直播是怎么实现的，App里的3d交互实现的具体内容是什么electron做的项目是包壳还是什么，里面包的是链接吗有没有开发过需要和桌面硬件进行联动的项目能接受从threejs转Babylonjs吗 HR面试可以简述一下过往公司是做什么的，公司规模以及研发团队规模吗？可以介绍一下你在每家公司的离职原因吗？可以简述一下你在上份工作中负责的模块吗？除了工作之外，你还有其它爱好吗？你的朋友对你的评价是什么？你是如何看待加班的？你的职业规划是什么？有没有朝管理方向发展的意向？目前有没有收到其它公司的offer上学期间成绩怎么样"},{"title":"2025/02/12 润和科技","path":"/wiki/Job/log_07_20250212_RunHe.html","content":"面试公司：润和软件-华为海思芯片研发 面试岗位：上海-中级前端工程师 面试时间：2025021215:00 面试时长：30min 面试体验：一般，面试官感觉一周都没休息，非常疲惫 技术栈：基础前端技术、前端框架、常用数据库mysql 公司介绍 华为海思芯片研发外包项目上海青浦上班，项目周期8-10年，双休期望薪资12k反问方便问一下公司前端使用的技术栈吗可以问一下公司开发团队规模吗可以问一下岗位的主要职责和期待人选吗岗位是否稳定 技术问题场景问题：Excel表格有这么一个功能，一张excel表格，会有不同角色的用户去访问，这张excel表你要如何导入到数据库中呢（从前端角度）？表格上显示的东西会根据用户的角色做区分并且这张表需要经过各个层进行确认签字走流程这个功能你能实现吗？包括构建、开发、部署 能说一下前端是如何实现一个页面的吗如果你的npm安装时由于某些原因镜像拉取不到资源，如何解决如何解决跨域能说一下axios的实现原理吗HTTP请求发送浏览器：使用XMLHttpRequest来发送HTTP请求Node环境：使用node.js的http模块Promise异步请求axios返回promise对象使用.then和.catch进行处理拦截器在请求或响应发送到服务器或浏览器之前可以进行干预请求响应处理：监听http响应事件，接收到响应后进行处理，调用响应拦截进行干预 其它问题用过Linux吗，说说你常用的linux命令吗前端构建工具有哪些？有写过原生轮播图吗c#、java你都会写吗？你们的App也是原生写的吗？那h5页面也是可以这样嵌入进去吗？熟悉javascript吗？听成熟悉java spring吗？我还一愣，说不知道，面试官急了说：你写前端的怎么会不知道javascript（捂脸）对canvas了解吗http端口是多少80https端口是多少443有用过那种开箱即用的框架吗vue3+uniapp项目会自己搭建吗能说说你要如何实现权限控制吗"},{"title":"2025/02/13 徐州瑟驰","path":"/wiki/Job/log_09_20250213_SeChi.html","content":"面试公司：徐州瑟驰 面试岗位：徐州-vuereact前端工程师 面试时间：2025021311:00 面试时长： 面试体验： 技术栈：vuejsreact 公司介绍 待遇底薪+提成单双休成都古道科技有限公司的苏北运行中心外贸品牌营销推广外贸搜索引擎优化网站建设、商城建站、国外社交网络推广产品：外贸全球搜搜索引擎优化技术智能响应建站技术104种语言期待薪资：7k"},{"title":"2025/02/12 不知名公司","path":"/wiki/Job/log_08_20250212_UnKnown.html","content":"面试公司：不知名公司 面试岗位：前端工程师 面试时间：2025021216:30 面试时长：20min 面试体验：非常一般 突如其来电话面试 不知道是哪家公司 电话对面非常嘈杂 面到最后反问时，问到公司开发团队有多大，面试官反问hr没告知我吗，对方是初创公司，开发团队只有3个人（服了） 技术栈：vuejsreact 技术问题vue2、vue3区别vue生命周期vue自定义指令用过吗，vue指令一般写在哪里全局注册Vue.directive(‘指令名’,{})参数1：指令名称参数2：可以是对象数据，也可以是指令函数局部注册在options选项中设置directive属性自定义指令钩子bind 只调用一次，指令第一次绑定到元素时调用，可以进行一次性的初始化设置inserted 被绑定的元素插入父节点时调用update，所在组件的vnode更新时调用componentUpdated 组件的VNode以及其子VNode全部更新之后调用unbind 指令与元素解绑时，仅调用一次钩子函数参数el 绑定的元素，可以直接操作dombinding 一个对象，包含一些propertyvnodeoldnode应用场景表单防止重复提交通过指令实现按钮节流图片懒加载通过指令监听图片是否出现在视口中，实现懒加载元素实现拖拽vue指令写在哪里全局指令directivesindex.js，在main.js中调入使用局部指令直接写在options的directives中 介绍一下vue的diff算法typeof null 结果是什么es6常用特性有哪些能说说http请求吗http传输有文件大小限制吗？能传输文件吗本身对传输文件大小没有限制前端和后端可以对文件的大小进行限制大文件对网络环境要求比较高能传输二进制文件类型优化大文件传输分块传输读入二进制数据之后，通过控制步长和位移实现传输使用http2.0多路复用和二进制传输，提升大文件传输效率cdn内容分发网络分发大文件，减少服务器压力 websocket心跳一般每隔几秒发送一次答：30-60s比较合适心跳机制就是定时发送ping消息来确保连接客户端定时发送心跳包服务器端定时响应心跳包如果客户端在指定时间内没有收到服务器的响应，则认为连接已经断开 你们http请求是多长时间算作超时呢？答：3-5秒，具体要看业务 你们的门户网站有做单点登录吗单点登录SSO让用户在多个应用系统之间只要登陆一次就可以访问所有授权系统的机制 能说一下vue项目的部署过程吗简历里面提到的网站性能优化是指哪些东西？用的是哪些接口调试工具是如何区分后台和App端用户的"},{"title":"前端面试实战-叠纸","path":"/wiki/Job/summary_01_DieZhi.html","content":"原贴：小红书-这很派大星 描述一种方法，用以实现一个动态加载内容的无限滚动列表答案 使用InterSection Observer API监听一个触发元素，如列表底部标记，当该元素出现在视口中时，通过AJAX或Fetch API异步加载更多内容，并添加到列表底部const observer = new IntersectionObserver(entries = if(entries[0].isIntersecting) loadMoreItems() )observer.observe(document.querySelector(.scroll-anchor)) 如何使用Css实现一个效果，用户鼠标悬停时，按钮逐渐变大使用css的hover选择器和transition属性，来平滑变换按钮的尺寸 React中，如何优化组件以避免不必要的重新渲染使用React.memo对函数组件进行包装使用shouldComponentUpdate生命周期方法使用React.memo的第二个参数来避免不必要的渲染const MyComponent = React.memo(function MyComponent(props) // 组件内容,(prevProps, nextProps)= return prevProps.data === nextProps.data) 如果有一个含有数百个项目的数组，如何有效搜索特定项目使用JavaScript的Map或者Set数据结构因为它们提供平均时间复杂度为O(1)的查找性能const itemMap = new Map()largerArray.forEach((item,index)=itemMap.set(item.key,item)); 解释一下Web Accessibility（Web无障碍性）并举例说明如何在网页设计中实现它Web Accessibility，能够确保残障人士（如听觉、视觉存在障碍的人），也能够无障碍的访问和使用服务使用语义化Html标签，如header、nav、main、footerr，帮助屏幕阅读器更好理解页面结构使用alt属性为图片提供替代文本，帮助视觉障碍用户理解图片内容确保所有功能元素都可以通过键盘访问比如使用button标签而不是div创建按钮为自定义控件添加tabIndex属性，使其可以通过键盘聚焦设置合适的aria角色和属性button aria-label=Close tabindex=0Close/button 使用JavaScript，如何创建一个倒计时计时器，显示天、小时、分钟和秒使用setInterval函数更新倒计时时间function startCountdown(duration) const endTime = Date.now() + duration const interval = setInterval(()= const remaining = endTime - Date.now() if(remaining = 0) clearInterval(interval) else const days = Math.floor(remaining / (1000 * 50 * 60 * 24)) const hours = Math.floor(remaining % (1000 * 50 * 60 * 24)/ (1000*60*60)) const minutes = Math.floor(remaining % (1000 * 50 * 60 * 24) / (1000 * 60)) const seconds = Math.floor(remaining % (1000 * 50 * 60 * 24) / 1000) ,1000) 我的游戏界面需要实时更新玩家的得分，你会如何设计前端架构来实现这一功能使用WebSocket或者Server-Sent Events(SSE)实现与服务器端的实时通信当服务器端得分更新时，通过WebSocket推送到前端，更新用户界面const scoket = new WebSocket(ws://example.com/score)socket.onmessage = function(event) updateScore(event.data) 解释什么是服务工作线程（Service Worker），以及它可以如何帮助提高一个游戏网站的性能？Service Workers可以拦截和处理网络请求，缓存或检索资源提高加载速度并支持离线功能对于加载重资源的游戏尤其适用，可以在玩家第二次访问时提供及时加载体验if(serviceWorker in navigator) navigator.serviceWorker.register(/sw.js).then(registration= console.log(Service Worker registerd with scope, registration.scope) ).catch(error= console.error(failed,error) ) 请描述一个你如何使用SVG来增强网站视觉体验的情况svg是一矢量可缩放图片格式，适用于响应式设计，svg格式的图片在缩放后不会失真，例如echarts、d3等图片库也都非常支持svg的渲染格式，并且svg还可以实现动态和交互图形，在一些可视化动态网站和游戏中使用的非常多 如何在前端项目中实现国际化和本地化使用i18next或者similar国际化库，支持多语言内容和格式在前端实现时，定义语言文件，并在UI组件中引用翻译 解释CSS中的BEM命名方法，并展示如何使用它来组织你的样式表BEM（Block Element Modifier）是一种css类命名约定，有助于保持样式标的可维护性和可扩展性通过独立的块、元素、修饰符来组织代码 你将如何处理跨浏览器的兼容性问题，尤其是在不同设备和操作系统上在一个复杂的页面上，用户操作导致多次不必要的DOM操作，你将如何优化它描述一个场景，你使用FlexBox解决了一个布局问题当一个Ajax请求失败时，你通常如何处理错误，并给用户提供反馈？"},{"title":"10.1 函数语法","path":"/wiki/JavaScript/chapter_10_1.html","content":"函数对象 函数实际上是对象函数都是Function类型的实例Function也有属性和方法函数名是指向函数对象的指针 定义函数的几种方式 ① 函数声明function fun(param1,param2) return param1 + param2;② 函数表达式let fun = function(num1, num2) return num1 + num2;③ 箭头函数let fun = (param1, param2) = return param1 * param2;④ Function构造函数let fun = new Function(param1,param2,return param1 % param2);Function构造函数的参数 最后一个参数 始终被当做函数体 非最后一个参数 作为新函数的参数 不推荐使用原因：两次解释代码，会影响性能 将它当做常规ECMAScript代码 解释传给构造函数的字符串 重要的是：把函数想象为对象，把函数名想象为指针 10.1.1 箭头函数箭头函数适合嵌入函数的场景 let ints = [1, 2, 3];console.log(ints.map(function (i) return i + 1 ));console.log(ints.map(i = i + 1)); 只有一个参数的情况下可以不加括号 // 一个参数可以省略括号let triple = x = return 3 * x; // 没有参数需要括号let getRandom = () = return Math.random(); // 多个参数需要括号let sum = (a, b) = return a + b; 函数体单条语句隐藏大括号表示返回这行代码的值 let triple = x = 3 * x;// 直接赋值let value = ;let setName = x = x.name = Matt;setName(value);console.log(value.name); //Matt 箭头函数局限 不能使用 arguments、super、new.target不能用作构造函数没有 protortpe 属性 10.1.2 函数名函数名作为指针就意味着：一个函数可以有多个名称 function sum(num1, num2) return num1 + num2;console.log(sum(10, 20)); //30let anotherSum = sum;console.log(anotherSum(10, 10)); //20sum = null;console.log(anotherSum(10, 10)); //20 函数的name属性 name属性一般保存的是函数标识符name属性只读没有名称的函数，name为空字符串Function构造的函数，name为’anonymous’function foo() let bar = function () ;let baz = () = ;console.log(foo.name); //fooconsole.log(bar.name); //barconsole.log(baz.name); //bazconsole.log((() = ).name); //console.log((new Function()).name); //anonymous特殊函数的标识前缀对于获取函数get、设置函数set、使用bind()实例化的函数，标识符前会加上一个前缀函数前缀getgetsetsetbindboundfunction foo() console.log(foo.bind(null).name); //bound foolet dog = years: 1, get age() return this.years; , set age(newAge) this.years = newAge; let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, age);console.log(propertyDescriptor.get.name); //get ageconsole.log(propertyDescriptor.set.name); //set age"},{"title":"前端面试实战-小西科技实习一面","path":"/wiki/Job/summary_02_XiaoXi.html","content":"原文地址 css什么是盒模型html元素由一个矩形框组成，即盒模型，盒模型由这些部分组成：content box显示内容的区域通过widthheight设置大小padding box内边框，paddingborder box边框，bordermargin box外边框，margin介绍一下css的2种盒模型box-sizing:content-box标准盒模型元素的宽度、高度只包括内容box-sizing:border-boxIE盒模型元素内容包括内边距和边框 link和@import的区别导入方式不同link使用标签的方式@import是css的一种语法使用范围不同link除了加载css样式，还能用于指定rel属性rel属性指定当前文档和被链接文档资源之间的关系加载方式不同link方式：浏览器会一同加载html和css@import：浏览器会先加载html，再加载css可以通过js操作dom，插入link@import支持ie5以上，link标签不存在兼容性问题 常用的布局方式flex布局grid网格布局绝对定位布局浮动布局两栏布局左侧宽度固定，右侧自适应 中间有间距，两边没有间距，怎么设置使用flex横向布局，justify-content使用space-between使用flex横向布局，设置flex:1自适应宽度，设置gap左侧元素设置margin-right，右侧元素设置margin-left position定位有哪些statictoprightbottomleftz-index无效relative相对于正常文档流的位置absolute相对于最近的非static定位祖先元素fixed相对于视口sticky js什么是变量提升将所有var声明的变量和函数提升到代码的头部函数声明的优先级高于变量声明 原型和原型链什么是原型在js中，每定义一个对象，对象中都会包含一些预定义的属性每个函数对象上都有一个prototype属性，这个属性指向函数的原型对象使用原型对象的好处是所有对象实例共享它包含的属性和方法什么是原型链每个对象都有一个原型对象，通过proto指针指向原型对象，并从中继承方法和属性原型对象也可能拥有原型这样一层一层，最终指向null，这种关系就是原型链通过原型链一个对象可以拥有定义在其他对象中的属性和方法 防抖和节流什么是节流防抖 当多次执行某一动作，进行函数调用次数的限制，节省资源防抖在事件触发n秒后执行函数，若在n秒内再次触发，重新计时只有在最后一次事件之后才触发一次函数节流当多次执行某一动作，每隔一段时间，只执行一次函数不管事件触发有多频繁，都能保证在规定时间内一定会执行一次时间处理函数需要在用户触发页面滚动时，请求后台数据应用场景防抖登录、发短信等按钮，防止用户按得太快窗口大小resize事件，希望窗口调整结束后触发鼠标的mousemove、mouseover事件节流列表滚动搜索联想功能表单重复提交 如何实现 防抖var timer;function debounce(fn, delay) if(timer) // 保证只开启一个定时器 clearTimeout(timer) timer = setTimeout(function() // 延迟delay执行函数 fn() ,delay)window.onscroll = function() debounce(test, 1000)function test() console.log(滚动停止)节流function debounce(fn,delay) let timer; return function() let _this = this let _args = arguments; if(timer) clearTimeout(timer) timer = setTimeout(function() fn.apply(_this,_args) ,delay) let testDebounceFn = debounce(test, 1000)function test(a) console.log(滚动停止+a)window.onscroll = function() testDebounceFn(aaaa) 什么是闭包内层函数访问外层函数作用域 结合闭包，说一下防抖是怎么实现的debounce函数接受两个参数需要防抖的函数延迟时间使用闭包保存timer变量，确保每次调用返回的函数都能访问到同一个timer每次事件触发，如果timer存在，则清除之前的定时器，设置一个新的定时器延迟时间到达后，执行func函数 this的指向面试官说，谁调用就指向谁指向当前执行的上下文调用模式函数调用方法调用构造器调用applybindcall 怎么手动改变thisapply、bind、call call、bind、apply的区别apply传参是数组，call是参数列表bind返回绑定this之后的函数，apply和call是立即执行 手写call手写callFunction.prototype.myCall = function(context, ...arg) const fn = Symbol(临时属性) context[fn] = this context[fn](...arg) delete context[fn]手写applyFunction.prototype.apply = function(context,arg) const fn = Symbol(占位元素) context[fn] = context context[fn](...arg) delete context[fn]手写bindFunction.prototype.myBind = function(context, ...firstarg) const that = this const bindFn = function (...secoundarg) return that.myCall(context, ...firstarg, ...secoundarg) bindFn.prototype = Object.create(that.prototype) return bindFn 箭头函数和普通函数区别写法不同箭头函数都是匿名函数箭头函数不能用于构造函数普通函数this指向调用对象，如果作为构造函数，this指向创建的实例箭头函数的this永远指向上下文的this，并且无法改变箭头函数没有arguments reactreact中性能优化有哪些方法参考博客 React.memoreact在组件刷新的时候会深度遍历所有子组件，查找所有更新节点，即父组件更新，子组件必会更新memo可以在某些情况下避免不必要的组件重新渲染，从而提高应用程序的性能有2种用法直接使用memo包裹组件需要更加精确的控制组件重新渲染，可以传递第二个参数给memo来自定义比较函数，函数接收2个值，分别是前一次的props和当前的props，返回一个布尔值表示是否需要重新渲染组件如果是class组件一般使用shouldComponentUpdate函数或则PureComponent实现列表使用key为了提高diff算法在渲染列表时候的性能有了它，react就能知道相比较上一个渲染周期，当前的渲染周期需要插入、移动或者删除哪些节点复用之前的dom，减少不必要的dom操作所产生的开销，从而提高界面更新的性能合理运用useCallback和useMemouseMemo和useCallback只针对重新渲染有帮助需要结合父组件具体情况来看使用懒加载和代码分割使用React.lazy和Suspense，按需加载组件，可以减少初始化加载时间，提高性能使用虚拟化对长列表或大型数据集，使用虚拟化库，仅渲染可见部分react-virtualized使用Profiler测量性能 useMemo和useEffect的区别执行时机不同useMemo会在渲染期间执行，memo在dom更新前触发useEffect只能在dom更新后，浏览器渲染完成后再触发 useMemo的原理，为什么要用React.memo包裹起来react的渲染过程触发渲染：props或者state发生变化时，react会重新渲染render方法：react调用组件的render方法，生成虚拟dom比较虚拟dom更新domuseMemo作用：在渲染过程中缓存计算结果，以便在每次渲染时都重新计算实现原理useMemo接收两个参数：callback和dependencies依赖数组存储计算结果，和上一次的依赖数组如果数组发生变化，重新计算并更新计算结果和依赖数组如果没有变化，则直接返回上一次计算的结果 React中函数组件如何模仿生命周期（用useEffect）componentDidMountuseEffect传入一个空数组componentDidUpdateuseEffect传入第二个参数，用于监听依赖项的变化componentWillUnmountuseEffect返回的函数会在组件卸载时执行shouldComponentUpdate可以使用React.memo对props进行比较 jsx和js的区别标签嵌套jsx允许在js中嵌套html标签插值表达式jsx支持通过花括号将js表达式插入到jsx中类名和属性命名不同，避免与js关键字冲突使用className代替class使用htmlFor代替for， babel处理jsx的原理解析将jsx代码分解为标记，构建出一个对应的astast能够表示源代码的结构和语法转换将jsx语法转换为普通的js代码将ast转换为js代码"},{"title":"10.2 函数参数","path":"/wiki/JavaScript/chapter_10_2.html","content":"10.2.1 理解参数ECMAScript的参数内部表现为一个数组，但函数并不关心数组中包含什么 arguments arguments是一个类数组对象，可以在函数内部访问arguments对象， 声明参数写法function sayHi(name,message) console.log(Hello + name + , + message);使用arguments重写function sayHi() console.log(Hello + arguments[0] + , + arguments[1]);使用arguments.length检查传入的参数个数function doAdd() if (arguments.length === 1) console.log(arguments[0] + 10); else if (arguments.length === 2) console.log(arguments[0] + arguments[1]); doAdd(10); //20doAdd(30, 20); //50arguments对象也可以和命名参数一起使用function doAdd(num1, num2) if (arguments.length === 1) console.log(num1 + 10); else if (arguments.length === 2) console.log(num1 + num2); doAdd(0); //10doAdd(5, 10); //15arguments始终与对应的命名参数同步但它们并不访问同一个内存地址，只是保持同步而已。 function doAdd(num1, num2) num2 = 1000; arguments[0] = -1000; console.log(num1 + arguments[1]);doAdd(10, 20); //0但如果访问arguments的索引超过了实际传参的数量，则无法同步。并且访问未传的参数默认值为undefined。strict modearguments和命名参数无法再同步函数中重写arguments对象会报错 箭头函数中的参数 箭头函数参数不能使用arguments关键字访问function foo() console.log(arguments[0]);foo(5); //5let bar = () = console.log(arguments[0]);bar(5); //ReferenceError: arguments is not defined可以在包装函数中把arguments提供给箭头函数function foo() let bar = () = console.log(arguments[0]); ; bar();foo(5); //5 10.2.2 没有重载ECMAScript函数参数内部是由数组表示的，没有函数签名，自然也就无法重载 存在同名函数，后定义的覆盖先定义的 function addSomeNumber(num) return num + 100;function addSomeNumber(num) return num + 200;console.log(addSomeNumber(0)); //200可以通过检查参数的类型和数量，分别执行不同逻辑来模拟函数重载。 10.2.3 默认参数值ECMAScript5.1以前设置默认参数值 简单粗暴 检测参数是否等于undefined，是的话就给它赋一个值function makeKing(name) name = (typeof name !== undefined) ? name : Henry; return `King $name VIII`;console.log(makeKing()); // King Henry VIIIconsole.log(makeKing(Louis)); // King Louis VIII ECMAScript6：支持实现设置参数默认值 function makeKing(name = Henry) return `King $name VIII`;console.log(makeKing()); //King Henry VIIIconsole.log(makeKing(Louis)); // King Louis VIII 通过传值为undefined的参数占位 function makeKing(name = Henry, numerals = VIII) return `King $name $numerals`console.log(makeKing()); //King Henry VIIIconsole.log(makeKing(Louis)); //King Louis VIIIconsole.log(makeKing(undefined, VI)); //King Henry VI arguments不反映参数的默认值 arguments始终以调用函数时传入的值为准，所以修改命名参数也不会影响arguments对象function makeKing(name = Henry) name = Louis; return `King $arguments[0]`;console.log(makeKing()); //King undefinedconsole.log(makeKing(Louis)); //King Louis 默认参数可以是原始类型或者引用类型 计算默认值的函数只有在调用函数并且未传相应参数时才会被调用let romanNumerals = [I, II, III, IV, V, VI];let ordinalty = 0;function getNumerals() return romanNumerals[ordinalty++];function makeKing(name = Henry, numerals = getNumerals()) return `King $name $numerals`;console.log(makeKing()); //King Henry Iconsole.log(makeKing(Louis, XVI)); //King Louis XVIconsole.log(makeKing()); //King Henry II console.log(makeKing()); //King Henry III 箭头函数得到默认参数 在只有一个参数且设置了默认值的时候，箭头函数参数的括号就不能省略了let makeKing = (name = Henry) = `King $name`;console.log(makeKing()); //King Henry 默认参数作用域与暂时性死区 给参数赋默认值实际上等同于使用let顺序声明function makeKing(name = Henry, numerals = VIII) return `King $name $numerals`;console.log(makeKing()); //King Henry VIII上面这段代码就等同于：function makeKing() let name = Henry; let numerals = VIII; return `King $name $numerals`;console.log(makeKing()); //King Henry VIII默认参数赋值也是顺序的：function makeKing(name = Henry, numerals = name) return `King $name $numerals`;console.log(makeKing()); //King Henry Henry暂时性死区暂时性死区 指的是 前面定义的参数不能引用后面定义的，否则会抛出错误：function makeKing(name = numerals, numerals = VIII) return `King $name $numerals`;// ReferenceError: Cannot access numerals before initializationconsole.log(makeKing());参数也存在与自己的作用域中function makeKing(name = Henry, numerals = defaultNumers) let defaultNumbers = VIII; return `King $name $numerals`;console.log(makeKing()); //ReferenceError: defaultNumbers is not defined 10.2.4 参数扩展与收集ES6新增的扩展操作符最有用的场景就是函数定义中的参数列表 扩展参数收集参数使用场景：不需要传入一个数组，强调分别传入数组元素let values = [1, 2, 3, 4];function getSum() let sum = 0; for (let i = 0; i arguments.length; i++) sum += arguments[i]; return sum;可以使用扩展操作符拆分可迭代对象参数console.log(getSum(...values)); //10console.log(getSum(...values, 5)); //15console.log(getSum(-1, ...values, 5)); //14console.log(getSum(...values, ...[5, 6, 7])); //28扩展操作符也可以用于命名参数中function getProduct(a, b, c = 1) return a * b * c;let getSum = (a, b, c = 0) = return a + b + c;console.log(getProduct(...[1,2])); //2console.log(getProduct(...[1,2,3])); //6console.log(getProduct(...[1, 2, 3, 4])); //6console.log(getSum(...[0, 1])); //1console.log(getSum(...[0, 1, 2])); //3console.log(getSum(...[0, 1, 2, 3])); //3扩展操作符可以把不同长度的独立参数组合为一个数组function getSum(...values) return values.reduce((x, y) = x + y, 0);console.log(getSum(1, 2, 3)); //6收集参数前如果还有命名参数，就只会收集剩余的参数没有剩余的话就只得到空数组function ignoreFirst(firstValue, ...values) console.log(values);ignoreFirst(); //[]ignoreFirst(1); //[]ignoreFirst(1, 2); //[2]ignoreFirst(1, 2, 3); //[2,3]function getProduct(...values, lastValue) //SyntaxError: Rest parameter must be last formal parameter箭头函数支持收集参数let getSum = (...values) = return values.reduce((x, y) = x + y, 0);console.log(getSum(1, 2, 3)); //6收集参数不影响argumentsfunction getSum(...values) console.log(arguments.length); //3 console.log(arguments); //[1,2,3] console.log(values); //[1,2,3]getSum(1, 2, 3);"},{"title":"10.3 函数特性","path":"/wiki/JavaScript/chapter_10_3.html","content":"10.3.1 函数声明与函数表达式函数声明和函数表达式的主要区别就在于是否会进行函数声明提升（functiondeclaration hoisting） 函数声明会进行函数声明提升 函数声明提升 即 函数声明会在任何代码执行之前先被读取并添加到执行上下文。console.log(sum(1, 2)); //3function sum(num1, num2) return num1 + num2; 函数表达式 必须要等到代码执行到那一行才会执行函数定义 这和let还是var声明无关。//ReferenceError: Cannot access num before initialization console.log(sum(10, 20)); let sum = function (num1, num2) return num1 + num2; 10.3.2 函数作为值因为函数名本身就是变量，因此函数可以作为参数和返回值。 function callSomeFunction(someFunction, someArgument) return someFunction(someArgument);function add10(num) return num + 10;console.log(callSomeFunction(add10, 10)); //20function getGreeting(name) return Hello, + name;console.log(callSomeFunction(getGreeting, Nicholas)); //Hello, Nicholas 从一个函数返回另一个函数可以非常有用 下面的程序中创建了一个可以按照对象数组中任意对象属性对数组进行排序的函数function createComparisonFunction(propertyName) return function (object1, object2) let value2 = object2[propertyName]; let value1 = object1[propertyName]; if (value1 value2) return -1; else if (value1 value2) return 1; else return 0; ;let data = [ name: Zachary, age: 28 , name: Nicholas, age: 29 ];data.sort(createComparisonFunction(name));console.log(data[0].name); //Nicholas 10.3.3 函数内部函数内部存在三个特殊对象 argumentsthisnew.target arguments arguments.callee 是一个指向arguments对象所在函数的指针。 经典阶乘函数function factorial(num) if (num = 1) return 1; else return num * factorial(num - 1); console.log(factorial(10)); //3628800使用arguments.callee重写迭代这样的话就可以让函数逻辑与函数名解耦，解决了硬编码带来的问题。 function factorial(num) if (num = 1) return 1; else return num * arguments.callee(num - 1); console.log(factorial(5)); //120let trueFactorial = factorial;factorial = function () return 0;console.log(trueFactorial(5)); //120console.log(factorial(10)) //0 this 标准函数中的this引用的是把函数当成方法调用的上下文对象，全局上下文中调用函数，this指向 windows。 window.color = red;let o = color: blue;function sayColor() console.log(this.color);sayColor(); //redo.sayColor = sayColor;o.sayColor(); //blue箭头函数中的this引用的是定义箭头函数的上下文。 window.color = red;let o = color: bluelet sayColor = () = console.log(this.color);sayColor(); //redo.sayColor = sayColor;o.sayColor(); //red因此在使用事件回调或定时回调时，为了保证回调函数内this值指向定义函数的上下文，常使用箭头函数定义回调函数。function King() this.royaltyName = Henry; setTimeout(() = console.log(this.royaltyName), 1000);function Queen() this.royaltyName = Elizabeth; setTimeout(function () console.log(this.royaltyName); , 1000);new King(); //Henrynew Queen(); //undefined caller caller 引用的是调用当前函数的函数。 function outer() inner();function inner() console.log(inner.caller);outer(); //output:outer source code为了降低耦合度，可以引用arguments.callee.caller。function outer() inner();function inner() console.log(arguments.callee.caller);outer(); //outer source code严格模式下访问arguments.callee会报错不能给caller属性赋值 new.target（ES6） 用于检测函数是否是使用new关键字调用的。 正常调用 new.target undefinednew关键字调用 new.target 被调用的构造函数function King() if (!new.target) throw King must be instantiated using new console.log(King instantiated using new);new King(); //King instantiated using newKing(); //Error:King must be instantiated using new 10.3.4 函数属性与方法函数固有属性（2个） lengthlength保存函数定义的命名参数个数。 function sayName(name) console.log(name)function sum(num1, num2) return num1 + num2;function sayHi() console.log(hi)console.log(sayName.length) //1console.log(sum.length) //2console.log(sayHi.length) //0prototypeprototype用于保存引用类型所有实例方法，在自定义类型时特别重要。注意prototype不可枚举。 函数方法（apply，call，bind） 这3种方法都是用于 设置调用函数时函数体内this对象的值。strict模式下，没有指定上下文的调用函数，函数的this不会指向window，而会变成undefinedapply()接收2个参数： param1 指定this param2 参数数组 function sum(num1, num2) return num1 + num2;function callSum1(num1, num2) return sum.apply(this, arguments);function callSum2(num1, num2) return sum.apply(this, [num1, num2]);console.log(callSum1(10, 20)); //30console.log(callSum2(20, 30)); //50 call()call方法和apply的不同之处在于：需要传递的参数是逐个传递的 function sum(num1, num2) return num1 + num2;function callSum(num1, num2) return sum.call(this, ...arguments);console.log(callSum(10, 20)); //30apply和call最强大就是控制函数调用上下文this的能力。 window.color = redlet o = color:bluefunction sayColor() console.log(this.color)sayColor();sayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //bluebind（ES5）bind和call、apply的区别在于bind会创建一个绑定了指定this的函数实例。window.color = red;var o = color:bluefunction sayColor() console.log(this.color);let objectSayColor = sayColor.bind(o);objectSayColor(); //blue提示toLocaleString() 和 toString() 始终返回函数代码，但是返回代码的具体格式会因浏览器而异，因此应该在重要功能是避免依赖这些方法的返回值。 10.3.5 函数表达式let functionName = function (arg1, arg2, arg3) ; 像这样创建的函数叫做 匿名函数（anonymous function），有时也被称为兰姆达（λ）函数 函数声明提升案例 使用函数声明会进行声明提升，如下面这段危险的代码：let condition = true;if (condition) function sayHi() console.log(Hi!) else function sayHi() console.log(Yo!) sayHi() // Hi也许浏览器会帮你纠正这段声明，关键在于不同浏览器纠正问题的方式不一致，所以尽量不要这么写。"},{"title":"10.4 函数调用技巧","path":"/wiki/JavaScript/chapter_10_4.html","content":"10.4.1 递归递归函数通常是指一个函数通过名称调用自己 但如果不将函数逻辑和函数名称解耦合，就可能会出现问题： function factorial(num) if (num = 1) return 1; else return num * factorial(num - 1); let anotherFactorial = factorial;factorial = null;//TypeError: factorial is not a functionconsole.log(anotherFactorial(10)); 使用arguments.callee可以解决硬编码问题 function factorial(num) if (num = 1) return num; else return num * arguments.callee(num - 1); 严格模式下解耦递归函数 严格模式下不能访问arguments.callee,可以使用命名函数表达式（named function expression）。const factorial = (function f(num) if (num = 1) return 1; else return num * f(num - 1); ) 10.4.2 尾调用优化尾调用 即外部函数返回值是一个内部函数的返回值function outerFunction() return innerFunction();ES6新增的一项内存管理优化机制：JS引擎在满足条件时可以重用栈帧，使尾调用更具优势。 比较ES6优化前后尾调用的执行步骤 优化前优化后outerFunction执行，推上①号栈帧执行到return，开始进入innerFunctioninnerFunction执行，推上②号栈帧执行到return，计算返回值resultresult传回outerFunctionouterFunction返回result弹出①②号栈帧结论：每多调用一次嵌套函数，就会多增加一个栈帧。outerFunction执行，推上①号栈帧执行到return，开始进入innerFunctionJS引擎检测innerFunction和outerFunction的返回值是否一致（结果一致）弹出①号栈帧执行到innerFunction，推上②号栈帧执行到return，计算返回值result弹出②号栈帧结论：无论调用多少次嵌套函数，都只有一个栈帧 尾调用优化的条件：确认外部栈帧真的没有存在必要了 涉及条件如下：“use strict”原因：非严格模式下函数存在arguments属性和caller方法，都会引用外部函数的栈帧。外部函数返回值是对尾调用函数的调用 违反优化条件use strict;// 尾调用没有返回function outerFunction() innerFunction(); 符合优化条件use strict;function outerFunction(a,b) return innerFunction(a+b); 尾调用函数返回后不需要执行额外的逻辑 违反优化条件use strict;// 尾调用没有直接返回function outerFunction() let innerFunctionRsult = innerFunction(); return innerFunctionResult;// 尾调用返回后必须转型为字符串function outerFunction() return innerFunction().toString(); 符合优化条件use strict;function outerFunction(a,b) if(ab) return a; return innerFunction(a+b); 尾调用函数不是引用外部函数作用域中自由变量的闭包 违反优化条件use strict;// 尾调用是一个闭包function outerFunction() let foo = bar; function innerFunction()return foo; return innerFunction(); 符合优化条件function outerFunction(condition) return condition?innerFunctionA():innerFunctionB(); Tips：尾调用优化在递归场景下效果最好。 尾调用优化的代码 下面是一段待优化的代码：function fib(num) if (num 2) return num; // 存在相加逻辑操作，不符合优化条件 return fib(num - 1) + fib(num - 2);console.log(fib(1)); //1console.log(fib(5)); //5let startTime = new Date();console.log(fib(20)); //6765console.log(new Date() - startTime); //1可以改写成迭代循环形式function fib(n) return fibImpl(0, 1, n);function fibImpl(a, b, n) if (n === 0) return a; return fibImpl(b, a + b, n - 1);console.log(fib(1)); //1console.log(fib(5)); //5let startTime = new Date();console.log(fib(100)); //354224848179262000000console.log(new Date() - startTime); //0 10.4.3 闭包（closure）闭包指的是引用了另一个函数作用域中变量的函数。 作用域链 在调用一个函数时，会进行这2步操作：创建一个执行上下文创建一个作用域链function outerFunction() function innerFunction()innerFunction作用域链：innerFunction - outerFunction - [ more ] outerFunction的活动对象是innerFunction作用域链上的第二个对象作用域链一直向外串起所有包含函数的活动对象作用域链终止于全局执行上下文 变量对象和活动对象 每个执行上下文中都会有一个包含其中变量的对象。 在全局上下文中就叫做变量对象在函数局部上下文中就叫做活动对象，只在函数执行期间存在 普通函数的作用域链 function compare(value1, value2) if(value1value2) return -1; else if(value1value2) return 1; else return 0; let result = compare(5,10); 定义compare函数经历步骤创建作用域链预装载全局变量对象全局变量对象保存在内部的[[Scope]]中 调用compare函数经历步骤创建相应执行上下文复制函数的[[Scope]]创建作用域链创建函数的活动对象将函数活动对象推入作用域链首函数执行完毕，销毁局部活动对象 普通函数作用域链指针示意图 匿名函数的作用域链 function createComparisionFunction(propertyName) return function(object1,object2) let value1 = object1[propertyName]; let value2 = object2[propertyName]; if(value1value2) return -1; else if(value1value2) return 1; else return 0; let compare = createComparisionFunction(name);let result = compare(name:Nicolas,name:Matt);匿名函数与普通函数的不同在于：外部函数（createComparisonFunction）执行完毕后，执行上下文的作用域链会销毁，但是活动对象仍然会保留在内存中，直到匿名函数被销毁后才能完全被销毁。这是因为匿名函数的作用域链中仍然有对它的引用。作为返回值的匿名闭包函数作用域链指针示意图解除对函数引用对策：手动释放内存let compareNames = createComparisonFunction(name);let result = compareNames(name:Nicholas,name:Rachel);// 解除占用compareNames = null;因为闭包函数会保留其外部函数的活动对象，因此比其他函数更占用内存，需谨慎使用。 闭包中的this 闭包中使用this会让代码变得复杂。window.identity = The Window;let object = identity: My Object, getIdentityFunc() return function () return this.identity; console.log(object.getIdentityFunc()()); //The Windowconsole.log(object.getIdentityFunc().apply(object)); //My Object保留this可以保证闭包函数的this与其外部函数的this一致window.identity = The Window;let object = identity: My Object, getIdentityFunc() let that = this; return function () return that.identity; console.log(object.getIdentityFunc()()); //My Object特殊情况分析window.identity = The Window;let object = identity: My Object, getIdentity() console.log(this.identity); object.getIdentity(); //My Object(object.getIdentity)(); //My Object(object.getIdentity = object.getIdentity)(); //The Window第一行：obejct.getIdentity()普通函数中this指向调用函数的上下文，因为这里调用函数的上下文是object，因此这里的this就是object第二行：(object.getIdentity)()按照规范，object.getIdenitty (object.getIdentity)，因此this还是object第三行：(object.getIdentity object.getIdentity)()因为赋值表达式右侧的值是函数本身，并非函数引用，因此这里this的值不再与任何对象绑定，所以this指向的是window 内存泄漏 function assignHandler() let element = document.getElementById(someElement); element.onclick = () = console.log(element.id);上面的代码中匿名函数的存在导致element始终被引用，其内存不会被回收。因此可以进行手动回收。 function assignHandler() let element = document.getElementById(someElement); let id = element.id; element.onclick = () = console.log(id); element = null; 10.4.4 立即调用的函数表达式立即调用的函数表达式（IIFE，Immediately Invoked Function Expression） (function() // 块级作用域)(); IIFE主要用于模拟块级作用域 主要针对于ECMAScript5.1之前不支持块级作用域的情况。let count = 5;(function () for (let i = 0; i count; i++) console.log(i); )(); // 0 1 2 3 4因为不存在对这个匿名函数的引用，因此只要函数执行完毕其作用域链就会被销毁。 ECMAScript6以后出现了块级作用域： let i; for (i = 0; i couhnt; i++) console.log(i); console.log(i); //Error IIFE还可以用来锁定参数值 let divs = document.querySelectorAll(div);for (var i = 0; i divs.length; ++i) divs[i].addEventListener(click, function () console.log(i); )以上这段代码会导致每次触发click都打印同样的值，可以通过下面方式锁定索引值：let divs = document.querySelectorAll(div);for (var i = 0; i divs.length; ++i) divs[i].addEventListener(click, (function (frozenCounter) return function () console.log(frozenCounter); )(i));使用 ECMAScript6 块级作用域就简单那多了：let divs = document.querySelectorAll(div);for (let i = 0; i divs.length; ++i) divs[i].addEventListener(click, function () console.log(i); )当然要保证for循环使用块级作用域变量关键字：let divs = document.querySelectorAll(div);let i;for (i = 0; i divs.length; ++i) divs[i].addEventListener(click, function () console.log(i); //same output ) 10.4.5 私有变量JavaScript任何定义在函数或块中的变量，都可以认为是私有的。 闭包与私有变量 如果在函数中创建一个能通过作用域链访问外部函数变量的闭包，就能够创建出访问私有变量的公有方法。 特权方法（privileged method） 特权方法指的是能够访问函数私有变量方法的公有方法。方法一：在构造函数中实现即在构造函数中定义私有变量和私有方法，再创建一个能够访问这些私有成员的特权方法：function Person(name) this.getName = function () return name; ; this.setName = function (value) name = value; let person = new Person(Nicholas);console.log(person.getName()); //Nicholasperson.setName(Greg);console.log(person.getName()); //Greg方法二：使用私有作用域定义私有变量和函数(function () let privateVariable = 10; function privateFunction() return false; MyObject = function () ; MyObject.prototype.publicMethod = function () privateVariable++; return privateFunction(); )();这种方式存在的问题是：实例共享私有变量和私有函数：(function () let name = ; Person = function (value) name = value; ; Person.prototype.getName = function () return name; Person.prototype.setName = function (value) name = value; )();let person1 = new Person(Nicholas);console.log(person1.getName()); //Nicholasperson1.setName(Matt);console.log(person1.getName()); //Mattlet person2 = new Person(Michael);console.log(person2.getName()); //Michaelconsole.log(person1.getName()); //Michael 模块模式 模块模式是在单例对象基础上的扩展。let singleton = function () let proivateVariable = 10; function privateFunction() return false; return publicProperty: true, publicMethod() privateVariable++; return privateFunction(); ();如果单例对象需要进行某种初始化， 并且需要访问私有变量时， 可以采用这个模式： let application = function () let components = new Array(); components.push(new BaseComponent()); return getComponentCount() return components.length; , registerComponent(component) if (typeof component == object) components.push(component); ();单例模式与组件管理Web开发中，经常需要单例对象管理应用程序级的信息，比如在页面组件的管理上。 模块增强模式 增强模式即在返回对象之前对其进行增强，这适合单例对象需要时某个特定类型的实例，但又必须给它添加额外属性或方法的场景。 let singleton = function () let privateVariable = 10; function privateFunction() return false; let object = new CustomType(); object.publicProperty = true; object.publicMethod = function () privateVariable++; return privateFunction(); ; return object;重写单例模式中的application对象：let application = function () let components = new Array(); components.push(new BaseComponent()); let app = new BaseComponent(); app.getComponentCount = function () return components.length; ; app.getComponentCount = function (component) if (typeof component == object) components.push(component); ; return app;"},{"title":"11.1 异步编程","path":"/wiki/JavaScript/chapter_11_1.html","content":"同步与异步 在JavaScript这种单线程事件循环模型中，同步操作与异步操作是代码要依赖的核心机制。异步行为是为了优化因计算量大而花费时间长的操作。 11.1.1 同步与异步 同步行为对应内存中顺序执行的处理器指令。每条指令严格按照出现顺序执行，执行后立即获得存储在系统本地的信息。let x = 3;x = x + 4; 异步行为异步行为类似于系统中断。即当前进程外部的实体可以触发代码执行，常用于访问一些高延迟的资源。 let x = 3;setTimeout(() = x = x + 4, 1000); 预知异步执行的变化 异步执行由系统计时器触发，会生成一个入队执行的中断，中断何时触发则是无法预知的，但可以保证中断发生在当前线程的同步代码执行以后。 11.1.2 以往的异步编程模式回调地狱 早期JS中只支持回调函数来表明异步操作完成，因此常常会串联多个异步操作，俗称回调地狱（深度嵌套的回调函数）。function double(value) setTimeout(() = setTimeout(console.log, 0, value * 2), 1000);double(3); //6上面的例子中，double函数在setTimeout成功调度异步操作之后就会立即退出。 1.异步返回值 常用的策略是：给异步操作提供一个包含要使用异步返回值代码的回调函数。 function double(value, callback) setTimeout(() = callback(value * 2), 1000);// I was given 6double(3, (x) = console.log(`I was given: $x`)); 2.失败处理 考虑到异步操作也可能存在失败处理，因此就分化出了成功回调和失败回调。这种模式必须在初始化异步操作时定义回调。 function double(value, success, failure) setTimeout(() = try if (typeof value !== number) throw Must provide number as first argument; success(2 * value); catch (e) failure(e); , 1000);const successCallback = (x) = console.log(`Success: $x`);const failureCallback = (e) = console.log(`Failure: $e`);// Success: 6double(3, successCallback, failureCallback);// Failure: Must provide number as first argumentdouble(b, successCallback, failureCallback); 3.嵌套异步回调 在异步返回值需要依赖另一个异步返回值时，回调情况还会进一步变复杂： function double(value, success, failure) setTimeout(() = try if (typeof value !== number) throw Give me a number. success(value * 2); catch (e) failure(e); , 1000);const successCallback = (x) = double(x, (y) = console.log(`Success:$y`));const failureCallback = (e) = console.log(`Failure: $e`);double(3, successCallback, failureCallback); //Syccess:12 回调策略不具有扩展性，“回调地狱”实至名归。"},{"title":"11.2 期约","path":"/wiki/JavaScript/chapter_11_2.html","content":"期约是对尚不存在的结果的一个替身。 期约（Promise）还有以下别称 终局 （eventual）期许 （future）延迟 （delay）迟付 （deferred） 11.2.1 PromisesA+规范Promise起源 早期 期约机制在jQuery和Dojo中以 Deferred API 的形式出现 2010 CommonJS项目实现了 PromisesA2012 PromieseA+ 组织fork了CommonJS的 PromisesA 建议最终 ECMAScript6增加了 Promise 类型 11.2.2 期约基础new Promise() Promise作为引用类型时可以通过new操作符实例化，实例化时需要传入 执行器（executor） 函数作为参数。 如果不提供executor参数会报错。let p = new Promise(() = );setTimeout(console.log, 0, p); //Promisepending 1.期约状态机 期约可能处在下面3种状态之一：待定 （pending） 表示尚未开始或正在执行兑现解决 （fulfilledresolved） 表示已经成功完成拒绝 （rejected） 表示没有成功完成初始状态期约处于 待定（pending） 状态中。待定状态期约可以 落定（settled） 为2种状态： 兑现（fulfilled） 状态代表成功拒绝（rejected） 状态代表失败期约状态是私有的这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。期约故意将异步行为封装起来，从而隔离外部的同步代码。2.解决值、拒绝理由及期约用例 期约的两个主要用途抽象表示一个异步操作是否完成期约封装异步操作会实际生成某个状态改变后需要访问的值为了支持这两个用途，期约提供了两个私有的内部属性（可选，默认值为undefined）：value（值）： 期约状态切换为兑现时提供reason（理由）： 期约状态切换为拒绝时提供3.通过执行函数控制期约状态 executor的两项职责初始化期约的异步行为控制状态的最终转换控制期约转换的2个函数参数通常这样命名：resolve() 将状态切换为fulfilledreject() 将状态切换为rejectedexecutor函数是Promise的初始化程序。下面这段程序并非异步操作，因为在初始化Promise时，executor已经改变了Promise的状态。let p1 = new Promise((resolve, reject) = resolve());// Promisefulfilled: undefinedsetTimeout(console.log, 0, p1);let p2 = new Promise((resolve, reject) = reject());// Promiserejected: undefinedsetTimeout(console.log, 0, p2); // Uncaught (in promise)使用setTimeout推迟切换状态，可以看到Promise仍处在pending状态中：let p = new Promise((resolve, reject) = setTimeout(resolve, 1000));setTimeout(console.log, 0, p); //PromisependingPromise状态的转换不可撤销，修改状态操作静默失败：let p = new Promise((resolve, reject) = resolve(); reject(););// Promise fulfilled: undefinedsetTimeout(console.log, 0, p); 为了防止长时间卡在pending状态，可以添加一个定时退出的功能：let p = new Promise((resolve, reject) = setTimeout(reject, 5000);)// Promise pendingsetTimeout(console.log, 0, p); //Uncaught: (in promise)// Promise rejectedsetTimeout(console.log, 6000, p);4.Promise.resolve() 功能调用 Promise.resolve() 静态方法可以实例化一个 resolved Promise ，实际上它可以 把任何值都转换为一个Promise对象 。参数Promise.resolve() 的第一个参数表示解决的期约的返回值 value 。多余的参数会被忽略。// Promiseresolved: undefinedsetTimeout(console.log, 0, Promise.resolve());// Promiseresolved: 3setTimeout(console.log, 0, Promise.resolve(3));// Promiseresolved: 4setTimeout(console.log, 0, Promise.resolve(4, 5, 6));幂等性传入参数如果本身就是Promise对象，就相当于空包装。let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p)); //truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))); //true这种幂等性还会保留传入期约的状态。 let p = new Promise(() = );// Promise pendingsetTimeout(console.log, 0, p);// Promise pendingsetTimeout(console.log, 0, Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(p));5.Promise.reject() 功能实例化一个 rejective Promise 并抛出一个异步错误，异步错误 不能通过trycatch捕捉，只能通过 拒绝程序 捕获。 参数Promise.reject() 的第一个参数作为 拒绝期约的理由，该理由会顺次传给后续的拒绝程序。 let p = Promise.reject(3);// Promise rejected: 3setTimeout(console.log, 0, p);p.then(null, (e) = setTimeout(console.log, 0, e)); //3非幂等性传给 Promise.reject 一个Promise对象作为参数，该对象会作为拒绝期约的理由。//Promise rejected: PromisesetTimeout(console.log, 0, Promise.reject(Promise.resolve(3)));6.同步异步执行的二元性 对比同步异步模式下捕捉错误的区别 try throw new Error(foo); catch (e) console.log(e); //Error: foo try Promise.reject(new Error(bar)); catch (e) console.log(e);//Uncaught (in promise) Error: bar Promise真正的异步性在于：Promise是 同步对象 ，也是 异步执行模式 的媒介。同步模式： 错误直接抛到执行同步代码的线程中异步模式： 错误通过浏览器异步消息队列来处理 11.2.3 期约的实例方法1.实现Thenable接口 如何实现？答：在对象上实现 then 方法。 class MyThenable then()ECMAScript暴露的 异步结构中的任何对象 都有一个then方法。 2.Promise.prototype.then() then方法的参数与返回值then方法接收2个可选的参数：param1 onResolved处理程序（如果选择不传，需要使用nullundefined占位）param2 onRejected处理程序function onResolved(id) setTimeout(console.log, 0, id, resolved);;function onRejected(id) setTimeout(console.log, 0, id, rejected);let p1 = new Promise((resolve, reject) = setTimeout(resolve, 1000));let p2 = new Promise((resolve, reject) = setTimeout(reject, 1000));// p1 resolvedp1.then(()=onResolved(p1), ()=onRejected(p1)); // p2 rejectedp2.then(()=onResolved(p2), ()=onRejected(p2)); 如果参数非函数类型，会被 静默忽略。如果只想提供onRejected参数，需要对onResolved参数进行 占位。function onResolved(id) setTimeout(console.log, 0, id, resolved);function onRejected(id) setTimeout(console.log, 0, id, rejected);let p1 = new Promise((resolve, reject) = setTimeout(resolve, 1000));let p2 = new Promise((resolve, reject) = setTimeout(reject, 1000));// 非函数处理程序：静默p1.then(notFunction);// onResolved占位p2.then(undefined, () = onResolved(p2)); //p2 rejectedPromise.prototype.then返回值：一个新的期约实例。let p1 = new Promise(() = );let p2 = p1.then();setTimeout(console.log, 0, p1); //Promise pendingsetTimeout(console.log, 0, p2); //Promise pendingsetTimeout(console.log, 0, p1 === p2); false;对于不同返回值的几种情况：onResolved函数提供了返回值会将返回值通过Promise.resolve()包装成新的期约。 let p6 = p1.then(() = bar);let p7 = p1.then(() = Promise.resolve(bar));setTimeout(console.log, 0, p6); // Promisefulfilled: barsetTimeout(console.log, 0, p7); // Promisefulfilled: barlet p8 = p1.then(() = new Promise(() = ));let p9 = p1.then(() = Promise.reject());//Uncaught (in promise) undefinedsetTimeout(console.log, 0, p8); //Promise pendingsetTimeout(console.log, 0, p9); //Promise rejected: undefined没有提供onResolved函数会包装上一个期约解决之后的值。 let p1 = Promise.resolve(foo);let p2 = p1.then();setTimeout(console.log, 0, p2); //Promisefulfilled: foolet p8 = p1.then(() = new Promise(() = ));let p9 = p1.then(() = Promise.reject());//Uncaught (in promise) undefinedsetTimeout(console.log, 0, p8); //Promise pendingsetTimeout(console.log, 0, p9); //Promise rejected: undefinedonResolved函数没有显式返回语句会包装默认返回值 undefined。 let p3 = p1.then(() = undefined); let p4 = p1.then(() = );let p5 = p1.then(() = Promise.resolve());setTimeout(console.log, 0, p3); // Promisefulfiled: undefinedsetTimeout(console.log, 0, p4); // Promisefulfiled: undefinedsetTimeout(console.log, 0, p5); // Promisefulfiled: undefined抛出异常会返回 rejective Promise。 // Uncaught (in promise) bazlet p10 = p1.then(() = throw baz; );setTimeout(console.log, 0, p10); //Promise rejected baz返回错误值不会触发reject，会将错误对象包装在一个 resolved Promise 中。 let p11 = p1.then(() = Error(qux));setTimeout(console.log, 0, p11); //Promise fulfilled: Error:quxonRejected处理程序返回值也会被 Promise.resolve() 包装，虽然有点诡异，但是 onRejected 本身的任务就是 捕获异步错误，也就是 捕获错误后不抛出异常 。 onRejected返回值案例let p1 = Promise.reject(foo);let p2 = p1.then();// Promise rejected: foo// Uncaught (in promise) foosetTimeout(console.log, 0, p2);let p3 = p1.then(null, () = undefined);let p4 = p1.then(null, () = );let p5 = p1.then(null, () = Promise.resolve());setTimeout(console.log, 0, p3); // Promise rejected: undefinedsetTimeout(console.log, 0, p4); // Promise rejected: undefinedsetTimeout(console.log, 0, p5); // Promise rejected: undefinedlet p6 = p1.then(null, () = bar);let p7 = p1.then(null, () = Promise.resolve(bar));setTimeout(console.log, 0, p6); // Promise rejected: barsetTimeout(console.log, 0, p7); // Promise rejected: barlet p8 = p1.then(null, () = new Promise(() = ));let p9 = p1.then(null, () = Promise.reject());setTimeout(console.log, 0, p8); // Promise pending// Promise rejected: undefined// Uncaught (in promise) undefinedsetTimeout(console.log, 0, p9); let p10 = p1.then(null, () = throw baz );// Promise rejected:baz// Uncaught (in promise) bazsetTimeout(console.log, 0, p10); let p11 = p1.then(null, () = Error(qux));// Promise rejected:Error:quxsetTimeout(console.log, 0, p11);3.Promise.prototype.catch() catch的功能与参数catch用于 给期约添加拒绝处理程序。唯一参数是 onRejected处理程序。相当于 Promise.prototype.then(null, onRejected) 的语法糖。let p1 = new Promise(() = );let p2 = p1.catch();setTimeout(console.log, 0, p1); // Promise pendingsetTimeout(console.log, 0, p2); // Promise pendingsetTimeout(console.log, 0, p1 === p2); //false4.Promise.prototype.finally() finally的功能与参数finally()方法用于 给期约添加onFinally处理程序。onFinally无论Promise转化为 fulfilled 还是 rejected ，onFinally都会执行，用这个方法能够避免 onResolved 和 onRejected 程序中出现冗余代码。onFinally无法获知Promise的状态，所以这个方法主要用于添加清理代码。let p1 = Promise.resolve();let p2 = Promise.reject();let onFinally = function () setTimeout(console.log, 0, Finally!);p1.finally(onFinally); // Finally!p2.finally(onFinally); // Finally!finally()与catch()、then()的区别主要就是onFinally被设计为一个 状态无关的方法，重点在于 父期约的传递 上。 let p1 = Promise.resolve(foo);let p2 = p1.finally();let p3 = p1.finally(() = undefined);let p4 = p1.finally(() = );let p5 = p1.finally(() = Promise.resolve());let p6 = p1.finally(() = bar);let p7 = p1.finally(() = Promise.resolve(bar));let p8 = p1.finally(() = Error(qux));setTimeout(console.log, 0, p2); //Promise fulfilled:foosetTimeout(console.log, 0, p3); //Promise fulfilled:foosetTimeout(console.log, 0, p4); //Promise fulfilled:foosetTimeout(console.log, 0, p5); //Promise fulfilled:foosetTimeout(console.log, 0, p6); //Promise fulfilled:foosetTimeout(console.log, 0, p7); //Promise fulfilled:foosetTimeout(console.log, 0, p8); //Promise fulfilled:foo特殊情况下的finally返回值当出现下列情况时，会返回相应的期约： 期约待定：Promise {pending} onFinally程序抛出了错误 onFinally程序显式抛出或返回了一个 rejective Promise let p1 = Promise.resolve(foo);// 返回待定期约let p2 = p1.finally( () = new Promise( (resolve, reject) = setTimeout(() = resolve(bar), 100) ));setTimeout(console.log, 0, p2); // Promise pendingsetTimeout(() = setTimeout(console.log, 0, p2), 200); //Promise fulfilled: foolet p9 = p1.finally(() = new Promise(() = ));let p10 = p1.finally(() = Promise.reject());// Uncaught (in promise) undefinedsetTimeout(console.log, 0, p9); // Promise pendingsetTimeout(console.log, 0, p10); // Promise rejected: undefined5.非重入期约的方法 非重入（non-reentrancy）特性当期约进入 fulfilled 状态时，相关异步处理程序不会立即执行，仅仅会被 排期 ，其后的同步代码一定会在它之前执行。 // 创建解决的期约let p = Promise.resolve();// 添加解决处理程序p.then(() = console.log(`onResolved handler`));// 同步操作console.log(then() returns);// then() returns// onResolved handler先添加处理程序后解决期约。let synchronousResolve;// 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) = synchronousResolve = function () console.log(1); resolve(); console.log(2); ;);p.then(() = console.log(4));synchronousResolve();console.log(3); //1 2 3 4非重入适用范围。 onResolvedonRejected catch finally let p1 = Promise.resolve();p1.then(() = console.log(p1.then() onResolved));console.log(p1.then() returns);let p2 = Promise.reject();p2.then(null, () = console.log(p2.then() onRejected));console.log(p2.then() returns)let p3 = Promise.reject();p3.catch(() = console.log(p3.catch() onRejected));console.log(p3.catch() returns)let p4 = Promise.resolve();p4.finally(() = console.log(p4.finally() onFinally));console.log(p4.finally() returns)// p1.then() returns// p2.then() returns// p3.catch() returns// p4.finally() returns// p1.then() onResolved// p2.then() onRejected// p3.catch() onRejected// p4.finally() onFinally6.邻近处理程序的执行顺序 同一期约多个处理程序按照添加顺序执行let p1 = Promise.resolve();let p2 = Promise.reject();p1.then(() = setTimeout(console.log, 0, 1));p1.then(() = setTimeout(console.log, 0, 2));//1 2p2.then(null,() = setTimeout(console.log, 0, 3));p2.then(null, () = setTimeout(console.log, 0, 4));// 3 4p2.catch(() = setTimeout(console.log, 0, 5));p2.catch(() = setTimeout(console.log, 0, 6));// 5 6p1.finally(() = setTimeout(console.log, 0, 7));p1.finally(() = setTimeout(console.log, 0, 8));// 7 87.传递解决值和拒绝理由 在进入fulfilled状态后，期约会提供valuereason给相关状态的处理程序。 let p1 = new Promise((resolve, reject) = resolve(foo));p1.then((value) = console.log(value)); //foolet p2 = new Promise((resolve, reject) = reject(bar));p2.catch((reason) = console.log(reason)); //barlet p3 = Promise.resolve(foo);p3.then((value) = console.log(value)); //foolet p4 = Promise.reject(bar);p4.catch((reason) = console.log(reason)); //bar8.拒绝期约与拒绝错误处理 在期约执行处理时抛出错误会导致拒绝let p1 = new Promise((resolve, reject) = reject(Error(foo)));let p2 = new Promise((resolve, reject) = throw Error(foo) );let p3 = Promise.resolve().then(() = throw Error(foo) );let p4 = Promise.reject(Error(foo));setTimeout(console.log, 0, p1); //Promise rejected: Error:foosetTimeout(console.log, 0, p2); //Promise rejected: Error:foosetTimeout(console.log, 0, p3); //Promise rejected: Error:foosetTimeout(console.log, 0, p4); //Promise rejected: Error:foo异步错误的副作用正常情况下抛出的错误会阻塞后续指令的执行： // Uncaught Error: foothrow Error(foo);console.log(bar); // 无效代码 期约中抛出的错误不会阻塞后续同步指令的执行： // Error: foo// barPromise.reject(Error(foo));console.log(bar); 对比同步错误与异步错误处理 同步错误处理// 1// 3 Error:2// 4console.log(1);try throw Error(2); catch (e) console.log(3,e);console.log(4); 异步错误处理// 1// 3 Error:2// 4new Promise((resolve, reject) = console.log(1); reject(Error(2));).catch((e) = console.log(3, e);).then(() = console.log(4);) 11.2.4 期约连锁与期约合成 期约连锁一个期约接一个期约的拼接。 期约合成将多个期约组合为一个期约。 1.期约连锁 通过连缀方法调用就可以构成所谓的 期约连锁：let p = new Promise((resolve, reject) = console.log(first); resolve(););// first second third fourthp.then(() = console.log(second)) .then(() = console.log(third)) .then(() = console.log(fourth));串行化异步任务每个执行器都返回一个期约实例，每个后续期约都等待之前的期约。 let p1 = new Promise((resolve, reject) = console.log(p1 executor); setTimeout(resolve, 1000);)p1.then(() = new Promise((resolve, reject) = console.log(p2 executor); setTimeout(resolve, 1000);)).then(() = new Promise((resolve, reject) = console.log(p3 executor); setTimeout(resolve, 1000);)).then(() = new Promise((resolve, reject) = console.log(p4 executor); setTimeout(resolve, 1000);));// p1 executor// p2 executor// p3 executor// p4 executor将生成期约代码提取成工厂函数function delayedResolve(str) return new Promise((resolve, reject) = console.log(str); setTimeout(resolve, 1000); )delayedResolve(p1 executor) .then(() = delayedResolve(p2 executor)) .then(() = delayedResolve(p3 executor)) .then(() = delayedResolve(p4 executor));// p1 executor// p2 executor// p3 executor// p4 executor使用回调函数重写连锁期约（回调地狱）function delayedExecute(str, callback = null) setTimeout(() = console.log(str); callback callback(); , 1000);delayedExecute(p1 callback, () = delayedExecute(p2 callback, () = delayedExecute(p3 callback, () = delayedExecute(p4 callback); ) ));// p1 callback// p2 callback// p3 callback// p4 callback串联期约的相关方法let p = new Promise((resolve, reject) = console.log(initial promise rejects); reject(););p.catch(() = console.log(reject handler)) .then(() = console.log(resolve handler)) .finally(() = console.log(finally handler));// initial promise rejects// reject handler// resolve handler// finally handler2.期约图 期约连锁的结构类似于 有向非循环图：一对多关系： 一个期约可以有任意多个处理程序节点： 组成连锁期约的每一个期约有向顶点： 使用实例添加的处理程序层序遍历： 期约处理程序是按照添加顺序执行的// A// / \\// B C// / \\ / \\// D E F Glet A = new Promise((resolve, reject) = console.log(A); resolve(););let B = A.then(() = console.log(B));let C = A.then(() = console.log(C));B.then(() = console.log(D));B.then(() = console.log(E));C.then(() = console.log(F));C.then(() = console.log(G));// A B C D E F G3.Promise.all()和Promise.race() 合成期约方法Promise.all()Promise.race()功能： 创建一个期约，该期约会在一组期约全部解决后再解决存在一个待定期约，合成期约也待定存在一个拒绝期约，合成期约也拒绝参数： 可迭代对象返回值： 一个新期约合成期约解决值： 所有包含期约解决值的数组，按照迭代器顺序合成期约拒绝理由： 即第一个拒绝的期约的理由Promise.all()参数let p1 = Promise.all([ Promise.resolve(), Promise.resolve()]);// 可迭代对象中的元素会通过Promise.resolve()转换为期约let p2 = Promise.all([3, 4]);// 空的可迭代对象等价于Promise.resolve()let p3 = Promise.all([]);// 无效语法// TypeError: undefined is not iterable let p4 = Promise.all();合成期约在每个期约都解决后才解决let p = Promise.all([ Promise.resolve(), new Promise((resolve, reject) = setTimeout(resolve, 1000))]);setTimeout(console.log, 0, p); //Promise pending// after 1s: all() resolved! p.then(() = setTimeout(console.log, 0, all() resolved!));合成期约的pendinng和rejected条件let p1 = Promise.all([new Promise(() = )]);setTimeout(console.log, 0, p1); // Promise pendinglet p2 = Promise.all([ Promise.resolve(), Promise.reject(), Promise.resolve()]);setTimeout(console.log, 0, p2); // Promise rejected合成期约的解决值let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4)]);p.then((value) = setTimeout(console.log,0,value)); // [3,undefined,4]合成期约会静默处理所有包含期约的拒绝操作let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) = setTimeout(reject, 1000))])p.catch((reason) = setTimeout(console.log, 0, reason)); //3功能： 返回一个包装期约，该期约是一组集合中最先解决拒绝的期约的镜像不会对解决或拒绝的期约区别对待会静默处理所有包含期约的拒绝操作参数： 可迭代对象返回值： 一个新期约Promise.race()参数let p1 = Promise.race([ Promise.resolve(), Promise.resolve()]);// 可迭代对象中的元素会通过Promise.resolve转换为期约let p2 = Promise.race([3, 4]);// 空的迭代对象等价于new Promise(()=)let p3 = Promise.race([]);// 无效语法// TypeError: undefined is not iterablelet p4 = Promise.race();Promise.race()返回值// 先解决let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) = setTimeout(reject, 1000))]);setTimeout(console.log, 0, p1); //Promise fulfilled:3// 先拒绝let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) = setTimeout(resolve, 1000))]);setTimeout(console.log, 0, p2); //Promise rejected:4// 迭代顺序决定落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.reject(7),]);setTimeout(console.log, 0, p3); //Promise fulfilled:5Promise.race()对拒绝操作的静默处理let p = Promise.race([ Promise.reject(3), new Promise((resolve, reejct) = setTimeout(reject, 1000))]);p.catch((reason) = setTimeout(console.log, 0, reason)); //34.串行期约合成 基于期约的一个主要特性：异步产生值并将其传给处理程序。函数合成function addTwo(x) return x + 2; function addThree(x) return x + 3; function addFive(x) return x + 5; function addTen(x) return addFive(addThree(addTwo(x)));console.log(addTen(10)); //20使用期约重现函数合成function addTwo(x) return x + 2; function addThree(x) return x + 3; function addFive(x) return x + 5; function addTen(x) return Promise.resolve(x) .then(addTwo) .then(addThree) .then(addFive);addTen(8).then(console.log); //18使用Array.prototype.reduce()再简化function addTwo(x) return x + 2; function addThree(x) return x + 3; function addFive(x) return x + 5; function addTen(x) return [addTwo, addThree, addFive] .reduce( (promise, fn) = promise.then(fn), Promise.resolve(x) );addTen(5).then(console.log); //15提炼通用合成函数function addTwo(x) return x + 2; function addThree(x) return x + 3; function addFive(x) return x + 5; function compose(...fns) return (x) = fns.reduce( (promise, fn) = promise.then(fn), Promise.resolve(x) )compose( addTwo, addFive, addThree)(11).then(console.log); //21 11.2.5 期约扩展为什么ES6不支持取消期约和进度通知？ 一个主要原因就是这样会导致 期约连锁 和 期约合成 过度复杂化。 下面涉及到两个第三方期约库中具备但是ECMAScript未涉及的特性。 期约取消进度追踪一般针对于期约正在处理过程中，程序不再需要结果的情形。ES6被认为是“激进的”因为期约的逻辑只要开始执行，就无法阻止其执行到完成。取消令牌（cancel token）提供一种临时性的封装。生成的令牌实例提供一个接口，可以用于取消期约。同时也提供一个期约实例，用来触发取消后操作并求值取消状态。class CancelToken constructor(cancelFn) this.promise = new Promise((resolve, reject) = cancelFn(resolve); ) 取消令牌案例存在问题： 尽管本案例的思路是在触发开始按钮的时候，对取消按钮进行事件绑定。但是由于没有手动进行事件解绑，因此导致取消按钮事件会不断堆叠。解决方法：在添加事件监听器时将option.once配置为true，表示仅触发一次事件。 cancelButton.addEventListener(click,cancelCallback,once:true); button id=startStart/buttonbutton id=cancelCancel/button class CancelToken constructor(cancelFn) this.promise = new Promise((resolve, reject) = cancelFn(() = setTimeout(console.log, 0, delay cancelled); resolve(); ) ) const startButton = document.querySelector(#start);const cancelButton = document.querySelector(#cancel);function cancellableDelayedResolve(delay) setTimeout(console.log, 0, set delay); return new Promise((resolve, reject) = const id = setTimeout(() = setTimeout(console.log, 0, delayed resolve); resolve(); , delay); const cancelToken = new CancelToken( cancelCallback = cancelButton.addEventListener(click, cancelCallback) ); cancelToken.promise.then(() = clearTimeout(id)); )startButton.addEventListener(click, () = cancellableDelayedResolve(1000));简化版取消期约实现思路 相比取消令牌方法更加简单粗暴，即是将开始按钮触发事件包装成异步操作，给取消按钮添加提前resolve事件，在期约进入resolve状态时对取消按钮进行解绑。相较官方案例扩展度更低，但简单粗暴。 function cancellableDelayedResolve(delay) setTimeout(console.log, 0, start); let cancelCallback; new Promise((resolve, reject) = let id = setTimeout(() = console.log(finished); resolve(); , 1500); cancelCallback = () = console.log(cancel); clearTimeout(id); resolve(); cancelButton.addEventListener(click,cancelCallback); ).finally(() = cancelButton.removeEventListener(click, cancelCallback); )startButton.addEventListener(click, cancellableDelayedResolve); asyncawait实现取消期约let startButton = document.querySelector(#start);let cancelButton = document.querySelector(#cancel);async function cancellableDelayedResolve(delay) setTimeout(console.log, 0, start); let id = setTimeout(console.log, delay, await finished); cancelButton.addEventListener(click, () = clearTimeout(id); console.log(cancel) , once: true );startButton.addEventListener(click, () = cancellableDelayedResolve(1000));有种实现期约进度追踪的方法：扩展Promise类，添加 notify() 方法：class TrackablePromise extends Promise constructor(executor) const notifyHandlers = []; super((resolve, reject) = return executor(resolve, reject, (status) = notifyHandlers.map((handler) = handler(status)); ); ); this.notifyHandlers = notifyHandlers; notify(notifyHandler) this.notifyHandlers.push(notifyHandler); return this; let p = new TrackablePromise((resolve, reject, notify) = function countdown(x) if (x 0) notify(`$20 * x% remaining`); setTimeout(() = countdown(x - 1), 1000); else resolve(); countdown(5););p.notify((x) = setTimeout(console.log, 0, a:, x)) .notify((x) = setTimeout(console.log, 0, b:, x));p.then(() = setTimeout(console.log, 0, completed));// a: 80% remaining// b: 80% remaining// a: 60% remaining// b: 60% remaining// a: 40% remaining// b: 40% remaining// a: 20% remaining// b: 20% remaining// completed"},{"title":"11.3 异步函数","path":"/wiki/JavaScript/chapter_11_3.html","content":"ES8之前的异步调用 任何要访问期约产生值的代码，都需要以处理程序的形式来接受此值：function handler(x) console.log(x); let p = new Promise((resolve, reject) = setTimeout(resolve, 1000, 3));p.then(handler); //3这种书写方式相当笨重，ES8新增了 asyncawait 关键字，让以同步方式写的代码能够异步执行。 11.3.1 异步函数asyncawaitasync用于声明异步函数async语法适用范围： 函数声明 函数表达式 箭头函数 方法 async function foo() //函数声明let bar = async function () ; //函数表达式let baz = async () = ; //箭头函数class Qux async qux() //方法 async功能让函数具有异步特征，但总体上代码仍然是同步求值。 async function foo() console.log(1);foo();console.log(2); //1 2async返回值始终返回 期约对象。返回值会被 Promise.resolve() 包装为一个期约对象。 async function foo() console.log(1); return 3; // 相当于 return Promise.resolve(3)foo().then(console.log);console.log(2); // 1 2 3 async返回值的静默处理async函数的返回值实际期待的是：一个实现thenable接口的对象对于是否实现了这一条件，async会对返回值采取不同的静默处理方式： 实现thenable接口 在调用返回值的then方法时，可以提供onResolveonRejected处理程序以供解包 未实现thenable接口 返回值被当做已经已解决的期约 返回一个原始值async function foo() return foo;foo().then(console.log); // foo 返回一个没有实现thenable接口的对象async function bar() return [bar];bar().then(console.log); //[bar] 返回一个实现了thenable接口的对象async function baz() const thenable = then(callback) callback(baz); ; return thenable;baz().then(console.log); //baz 返回一个期约async function qux() return Promise.resolve(qux);qux().then(console.log); //qux 异步函数中抛出错误会返回拒绝期约 async function foo() console.log(1); throw 3;foo().catch(console.log);console.log(2); //1 2 3拒绝期约的错误不会被异步函数捕获 async function foo() console.log(1); Promise.reject(3);foo().catch(console.log);console.log(2);//1 2 //Uncaught (in promise) 3await可以暂停异步函数代码的执行，等待期约解决await功能await关键字会 暂停执行异步函数后面的代码 。 第一步尝试解包对象的值。第二步将值传给表达式。第三步异步恢复异步函数的执行。 async function foo() let p = new Promise((resolve, reject) = setTimeout(resolve, 1000, 3)); console.log(await p);foo(); //3 await用法用法相当于 一元操作符： 异步打印”foo“async function foo() console.log(await Promise.resolve(foo));foo(); //foo 异步打印”bar“async function bar() return await Promise.resolve(bar);bar().then(console.log); //bar 1000ms后异步打印”baz“async function baz() await new Promise((resolve, reject) = setTimeout(resolve, 1000)); console.log(baz);baz(); //bazawait的静默处理await关键字实际期待的是：一个实现了thenable接口的对象对于是否实现thenable接口，await对其也有不同的静默处理方式： 实现了thenable接口： await会对其进行解包 未实现thenable接口： 默认包装为已解决的期约 await一个原始值async function foo() console.log(await foo);foo(); //foo await一个没有实现thenable接口的对象async function bar() console.log(await [bar]);bar(); //[bar] await一个实现了thenable接口的对象async function baz() const thenable = then(callback) callback(baz); ; console.log(await thenable);baz(); //baz await一个期约async function qux() console.log(await Promise.resolve(qux));qux(); //quxawait抛出错误的同步操作会返回拒绝的期约。 async function foo() console.log(1); await (() = throw 3; ) ();foo().catch(console.log);console.log(2); // 1 2 3await拒绝的期约会 释放（unwrap）错误值。即直接将拒绝期约作为返回值return。 async function foo() console.log(1); await Promise.reject(3); console.log(4); // 本行不会执行foo().catch(console.log);console.log(2); //1 2 3await的限制await关键字只能 直接出现在异步函数的定义中 ，它的异步特质不会扩展到嵌套函数中。不能在顶级上下文中使用，但是可以定义并立即调用： 定义并立即调用的异步函数(async function () console.log(await Promise.resolve(3));)(); //3 不允许：await出现在箭头函数中function foo() const syncFn = () = return await Promise.resolve(foo); ; console.log(syncFn()); 不允许：await出现在同步函数声明中function bar() function syncFn() return await Promise.resolve(bar); console.log(syncFn()); 不允许：await出现在同步函数表达式中function baz() const syncFn = function () return await Promise.resolve(baz); console.log(syncFn()); 不允许：IIFE使用同步函数表达式或箭头函数function qux() (function () console.log(await Promise.resolve(qux)); )(); (() = console.log(await Promise.resolve(qux)))(); 11.3.2 停止和恢复执行await关键实际作用 异步函数中真正起作用的实际是 await，async更像是一个 标识符，异步函数如果不包含await关键字，执行起来实际和普通函数没有区别：async function foo() console.log(await Promise.resolve(foo));async function bar() console.log(await bar);async function baz() console.log(baz);foo(); bar();baz();// baz bar foo await关键字作用原理 JavaScript运行时遇到await会进行如下操作第一步记录暂停执行的位置。第二步等到对象值可用时，会向消息队列推送一个任务。第三步该任务恢复异步函数的执行（回到之前记录的暂停位置）await对象是一个立即可用的值await对象是一个Promise的对象 async function foo() console.log(2); await null; console.log(3)console.log(1);foo();console.log(4); // 1 2 3 4 step 1 打印1step 2 进入foo()，打印2step 3 遇到await关键字，记录暂停位置，向消息队列中添加一个任务step 4 暂时退出foo()，打印3step 5 同步线程代码执行完毕，从消息队列中取出任务，返回之前记录位置恢复异步函数执行stup 6 打印4，退出foo() async function foo() console.log(2); console.log(await Promise.resolve(8)); console.log(9);async function bar() console.log(4) console.log(await 6); console.log(7);// 1 2 3 4 5 8 9 6 7console.log(1);foo();console.log(3);bar();console.log(5); step 1 打印1step 2 进入foo，打印2step 3 遇到await关键字暂停执行，记录暂定位置，向消息队列中添加一个期约在落定之后执行的任务step 4 期约立即落定，把给await提供值的任务添加到消息队列，暂时从foo中退出step 5 打印3step 6 进入bar，打印4step 7 遇到await关键字暂停执行，向消息队列添加一个任务，暂时退出barstep 8 打印5，线程执行完毕step 9 退回到foo暂停位置，打印8，打印9，退出foo()step 10 退回到bar暂停位置，打印6，打印7，退出bar() 11.3.3 异步函数策略1.实现sleep() 可以实现类似Java中的 Tread.sleep() 函数，在程序中加入非阻塞的暂停：async function sleep(delay) return new Promise((resolve) = setTimeout(resolve, delay));async function foo() const t0 = Date.now(); await sleep(1500); console.log(Date.now() - t0);foo(); //15072.利用平行执行 顺序等待多个异步操作平行执行多个异步操作async function randomDelay(id) const delay = Math.random() * 1000; return new Promise((resolve) = setTimeout(() = console.log(id); resolve(); ,delay))async function foo() const t0 = Date.now(); await randomDelay(0); await randomDelay(1); await randomDelay(2); await randomDelay(3); await randomDelay(4); console.log(Date.now() - t0);foo(); //0 1 2 3 4 1994async function randomDelay(id) const delay = Math.random() * 1000; return new Promise((resolve) = setTimeout(() = console.log(id); resolve(); ,delay))async function foo() const t0 = Date.now(); // 一次性初始化所有期约，再分别等待结果 const p0 = randomDelay(0); const p1 = randomDelay(1); const p2 = randomDelay(2); const p3 = randomDelay(3); const p4 = randomDelay(4); await p0; await p1; await p2; await p3; await p4; console.log(Date.now() - t0); foo(); // 3 1 4 2 0 9773.串行执行期约 async function addTwo(x) return x + 2; async function addThree(x) return x + 3; async function addFive(x) return x + 5; async function addTen(x) for (const fn of [addTwo, addThree, addFive]) x = await fn(x); return x;addTen(9).then(console.log); //194.栈追踪与内存管理 比较 期约 与 内存管理 在拒绝期约时的栈追踪信息： 期约function fooPromiseExecutor(resolve, reject) setTimeout(reject, 1000, bar);function foo() new Promise(fooPromiseExecutor);foo();栈追踪信息Uncaught (in promise) barsetTimeout (async)fooPromiseExecutorfooJavaScript引擎会在创建期约时 尽可能保留完整的调用栈 ，这意味着栈追踪信息会占用内存，带来一些计算和存储成本。 异步函数function fooPromiseExecutor(resolve, reject) setTimeout(reject, 1000, bar);async function foo() await new Promise(fooPromiseExecutor);foo();栈追踪信息Uncaught (in promise) barfooawait in foo (async)栈追踪信息可以准确地反应当前的调用栈。JavaScript在嵌套函数中存储指向包含函数的指针，指针存储在内存中，可以用于在出错时生成追踪信息。因此能够降低内存的额外消耗。 栈追踪信息应该相当直接地表现JavaScript引擎当前栈内存中函数调用之间的嵌套关系。"},{"title":"9.1 代理基础","path":"/wiki/JavaScript/chapter_9_1.html","content":"代理简单来说 就是指给目标对象定义一个代理对象，然后把它当做抽象的目标对象使用因此它能够用作目标对象的替身，又完全独立于目标对象。 代理需要平台支持 代理是一种新的基础性语言能力，转义程序不能直接将其转换为ES6之前的代码，因此代理和反射需要在百分百支持它们的平台上使用。 9.1.1 创建空代理Proxy函数 功能： 创建代理参数：param 1： 目标对象param 2： 处理程序对象区分代理和目标：可以使用严格相等（）来区分不能使用instanceof Proxy，因为Proxy.prototype是undefined const target = id: target;const handler = ;const proxy = new Proxy(target, handler);console.log(target.id); //targetconsole.log(proxy.id); //targettarget.id = `foo`;console.log(target.id); //fooconsole.log(proxy.id); //fooproxy.id = `bar`;console.log(target.id); //barconsole.log(proxy.id); //barconsole.log(target.hasOwnProperty(id)); //trueconsole.log(proxy.hasOwnProperty(id)); //trueconsole.log(proxy === target); //false// TypeError: Function has non-object // prototype undefined in instanceof checkconsole.log(target instanceof Proxy);console.log(proxy instanceof Proxy) 9.1.2 定义捕获器使用代理的主要目的就是可以定义捕获器（trap）。代理能在操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。 注意 只有在代理对象上执行这些操作才会触发捕获器。 const target = foo: barconst handler = get() return handler override; const proxy = new Proxy(target, handler);console.log(target.foo); //barconsole.log(proxy.foo); //handler overrideconsole.log(target[foo]) //barconsole.log(proxy[foo]) //handler overrideconsole.log(Object.create(target)[foo]); //barconsole.log(Object.create(proxy)[foo]); //handler override 9.1.3 捕获器参数和反射APIget()参数 trapTarget: 目标对象property: 要查询的属性receiver: 代理对象 const target = foo:barconst handler = get(trapTarget, property, receiver) console.log(trapTarget === target); console.log(property); console.log(receiver === proxy); const proxy = new Proxy(target, handler);// true// foo// trueproxy.foo; 通过这些参数就可以重建目标对象的原始行为了： const target = foo:barconst handler = get(trapTarget, property, receiver) return trapTarget[property]; const proxy = new Proxy(target, handler);console.log(proxy.foo); //barconsole.log(target.foo); //bar 全局对象Reflect 通过全局对象Reflect的同名方法也可以轻松实现重建。简洁一点…const handler = get() return Reflect.get(...arguments); 再简洁一点…const handler = get:Reflect.get更简洁点…（直接捕获所有方法）const proxy = new Proxy(target, Reflect);使用反射API的样板代码const target = foo: bar, baz: qux;const handler = get(trapTarget, property, receiver) let decoration = ; if (property === foo) decoration = !!!; return Reflect.get(...arguments) + decoration; const proxy = new Proxy(target, handler);console.log(proxy.foo); //foo!!!console.log(target.foo); //fooconsole.log(proxy.baz); //quxconsole.log(target.baz); //qux 9.1.4 捕获器不变式当捕获器定义出现过于反常的行为时（如get和writable的定义出现冲突时）捕获器不变式会进行报错。 const target = ;Object.defineProperty(target, foo, configurable: false, writable: false, value: bar);const handler = get() return qux; ;const proxy = new Proxy(target, handler);// get on proxy: property foo is a read-only // and non - configurable data property on the proxy // target but the proxy did not return its // actual value(expected bar but got qux)console.log(proxy.foo); 9.1.5 可撤销代理Proxy.revocable 这个方法支持撤销代理对象与目标对象的关联。const target = foo:barconst handler = get() return interecpted const proxy, revoke = Proxy.revocable(target, handler);console.log(proxy.foo); //barconsole.log(target.foo); //barrevoke();// TypeError:// Cannot perform get on a proxy that has been revokedconsole.log(proxy.foo); 9.1.6 实用反射API 反射API与对象API 反射API并不限于捕获处理程序 大多数反射API方法在Object类型上有对应的方法 Object上的方法适用于通用程序 反射方法适用于细粒度的对象控制与操作 状态标记 数据类型： 布尔值 表示： 意图执行的操作是否成功 重构前 const o = try Object.defineProperty(o, foo, bar); console.log(success); catch (e) console.log(failure); 重构后（操作失败时不会报错） const o = ;if (Reflect.defineProperty(o, foo, value: bar )) console.log(success); //success else console.log(failure); 提供状态标记的反射方法 Reflect.defineProperty()Reflect.preventExtensions()Reflect.setPrototypeof()Reflect.set()Reflect.deleteProperty() 用一等函数替代操作符 Reflect.get(): 代替对象属性访问操作符 Reflect.set(): 代替赋值操作符 Reflect.has(): 代替in操作符或with() Reflect.deleteProperty(): 代替delete操作符 Reflect.construct(): 代替new操作符 安全地应用函数 主要针对apply方法的调用: apply调用反面教材 Function.prototye.apply.call(myFunc, thisVal, argumentList); 使用Reflect来避免 Reflect.apply(myFunc, thisVal, argumentsList); 9.1.7 代理另一个代理多层拦截网 代理完全可以代理另一个代理，因此可以在一个目标对象之上构建多层拦截网。const target = foo:barconst firstProxy = new Proxy(target, get() console.log(first proxy); return Reflect.get(...arguments); );const secondProxy = new Proxy(firstProxy, get() console.log(second Proxy); return Reflect.get(...arguments); );// second Proxy// first Proxy// barconsole.log(secondProxy.foo); 9.1.8 代理的问题与不足 代理中的this 直觉上讲，this通常指向调用这个方法的对象。即调用代理上的任何方法，如proxy.outerMethod(),proxy.outerMethod()调用this.innerMethod(),实际上会调用proxy.innerMethod()当目标对象依赖于对象标识时会存在问题const wm = new WeakMap();class User constructor(userId) wm.set(this, userId); set id(userId) wm.set(this, userId); get id() return wm.get(this); const user = new User(123);console.log(user.id); //123const userInstanceProxy = new Proxy(user, );console.log(userInstanceProxy.id); //undefined这是因为User实例一开始使用目标对象作为WeakMao的键，代理对象却尝试从自身取得这个实例。 解决方案把代理User实例改为代理User类本身，再创建代理的实例。const UserClassProxy = new Proxy(User, );const proxyUser = new UserClassProxy(456);console.log(proxyUser.id); //456 代理与内部槽位 有些ECMAScript内置类型可能会依赖代理无法控制的机制，原因是这些内置类型方法的执行依赖this值上的内部槽位，但是代理对象上不存在这个内部槽位。 const target = new Date();const proxy = new Proxy(target, );console.log(proxy instanceof Date); //trueproxy.getDate(); //TypeError: this is not a Date object"},{"title":"9.2 代理捕获器与反射方法","path":"/wiki/JavaScript/chapter_9_2.html","content":"代理可以捕获13种不同的基本操作。这些操作各自有不同的反射API方法、参数、关联ECMAScript操作和不变式。 9.2.1 get()const myTarget = ;const proxy = new Proxy(myTarget, get(target, property, receiver) console.log(get); return Reflect.get(...arguments); )proxy.foo; //getS 调用场景： 获取属性值的操作 反射API： Reflect.get() 返回值： 无返回值 拦截的操作： proxy.property proxy[property] Object.create(proxy)[property] Reflect.get(proxy, property, receiver) 捕获器处理程序参数： target: 目标对象 property: 字符串键属性 receiver: 代理对象 捕获器不变式： target.property不可写且不可配置，get返回值必须匹配target.property target.property不可配置且[[Get]]undefined，get返回值也必须是undefined 9.2.2 set()const myTarget = ;const proxy = new Proxy(myTarget, set(target, property, value, reciever) console.log(set); return Reflect.set(...arguments); )proxy.foo = bar; //set 调用场景： 在设置属性值的操作中被调用 反射API： Reflect.set() 返回值： true 设置成功 false 设置失败，strict模式下会抛出TypeError 拦截的操作： proxy.property value proxy[property] value Object.create(proxy)[property] value Reflect.set(proxy, property, value, receiver) 捕获器处理程序参数： target 目标对象 property 键属性 value 属性值 receiver 接收赋值的对象 捕获器不变式： target.property不可写且不可配置，不能修改目标属性值 target.property不可配置且[[Set]] undefined，不能修改目标属性值 strict模式下，return false会抛出TypeError 9.2.3 has()const myTarget = ;const proxy = new Proxy(myTarget, has(target, property) console.log(has); return Reflect.has(...arguments); )foo in proxy; //has 调用场景： 在in操作符中被调用 反射API： Reflect.has() 返回值： 必须为Boolean，表示属性是否存在 拦截的操作： property in proxy property in Obejct.create(proxy) with(proxy) {(property);} Reflect.has(proxy, property) 捕获器处理程序参数： target 目标对象 property 键属性 捕获器不变式： target.property存在且不可配置，return true target.property存在且目标对象不可扩展，return true 9.2.4 defineProperty()const myTarget = ;const proxy = new Proxy(myTarget, defineProperty(target, property, descriptor) console.log(defineProperty); return Reflect.defineProperty(...arguments); )// definePropertyObject.defineProperty(proxy, foo, value: bar ); 调用场景： 在 Obejct.defineProperty 中被调用 反射API： Reflect.defineProperty() 返回值： Boolean，表示属性是否成功定义 拦截的操作： Object.defineProperty(proxy, property, descriptor) Reflect.defineProperty(proxy, property, descriptor) 捕获器处理程序参数： target 目标对象 property 键属性 descriptor 一个包含可选的 enumerable、configurable、writable、value、get、set 的对象 捕获器不变式： target.property[[Configurable]] false，无法定义属性 target.property[[Configurable]] true，不能添加不可配置的同名属性 target.property[[Configurable]] false，不能添加可配置同名属性 9.2.5 getOwnPropertyDescriptor()const myTarget = ;const proxy = new Proxy(myTarget, getOwnPropertyDescriptor(target, property) console.log(getOwnPropertyDescriptor); return Reflect.getOwnPropertyDescriptor(...arguments); )// getOwnPropertyDescriptorObject.getOwnPropertyDescriptor(proxy, foo); 调用场景： 在 Object.getOwnPropertyDescriptor() 中被调用 反射API： Reflect.getOwnPropertyDescriptor() 返回值： 必须返回Object，属性不存在时返回undefined 拦截的操作： Object.getOwnPropertyDescriptor(proxy, property) Reflect.getOwnPropertyDescriptor(proxy, property) 捕获器处理程序参数： target 目标对象 property 键属性 捕获器不变式： target.property存在 target.property可配置，返回表示该属性可配置的对象 target.property不可配置，返回表示该属性存在的对象 target可扩展，返回一个该属性存在的对象 target不可扩展，返回undefined表示该属性不存在 target.property不存在，不能返回表示该属性可配置的对象 9.2.6 deleteProperty()const myTarget = ;const proxy = new Proxy(myTarget, deleteProperty(target,property) console.log(delete); return Reflect.deleteProperty(...arguments); )delete proxy.foo; //delete 调用场景： 在delete操作符中调用 反射API： Reflect.deleteProperty() 返回值： Boolean 表示删除是否成功 拦截的操作： delete proxy.property delete proxy[property] Reflect.deleteProperty(proxy, property) 捕获器处理程序参数： target 目标对象 property 键属性 捕获器不变式： target.property存在且不可配置则不能删除 9.2.7 ownKeys()const myTarget = ;const proxy = new Proxy(myTarget, ownKeys(target) console.log(ownKeys); return Reflect.ownKeys(...arguments); )Object.keys(proxy); //ownKeys 调用场景： 在Object.keys及类似方法中调用 反射API： Reflect.ownKeys() 返回值： StringSymbol 可枚举对象 拦截的操作： Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbols(proxy) Object.keys(proxy) Reflect.ownKeys(proxy) 捕获器处理程序参数： target 目标对象 捕获器不变式： 返回的可枚举对象必须包含target所有不可配置的自有property 如果target不可扩展，返回的可枚举对象必须准确包含自有属性键 9.2.8 getPrototypeOf()const myTarget = ;const proxy = new Proxy(myTarget, getPrototypeOf(target) console.log(getPrototypeOf); return Reflect.getPrototypeOf(...arguments); )// getPrototypeOfObject.getPrototypeOf(proxy); 调用场景： 在Object.getPropertyOf中调用 反射API： Reflect.getPropertyOf() 返回值： Objectnull 拦截的操作： Object.getPrototypeOf(proxy) Reflect.getPrototypeOf(proxy) proxy.__proto__ Object.prototype.isPrototypeOf(proxy) proxy instanceof Object 捕获器处理程序参数： target 目标对象 捕获器不变式： 若target不可扩展，proxy和target的getPrototypeOf值相等 9.2.9 setPrototypeOf()const myTarget = ;const proxy = new Proxy(myTarget, setPrototypeOf(target, prototype) console.log(setPrototypeOf); return Reflect.setPrototypeOf(...arguments); )// setPrototypeOfObject.setPrototypeOf(proxy, Object); 调用场景： 在Object.setPrototypeOf中调用 反射API： Reflect.setPropertyOf() 返回值： Boolean 表示原型赋值是否成功 拦截的操作： Object.setPrototypeOf(proxy) Reflect.setPrototypeOf(proxy) 捕获器处理程序参数： target 目标对象 prototype 代替原型，顶级原型则为null 捕获器不变式： 若target不可扩展，唯一有效的prototype参数就是Object.getPrototypeOf(target)返回值 9.2.10 isExtensible()const myTarget = ;const proxy = new Proxy(myTarget, isExtensible(target) console.log(isExtensible); return Reflect.isExtensible(...arguments); )Object.isExtensible(proxy); //isExtensible 调用场景： 在Object.isExtensible中调用 反射API： Reflect.isExtensible() 返回值： Boolean 表示target是否可扩展 拦截的操作： Object.isExtensible(proxy) Reflect.isExtensible(proxy) 捕获器处理程序参数： target 目标对象 捕获器不变式： target可扩展，return true target不可扩展，return false 9.2.11 preventExtensions()const myTarget = ;const proxy = new Proxy(myTarget, preventExtensions(target) console.log(preventExtensions); return Reflect.preventExtensions(...arguments); )//preventExtensionsObject.preventExtensions(proxy); 调用场景： 在Object.preventExtensions中调用 反射API： Reflect.preventExtensions() 返回值： Boolean 表示target是否不可扩展 拦截的操作： Object.preventExtensions(proxy) Reflect.preventExtensions(proxy) 捕获器处理程序参数： target 目标对象 捕获器不变式： 必须返回 !Object.isExtensible(proxy) 9.2.12 apply()const myTarget = () = ;const proxy = new Proxy(myTarget, apply(target, thisArg, ...argumentsList) console.log(apply); return Reflect.apply(...arguments); );proxy(); //apply 调用场景： 在调用函数时被调用 反射API： Reflect.apply() 返回值： 无限制 拦截的操作： proxy(…argumentsList) Function.prototype.apply(thisArg, argumentsList) Function.prototype.call(thisArg, …argumentsList) Reflect.apply(target, thisArgument, argumentsList) 捕获器处理程序参数： target 目标对象 thisArg 调用函数时this参数 argumentsList 调用函数时参数列表 捕获器不变式： target必须是函数对象 9.2.13 construct()const myTarget = function () ;const proxy = new Proxy(myTarget, construct(target, argumentsList, newTarget) console.log(construct); return Reflect.construct(...arguments); )new proxy; //construct 调用场景： 在new操作符中调用 反射API： Reflect.construct() 返回值： Object 拦截的操作： new proxy(…argumentsList) Reflect.construct(target, argumentsList, newTarget) 捕获器处理程序参数： target 目标对象 argumentsList 传给目标构造函数的参数列表 newTarget 最初被调用的构造函数 捕获器不变式： target必须可以用做构造函数"},{"title":"9.3 代理模式","path":"/wiki/JavaScript/chapter_9_3.html","content":"代理可以用来实现一些有用的编程模式 9.3.1 跟踪属性访问把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过const user = name:Jakeconst proxy = new Proxy(user, get(target, property, receiver) console.log(`Getting $property`); return Reflect.get(...arguments); , set(target, property, value, receiver) console.log(`Setting $property = $value`); return Reflect.set(...arguments); );proxy.name; // Getting nameproxy.age = 27; // Setting age = 27 9.3.2 隐藏属性代理内部实现对外部代码不可见，可以借此隐藏目标对象上的属性const hiddenProperties = [foo, bar];const targetObject = foo: 1, bar: 2, baz: 3;const proxy = new Proxy(targetObject, get(target, property) if (hiddenProperties.includes(property)) return undefined; else return Reflect.get(...arguments); , has(target, property) if (hiddenProperties.includes(property)) return false; else return Reflect.has(...arguments); );console.log(proxy.foo); //undefinedconsole.log(proxy.bar); //undefinedconsole.log(proxy.baz); //3console.log(foo in proxy); // falseconsole.log(bar in proxy); // falseconsole.log(baz in proxy); // true 9.3.3 属性验证在赋值操作触发set捕获器时，可以根据所赋的值决定是否允许赋值。 const target = onlyNumbersGoHere: 0 const proxy = new Proxy(target, set(target, property, value) if (typeof value !== number) return false; else return Reflect.set(...arguments); )proxy.onlyNumbersGoHere = 1;console.log(proxy.onlyNumbersGoHere); //1proxy.onlyNumbersGoHere = 2;console.log(proxy.onlyNumbersGoHere); //1 9.3.4 函数与构造函数参数验证可以对函数和构造函数的参数进行审查，如让函数接收指定类型的值。 function median(...nums) return nums.sort()[Math.floor(nums.length / 2)];const proxy = new Proxy(median, apply(target, thisArg, argumentsList) for (const arg of argumentsList) if (typeof arg !== number) throw Error: Non-number argument provided; return Reflect.apply(...arguments); )console.log(proxy(4, 7, 1)); //4console.log(proxy(4, 7, 1)); //Error: Non-number argument provided又或者是在实例化时必须给构造函数传参class User constructor(id) this.id_ = id; const proxy = new Proxy(User, construct(target, argumentsList, newTarget) if (argumentsList[0] === undefined) throw User cannot be instantiated without id; else return Reflect.construct(...arguments); )new proxy(1);new proxy(); //Error: ... 9.3.5 数据绑定与可观察对象代理可以把运行时不相关的部分联系到一起，让不同的代码互操作。 可以将被代理的类绑定到一个全局实例集合中const userList = [];class User constructor(name) this.name_ = name; const proxy = new Proxy(User, construct() const newUser = Reflect.construct(...arguments); userList.push(newUser); return newUser; );new proxy(John);new proxy(Jacob);new proxy(Jingleheimerschmidt);console.log(userList); //[User,User,User]可以创建一个每次插入新实例都会发送消息的事件分派程序const userList = [];function emit(newValue) console.log(newValue);const proxy = new Proxy(userList, set(target, property, value, receiver) const result = Reflect.set(...arguments); if (result) emit(Reflect.get(target, property, receiver)); return result; )proxy.push(John); //John 1proxy.push(Jacob); //Jacob 2"},{"title":"Web应用安全/核心防御机制","path":"/wiki/Network/wahh_01_web.html","content":"问题问题 旨在阻止跨站点脚本攻击的输入确认机制按以下顺序处理一个输入：（1）删除任何出现的script表达式；（2）将输入截短为50个字符；（3）删除输入中的引号；（4）对输入进行URL解码；（5）如果任何输入项被删除，返回步骤（1）。是否能够避开上述确认机制，让以下数据通过确认？“scriptalert(“foo”)/script官方答案是。如果没有第4步，此机制将是可靠的，能够过滤其旨在阻止的特定项目。但是，由于输入在执行过滤步骤后被解码，攻击者只需要对有效载荷中的选定字符进行URL编码，就可以避开这种过滤：“如果首先执行第4步，或根本不执行该步骤，攻击者将不可能避开上述过滤。代码实现function inputFilter(src) let hasInvalid = false // 1. 删除任何出现的script表达式 const reg = /(\\/)?script/g if(reg.test(src)) src = src.replaceAll(reg, ) hasInvalid = true // 2. 将输入截断为50个字符 if(src.length50) src = src.slice(0,50) hasInvalid = true // 3. 删除2输入中的引号 let signReg = /[]/g if(signReg.test(src)) src = src.replaceAll(signReg, ) hasInvalid = true // 4. 对输入进行URL解码 src = urlencode.decode(src) if(hasInvalid) return inputFilter(urlencode.encode(src)) return src这时如果输入的数据经过攻击者编码：// %22= %27= %3C= %3E=const src = %22%3Cscriptalert(%22foo%22)%3C/script输出结果显示字符串被解析为跨站脚本攻击字符串：--------------------------------------目标输出：scriptalert(foo)/script输入：%22%3Cscriptalert(%22foo%22)%3C/script输出：scriptalert(foo)/script--------------------------------------"},{"title":"Hello NodeJs","path":"/wiki/Node/beginner_01_hello_nodejs.html","content":"命令行窗口常用的指令有： dir 列出当前目录下的所有文件 cd md 文件夹名 创建一个文件夹 rd 文件夹名 删除一个文件夹 环境变量：操作系统中的变量位置：高级系统变量-环境变量 用户变量：只有当前用户能用 系统变量：所有用户都能用 path D:\\Ruby\\Ruby31-x64\\bin;D:\\python3\\Scripts;D:\\python3;D:\\python\\Scripts;D:\\python;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;…在D:\\CS_Demo\\V_Demo\\NodeJs_Demo\\assets\\hello目录下新建hello.txt，试着在path中加入这样一行变量D:\\CS_Demo\\V_Demo\\NodeJs_Demo\\assets\\hello重启cmd，无论在什么目录下输入hello.txt命令，都能够访问到hello.txt 操作系统访问文件的顺序 在当前目录下寻找，找到了直接打开如果没在目录下找到，会依次按照环境变量path的路径寻找如果还是没找到会报错所以我们可以将经常需要访问的程序和文件路径添加到path中这样就能在任意位置访问这些文件和程序了 进程和线程 进程 负责为程序的运行提供必备的环境 就像工厂中的车间 线程 计算机中的最小计算范围，负责执行进程中的程序 相当于工厂中的工人 单线程和多线程 单线程相当于一个线程做完整个一个流程，像js这种需要对页面dom元素进行操作的程序就是单线程执行的 多线程是主流的线程处理方式，相当于多个线程完成一个流程，一般情况下性能比较高 NodeJs简介NodeJs是一个服务器端运行的js环境 之前的js都是在浏览器端运行，nodeJs让js直接在服务器运行， Ryan Dahl在2009年2月开始着手编写Node.js，最初是打算写一个名为Web.js的服务器，后来越写越大，形成一个可以扩充的生态系统，改名为Node.js，意指像node一样可以不断扩充。 单线程是NodeJs的独特之处，因为它即带来了体量小、速度快的优点，也存在并发量小的缺点 node执行js文件Hello Node.Js!"},{"title":"模块化","path":"/wiki/Node/beginner_02_model.html","content":"模块化简介Node中，一个js文件就是一个模块。 require node使用require引入外部模块，注意：如果要使用相对路径，必须以.或..开头require引入模块之后会返回一个对象，该对象表示的是引入的模块。 require引入 运行命令node helloNode.js运行结果module Ahello nodehelloNode.jsrequire(./module);console.log(hello node);module.jsconsole.log(module A); exports暴露变量 Node中，每个js文件中的js代码实际上都相当于运行在一个独立的函数之中。(function() // 函数体)()可以通过exports来向外暴露变量。exports.variableName exports案例 helloNode.jslet module_prop = require(./module);console.log(module_prop.a,module_prop.b);module_prop.fun(10,5);module.jsexports.a = 123;exports.b= abc;exports.fun = function(num1,num2) console.log(num1+num2);node helloNode.js运行结果：123 abc15 模块化详解模块标识 使用require引入模块的时候，使用的就是模块标识，模块标识能用来找到指定模块。模块标识分为两大类： 核心模块由node引擎提供的模块核心模块的表示就是模块名let fs = require(fs)文件模块由用户自己创建的模块文件模块的标识就是文件的路径（绝对路径、相对路径）let math = require(./math) 全局对象global node中有一个全局对象global，作用和window类似，全局中创建的变量和函数都会作为global的方法和属性保存。不使用letvar定义的变量即全局变量：let a = 10;global_a = 100;console.log(global.a); //undefinedconsole.log(global.global_a); //100 node对模块的函数化包装 如何确定我们调用的js文件实际上是函数呢？可以使用js中函数独有的arguments.callee属性，这个属性描述的是正在调用的函数体执行代码let a = 10;console.log(arguments.callee + );输出结果function(exports, require, module, __filename, __dirname) let a = 10; console.log(arguments.callee + );node模块化正是对每个js模块文件中的执行代码进行函数包装操作：function(exports, require, module, __filename, __dirname) // 我们自己的js代码像奥利奥夹心一样被夹在这里这同是也解释了我们之前使用的exports和require的来源，它们都是被包装的函数传进来的参数。exports用于将变量或函数暴露到外部require函数，用于引入外部模块require函数代码[Function: require] resolve: [Function: resolve] paths: [Function: paths] , main: Module id: ., path: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module, exports: , filename: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\\\main.js, loaded: false, children: [], paths: [ D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\ ode_modules, D:\\\\CS_Demo\\ ode_modules, D:\\ ode_modules ] , extensions: [Object: null prototype] .js: [Function (anonymous)], .json: [Function (anonymous)], .node: [Function (anonymous)] , cache: [Object: null prototype] D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\\\main.js: Module id: ., path: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module, exports: , filename: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\\\main.js, loaded: false, children: [], paths: [Array] module代表当前模块自身exports就是module的属性，用exports和module.exports本质上没有区别console.log(Object.is(module.exports,exports)); //truemodule对象源码Module id: ., path: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module, exports: , filename: D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\\\main.js, loaded: false, children: [], paths: [ D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\day2_module\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\ ode_modules, D:\\\\CS_Demo\\ ode_modules, D:\\ ode_modules ] __filename当前模块的完整路径__dirname当前模块所在文件夹的完整路径 module.exports和exports的区别 对于暴露单个属性或方法，使用module.exports和exports都是一样的：math.jsexports.pi = 3.14;module.exports.sin90 = 1;exports.add = function(num1,num2) return num1+num2;module.exports.multiply = function(num1,num2) return num1*num2;main.jslet math = require(./math);console.log(math.pi); //3.14console.log(math.sin90); //1console.log(math.add(10,5)); //15console.log(math.multiply(2,4)); //8但是如果将需要将对象和方法包装成类暴露的话，通过module.exports可以直接赋值，而直接修改exports相当于修改exports的指向，切断了它和module之间的指向关系。module.exports = pi:3.14, sin90:1, add:function(num1,num2) return num1+num2; , multiply:function(num1,num2) return num1*num2;"},{"title":"NPM","path":"/wiki/Node/beginner_04_npm.html","content":"npm简介NPM，CommonJS，NodeJS CommonJS包规范是 理论NPM是其中一种 实践就像 精神分析 和 催眠 的关系一样N NodeP PackageM MangaerNode与npm之间的关系npm帮助Node完成了第三方模块的发布、安装、依赖等Node与第三方模块之间形成了一个很好的生态系统 npm命令 npm -v查看版本npm帮助说明npm search 包名搜索模块包npm install 包名npm i 包名在当前目录安装包npm install下载当前项目依赖的包npm install 包名 -g全局模式安装包一般用来安装一些计算机工具npm install 包名 –save安装包并添加到依赖中npm init创建一个package.jsonnpm remove 包名npm r 包名删除一个模块npm install 文件路径从本地安装npm install 包名 -registry地址从镜像源安装npm config set registry 地址设置镜像源 配置cnpmcnpm镜像网站https://npmmirror.com/ npm install -g cnpm –registryhttps://registry.npmmirror.com 注意： cnpm下载下来的版本和官方版本并不完全一样，会在原本包名之前加下划线前缀，这是为了防止覆盖原版本 node搜索包流程 首先在当前目录的node_modules中寻找，找到则直接使用 如果根目录没找到，则去上一级目录的node_modules中寻找，找到则直接使用 如果上一级还没找到，再上一级目录寻找，直到找到为止 直到找到磁盘的根目录，这时如果依然没有，则报错"},{"title":"Buffer缓冲区","path":"/wiki/Node/beginner_05_buffer.html","content":"Buffer简介官网文档对于Buffer的介绍http://nodejs.p2hp.com/api/v19/buffer/ 中文文档https://nodejs.cn/api/buffer.html Buffer和数组的区别 Buffer结构和 数组 很像，操作方法也和数组类似数组中不能存储 二进制文件 ，buffer就是专门用来存储二进制数据的length属性意义不同ArrayInstance.length表示数组长度BufferInstance.length表示buffer占用内存的长度 Buffer的元素 为什么可以直接通过Buffer来 创建内存中的空间 ？Buffer的元素是 16进制的两位数（十六进制格式显示的二进制数）Buffer元素范围在 00-ff之间实际上一个元素就表示 内存中的一个字节实际上Buffer中的内存不是通过JavaScript分配的，而是在底层 通过C++申请的 Buffer元素打印Buffer let str = Hello World;let buf = Buffer.from(str);console.log(Buffer source data: )console.log(buf) // Uniform Codeconsole.log(Buffer content: + buf)console.log(Buffer length: + buf.length);运行结果Buffer source data: Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 Buffer content: Hello WorldBuffer length: 11 关于length ArrayInstance.length表示数组长度BufferInstance.length表示buffer占用内存的长度let str = Hello 世界;let buf = Buffer.from(str);console.log(Buffer source data: )console.log(buf) // Uniform Codeconsole.log(Buffer content: + buf)console.log(Buffer length: + buf.length);console.log(str length: + str.length);运行结果Buffer source data: Buffer 48 65 6c 6c 6f 20 e4 b8 96 e7 95 8c Buffer content: Hello 世界Buffer length: 12str length: 8 Buffer操作创建一个指定大小的buffer let buf = new Buffer(10);console.log(buf.length)运行结果10(node:13100) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.(Use `node --trace-deprecation ...` to show where the warning was created)如上所示，Buffer的构造函数都是不推荐使用的，可以使用 Buffer.alloc() 来创建buffer对象：let buf = Buffer.alloc(10);console.log(buf.length)console.log(buf);运行结果Buffer 00 00 00 00 00 00 00 00 00 00 Buffer元素写入 Buffer元素通过 索引操作 Buffer的长度一旦确定，就不能修改，因为Buffer实际上是对内存空间的直接操作写入二进制数值的位数超过8位，超出位数被忽略按索引读取buffer元素时，会默认将二进制数转化为10进制数。let buf = Buffer.alloc(10);buf[0] = 88;buf[1] = 255;buf[2] = 0xaa;buf[3] = 0xabc;buf[4] = -1;buf[10] = 10;console.log(buf)console.log(buf[2]);运行结果Buffer 58 ff aa bc ff 00 00 00 00 00 Buffer.allocUnsafe Buffer.allocUnsafe(size)创建一个指定大小的buffer，buffer中可能含有敏感数据（上一次该内存空间使用留下的数据），而Buffer.alloc会对指定的内存空间进行清空操作，从性能上来看，allocUnsafe因为无需进行清空，因此性能更好。 Buffer.from(str) 用于将一个字符串转换为Bufferlet buf = Buffer.from(Hello World);console.log(buf)console.log(buf+)运行结果Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64Hello World"},{"title":"包管理","path":"/wiki/Node/beginner_03_package.html","content":"包规范CommonJS的包规范由两个部分组成 包结构 用于组织包中的各种文件 包实际上就是一个压缩文件，解压之后规范的目录应该包含如下文件： package.json 描述文件 bin 可执行二进制文件 一般用于编译工具的配置 lib js代码 doc 文档 test 单元测试 包描述文件 描述包的相关信息，以供外部读取分析 package.json包描述文件 package.json 用于表达非代码相关的信息， 位于包的 根目录下。json文件里不能写注释package.json中的字段 key description name 名字 description 描述 version 版本 keywords 关键字 maintainers 主要贡献者 contributors 贡献者 bugs 地址 licenses 协议 repositories 仓库 dependencies 依赖 homepage 主页 os 系统 cpu cpu engine 引擎 builtin 构建工具 directories implements scripts author bin main devDependencies"},{"title":"文件读取","path":"/wiki/Node/beginner_07_read.html","content":"简单文件读取 readFile(path[, options], callback) callback参数 err 错误 data Buffer类型 readFileSync(path[, options]) 完整流程 const fs = require(fs);fs.readFile(hello.txt, function (err, data) if (!err) console.log(data.toString()); fs.writeFile(hello_copy.txt, data, function (err) if (!err) console.log(copy success) ) ) 流式文件读取 如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，就会自动开始读取数据 rs.on(data, function (data) console.log(data + );) 使用pipe快速copy流式文件 let fs = require(fs);let rs = fs.createReadStream(hello.txt);let ws = fs.createWriteStream(hello_copy_stream.txt);rs.once(open, function () console.log(rs open);)rs.once(close, function () console.log(rs close);)ws.once(open, function () console.log(ws open);)ws.once(close, function () console.log(ws close);)rs.pipe(ws);"},{"title":"文件写入","path":"/wiki/Node/beginner_06_write.html","content":"fs文件系统Node中文官网对fs的介绍https://nodejs.cn/api/fs.html 文件系统标志https://nodejs.cn/api/fs.html#file-system-flags File System Node中，与文件系统交互非常重要， 服务端的本质就是将本地文件发给远程客户端。文件系统简单说就是使用node对系统中文件进行操作Node通过fs模块和文件系统进行交互fs模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互要使用fs模块，需要先对其进行加载：const fs require(“fs”); 同步和异步调用 fs模块所有操作都有两种形式可供选择：同步fs 会阻塞程序执行异步fs不会阻塞程序执行通过callback回调函数返回结果 同步文件写入 完整步骤 const fs = require(fs);// 1. 打开文件let result = fs.openSync(hello.txt, w);console.log(result); //3// 2. 写入文件fs.writeSync(result, Hello world!)// 3. 关闭文件fs.closeSync(result); openSync 步骤1 打开文件fs.openSync(path, flags[, mode])path 要打开文件的路径flags 打开文件要做的操作类型r 只读w 可写mode 设置文件的操作权限，一般不传返回值该方法会返回一个文件的描述符作为结果，可以通过该描述符对文件进行各种操作步骤2 向文件中写入内容 fs.wraiteSync(fd, string[, position[, encoding]])fd 文件的描述符，需要传递要写入的文件的描述符string 要写入的内容position 写入的起始位置，默认是0，一般不传encoding 编码格式，默认是UTF-8，一般不传步骤3 保存并关闭文件fs.closeSync(fd)fd 要关闭文件的描述符 writeSync的position参数 不传position，默认为0fs.syncWrite( file, Hello World!);运行结果指定position，相当于在指定偏移位置进行写入操作fs.syncWrite( file, Hello World! ,20);运行结果 异步文件写入write open(path, flags[, mode], callback)异步调用的方法结果都是通过回调函数callback的参数返回的，fs.open(hello.txt, w, function () console.log(arguments);)[Arguments] { ‘0’: null, ‘1’: 3 }这里callback的两个参数：err 错误对象，如果没有错误则为nullfd 文件的描述符完整流程const fs = require(fs);// 1 打开文件fs.open(hello.txt, w, function (err, fd) if (!err) console.log(fd); // 2 写入文件 fs.write(fd, Hello World!, function (err) if (!err) // 3 关闭文件 fs.close(fd, function (err) if (!err) console.log(file closed) ); ); else console.log(err); ) 简单文件写入同步-简单文件写入 fs.writeFile(file, data[, options], callback)file 要操作文件路径data 要写入的数据options 选项，ObjectString，可以对写入进行一些设置encodingmodeflag 默认wcallback 当写入完成以后执行的函数完整流程const fs = require(fs);fs.writeFile( hello.txt, wraiteFile_Hello!, function (err) if (!err) console.log(write success); ); 异步-简单文件写入 fs.writeFileSync(file, data[, options]) 流式文件写入同步、异步、简单文件写入都不适合 大文件 写入，性能较差，容易导致内存溢出. fs.createWriteStream(path[, options]) 该方法可以用来创建一个可写流path 文件路径options 配置参数 监听流 可以通过open和close事件来监听流的打开和关闭，因为ws的打开和关闭是一次性事件，因此用once绑定更好更多有关事件绑定的文档介绍https://nodejs.cn/api/events.html#class-eventemitterws.once(open, function () console.log(Stream Open);)ws.once(close, function () console.log(Stream close)) 完整流程 const fs = require(fs);//创建一个可写流let ws = fs.createWriteStream(hello.txt);// 通过可写流向文件输出内容ws.write(stream_write );ws.write(1 Hello!!! );ws.write(2 Hello!!! );ws.write(3 Hello!!! );ws.once(open, function () console.log(Stream Open);)ws.once(close, function () console.log(Stream close))ws.end();"},{"title":"fs其他方法","path":"/wiki/Node/beginner_08_fs.html","content":"单个文件操纵验证路径是否存在 let isExits = fs.existsSync(hello.txt);console.log(isExits) //truefs.exists(path, callback)已经删除的方法，因为验证功能一般需要立即获取到结果，无需引入异步fs.existesSync(path) 获取文件信息 fs.stat(hello.txt, function (err,stats) console.log(stats);)运行结果Stats dev: 3932212942, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: 4096, ino: 5910974511137847, size: 46, blocks: 0, atimeMs: 1679821361534.1057, mtimeMs: 1679821361534.1057, ctimeMs: 1679821361534.1057, birthtimeMs: 1679818224344.4, atime: 2023-03-26T09:02:41.534Z, mtime: 2023-03-26T09:02:41.534Z, ctime: 2023-03-26T09:02:41.534Z, birthtime: 2023-03-26T08:10:24.344Zfs.stat(path, callback)获取文件的状态返回一个对象，该对象保存了当前对象状态的相关信息fs.statSync(path) 删除文件 fs.unlinkSync(./hello_copy_stream.txt);fs.unlink(path, callback)fs.unlinkSync(path) 截断文件 将文件截断为指定大小fs.truncateSync(hello_copy.txt, 4);fs.truncate(path, len,callback)fs.truncateSync(path, len) 监视文件更改写入 fs.watchFile(hello.txt, function () console.log(hello.txt change))fs.watchFile(filename[, options], listener)optionsinterval 间隔，默认5000mslistener参数curr stat对象，表示当前文件的状态prev stat对象，表示修改前文件的状态 目录操作列出目录 fs.readdir(., function (err, data) console.log(data);)运行结果[ asynch_write.js, hello.txt, hello_copy.txt, main.js, other_func.js, read.js, simple_write.js, stream_read.js, stream_write.js ]fs.readdir(path[, options], callback)callbackerrfiles 数组 元素为目录中文件名fs.readdirSync(path[, options]) 建立目录 fs.mkdirSync(hello);fs.mkdir(path[, mode], callback)fs.mkdirSync(path[, mode]) 删除目录 fs.rmdirSync(hello);fs.rmdir(path, callback)fs.rmdirSync(path) 重命名文件和目录 fs.renameSync(hello_copy.txt,hello2.txt)rename还能通过绝对路径实现文件的剪切功能fs.renameSync(hello_copy.txt,D:\\\\hello2.txt)fs.rename(oldPath, newPath, callback)fs.renameSync(oldPath, newPath)"},{"title":"2-创建数据库","path":"/wiki/Node/clwy_02_db.html","content":"CURD CreateUpdateReadDelete 创建数据库创建数据库 常用数据库数据类型： 常见SQL语句SQL Mysql教程-- 插入语句：INSERT INTO 表名 (列1, ...) VALUES (值1, ...);-- 多行插入：INSERT INTO 表名 (列1, ...) VALUES (值1, ...),(值1, ...)...;-- 修改语句：UPDATE 表名 SET 列1=值1, 列2=值2, ... WHERE 条件;-- 删除语句：DELETE FROM 表名 WHERE 条件;-- 查询语句：SELECT * FROM 表名;-- 条件查询：SELECT * FROM 表名 WHERE 条件;-- 排序查询：SELECT * FROM `Articles` WHERE `id`2 ORDER BY `id` DESC;"},{"title":"3-Sequelize","path":"/wiki/Node/clwy_03_Sequelize.html","content":"Sequelize ORMSequelize ORM 安装sequelize命令行工具：npm i -g sequelize-cli安装当前项目的sequelize、mysql2包：npm i sequelize mysql2初始化项目：sequelize init可以看到项目目录下多出了一些文件夹：configmigrationsmodelsseeders 配置config.jsconfig.js 注意修改timezone时区 development: username: root, password: your-password, database: your-db-development, host: 127.0.0.1, dialect: mysql, timezone: +08:00 , test: username: root, password: null, database: your-dbe-duck-home-test, host: 127.0.0.1, dialect: mysql, timezone: +08:00 , production: username: root, password: null, database: your-db-production, host: 127.0.0.1, dialect: mysql, timezone: +08:00 创建模型命名规则 模型名为单数：Article表名为复数：Articles sequelize创建模型 使用命令：sequelize model:generate --name Article --attributes title:string,view:integer发现在models和migrations中都创建了对应的文件：modelsweb.js 模型所在文件migrations20250201024243-create-web.js 建表迁移文件在migration迁移文件中，对一些属性手动进行修改：use strict;/** @type import(sequelize-cli).Migration */module.exports = async up(queryInterface, Sequelize) await queryInterface.createTable(Articles, id: allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER.UNSIGNED , title: type: Sequelize.STRING, allowNull: false, , view: type: Sequelize.INTEGER.UNSIGNED, defaultValue: 0, // 添加默认值 allowNull: false, , createdAt: allowNull: false, type: Sequelize.DATE , updatedAt: allowNull: false, type: Sequelize.DATE ); , async down(queryInterface, Sequelize) // 反向迁移操作 await queryInterface.dropTable(Articles); ;运行迁移：sequelize db:migrate 种子文件seed 命令行创建种子文件：sequelize seed:generate --name article编写种子文件脚本：use strict;/** @type import(sequelize-cli).Migration */module.exports = async up (queryInterface, Sequelize) const webs = [] const counts = 50 for(let i = 1; i=counts; i++) const web = href:https://ant.design, name:`This is website $i`, webIcon:`https://api.dicebear.com/7.x/miniavs/svg?seed=$i`, webCover:https://gw.alipayobjects.com/zos/rmsportal/mqaQswcyDLcXyDKnZfES.png, content:一个使用react、antd搭建的网站，后台使用nodejs搭建，用来作为一个导航站点，后续还会继续完善, categoryId: 0, view:0, github:https://github.com/PUYIXIU/CoffeeShop, blogHref: https://puyixiu.github.io/, createdAt:new Date(), updatedAt:new Date(), webs.push(web) // 种子数据写入 await queryInterface.bulkInsert(Webs, webs, ); , async down (queryInterface, Sequelize) await queryInterface.bulkDelete(Webs,null, ) ;运行种子文件：sequelize db:seed --seed xxx-article 模型验证表单数据表单验证 验证字段说明通过修改model模型中的字段规则，来实现表单验证：表单中访问其它表使用 sequelize.models.XXXWeb.init( href: type:DataTypes.STRING, allowNull:false, validate: notNull:msg:站点URL必须存在, notEmpty:msg:站点URL不能为空, isUrl:msg:请填写正确的URL, async isUnique(value) const web = await Web.findOne(where:name:value) if(web) throw new Error(`名称为：$value 的web已存在`) , name: type:DataTypes.STRING, allowNull:false, validate: notNull:msg:站点名称必须存在, notEmpty:msg:站点名称不能为空, len: args:[2,50], msg:站点名称需要在2-50个字符之间 , categoryId: type:DataTypes.INTEGER, allowNull:false, validate: notNull:msg:分类ID必须存在, notEmpty:msg:分类ID不能为空, async isPresent(value) const category = await sequelize.models.Category.findByPk(value) if(!category) throw new Error(`ID为：$value 的分类不存在`) if(category.typeId != this.typeId) throw new Error(`此应用类型无法选择ID为：$value的分类`) ,, sequelize, modelName: Web,);同时，trycatch捕获的错误处理也要进行修改：try //...catch(error) if (error.name === SequelizeValidationError) const errors = error.errors.map(e = e.message); res.status(400).json( status: false, message: 请求参数错误。, errors ); else res.status(500).json( status: false, message: 创建站点失败。, errors: [error.message] ); 迁移相关migration 回滚上一次迁移：sequelize db:migrate:undo运行迁移：sequelize db:migrate新建迁移：sequelize migration:create --name add-avatar-to-user迁移文件中向数据库补充数据：use strict;/** @type import(sequelize-cli).Migration */module.exports = async up (queryInterface, Sequelize) await queryInterface.addColumn(Users,avatar, type:Sequelize.STRING ) , async down (queryInterface, Sequelize) await queryInterface.removeColumn(Users,avatar ) ;"},{"title":"1-开发环境搭建","path":"/wiki/Node/clwy_01_env.html","content":"教程介绍 课程地址长乐未央-社区 使用nvm进行node版本控制 nvm安装介绍 创建Express项目 express官网 express脚手架 使用脚手架快速生成express项目：全局安装express-generatornpm i -g express-generator@4脚手架创建express项目–no-view表示不需要视图模板express --no-view proj-name cd proj-name安装项目依赖，启动项目npm i npm run start删除跟路由渲染的html文件删除publicindex.html文件引入热更新安装nodemonnpm i nodemon修改package.json中项目启动命令： scripts: start: nodemon ./bin/www 处理跨域安装cors库npm i corsapp.js中进行配置：const cors = require(cors)app.use(cors( origin:http://前端服务地址)) 使用Docker安装MysqlDocker教程 docker-compose 配置docker镜像（SettingsDocker Engine）：registry-mirrors: [ https://docker.hpcloud.cloud, https://docker.m.daocloud.io, https://docker.unsee.tech, https://docker.1panel.live, http://mirrors.ustc.edu.cn, https://docker.chenby.cn, http://mirror.azure.cn, https://dockerpull.org, https://dockerhub.icu, https://hub.rat.dev]在项目根目录新建docker-compose.yml文件：services: mysql: image: mysql:8.3.0 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci environment: - MYSQL_ROOT_PASSWORD=your_password - MYSQL_LOWER_CASE_TABLE_NAMES=0 ports: - 3306:3306 volumes: - ./data/mysql:/var/lib/mysql在根目录终端运行命令：docker-compose up -d在navicat中使用docker-compose.yml中的信息新建连接"},{"title":"4-增删改查","path":"/wiki/Node/clwy_04_rest.html","content":"注意三种查询参数的区别 路由映射参数从req.params中获取get方法，路由拼接参数从req.query中获取postput方法，body中传递从req.body中获取 查询接口查询列表 创建routesadminwebs.js路由映射文件，注意：awaitasync异步处理condition条件查询order 控制排序where 条件查询trycatch异常捕获返回值格式const express = require(express);const router = express.Router();const Op = require(sequelize);const Web = require(../../models)router.get(/,async (req,res)= try const condition = // 添加查询排序条件：根据id从大到小排序 order:[ [id,desc] ], where: name: [Op.like]:`%$name%` const webs = await Web.findAll(condition) res.json( status:true, message:站点列表查询成功, data: webs ) catch(error) // 异常处理 res.status(500).json( status:false, message:查询站点列表失败。, errors:[error.message] ) )module.exports = router;在app.js中引入，并进行路径映射：const adminWebsRouter = require(./routes/admin/webs)app.use(/admin/webs, adminWebsRouter);查询http://localhost:3000/admin/webs即可查询出数据 查询详情 查询详情接口需要注意：从request.params中获取id注意处理id未找到的情况/** * 查询站点详情 */router.get(/:id,async (req,res)= try const id = req.params; const web = await Web.findByPk(id) if(web) res.json( status:true, message:站点详情查询成功, data:web ) else res.status(404).json( status:false, message:站点信息未找到 ) catch(error) // 异常处理 res.status(500).json( status:false, message:查询站点详情失败。, errors:[error.message] ) ) 新增接口新增 新增接口注意事项：创建了新的资源，返回状态码201使用create创建新的数据对req.params中的数据进行白名单筛选/** * 新建站点 */router.post(/,async (req,res)= try const body = getFilterBody(req) const web = await Web.create(body) res.status(201).json( status:true, message:创建站点成功, data:web ) catch(error) // 异常处理 res.status(500).json( status:false, message:创建站点失败, errors:[error.message] ) )/** * 获取到过滤后的body参数 * @param request */function getFilterBody(req) const href, name, webIcon, webCover, content, categoryId, view, github, blogHref = req.body return href, name, webIcon, webCover, content, categoryId:Number(categoryId), view:view?Number(view):0, github, blogHref 删除接口删除注意事项 使用destroy方法删除之前先寻找对应id数据是否存在/** * 删除站点 */router.delete(/:id,async (req,res)= try const id = req.params; const web = await Web.findByPk(id) if(web) await web.destroy() res.json( status:true, message:删除站点成功 ) else res.status(404).json( status:false, message:未找到指定站点 ) catch(error) // 异常处理 res.status(500).json( status:false, message:删除站点失败, errors:[error.message] ) ) 更新接口更新接口注意 使用update方法进行更新先根据id查询数据是否存在，再进行更新/** * 更新站点 */router.put(/:id,async (req,res)= try const id = req.params; const web = await Web.findByPk(id) if(web) const body = getFilterBody(req) await web.update(body) res.json( status:true, message:站点更新成功, data:web ) else res.status(404).json( status:false, message:站点未找到 ) catch(error) // 异常处理 res.status(500).json( status:false, message:站点更新失败。, errors:[error.message] ) ) 模糊搜索模糊搜索 模糊搜索使用的sql语句：select * from Articles where title like %标题 10%`sequelize中，想要使用模糊搜索，需要用到Op：const Op = require(sequelize);在condition中添加where属性：/** * 查询站点列表 */router.get(/,async (req,res)= try const name = req.query const condition = // 添加查询排序条件：根据id从大到小排序 order:[ [id,desc] ] if(name) condition.where = name: [Op.like]:`%$name%` const webs = await Web.findAll(condition) // ..... catch(error) // ..... ) 分页查询分页查询 分页查询的sql语句：SELECT * FROM `Articles` LIMIT offset, limit;分页查询注意事项：根据currentPage和pageSize，手动计算offset使用findAndCount方法condition条件中加入offset和limit属性从返回值中手动提取rows和count值router.get(/,async (req,res)= try const name = req.query const currentPage = Math.abs(Number(req.query.currentPage || 1)) const pageSize = Math.abs(Number(req.query.pageSize || 10)) const offset = (currentPage - 1) * pageSize const condition = // 添加查询排序条件：根据id从大到小排序 order:[ [id,desc] ], limit:pageSize, offset if(name) condition.where = name: [Op.like]:`%$name%` // const webs = await Web.findAll(condition) const rows, count = await Web.findAndCountAll(condition) res.json( status:true, message:站点列表查询成功, data: webs:rows, pagination: total:count, currentPage, pageSize ) catch(error) // 异常处理 res.status(500).json( status:false, message:查询站点列表失败。, errors:[error.message] ) )"},{"title":"5-响应格式封装","path":"/wiki/Node/clwy_05_modelize.html","content":"自定义错误类error 在utilserrors.js中自定义错误类（部分）：/** * 自定义 404 错误类 * 未找到指定资源 */class NotFountError extends Error constructor(message) super(message); this.name = NotFountError; /** * 自定义 401错误类 * 未经认证错误 */class UnauthorizedError extends Error constructor(message) super(message); this.name = UnauthorizedError /** * 自定义400错误 * 传参错误类 */class BadRequestError extends Error constructor(message) super(message); this.name = BadRequestError module.exports = BadRequestError, UnauthorizedError, NotFoundError 成功失败响应封装response 在utilsresponse.js中封装响应函数：/** * 响应成功 * @param res 响应体 * @param message 响应信息 * @param data 数据 * @param code 状态码 */function success(res, message, data=, code = 200) res.status(code).json( status:true, message, data, )/** * 响应错误 * @param res 响应体 * @param error 错误类 * @returns * */function failure(res,error) if(error.name === SequelizeValidationError) const errors = error.errors.map(e=e.message) return res.status(400).json( status: false, message: 请求参数错误, errors:errors ) if(error.name === NotFoundError) return res.status(404).json( status:false, message:资源不存在, errors:[error.message] ) if(error.name === BadRequestError) return res.status(400).json( status:false, message:请求参数错误, errors:[error.message] ) if(error.name === UnauthorizedError) return res.status(401).json( status:false, message:认证失败, errors:[error.message] ) if(error.name === JsonWebTokenError) return res.status(401).json( status:false, message:认证失败, errors:[您提交的token错误] ) if(error.name === TokenExpiredError) return res.status(401).json( status:false, message:认证失败, errors:[您的token已过期] ) res.status(500).json( status: false, message:服务器错误, errors:[error.message] )module.exports = success, failure 实际使用完整的增删改查 const express = require(express);const router = express.Router();const Web = require(../../models)const Op = require(sequelize);const NotFoundError = require(../../utils/errors);const success, failure = require(../../utils/response);/** 查询站点列表 */router.get(/,async (req,res)= try const name = req.query const currentPage = Math.abs(Number(req.query.currentPage || 1)) const pageSize = Math.abs(Number(req.query.pageSize || 10)) const offset = (currentPage - 1) * pageSize const condition = order:[[id,desc]], limit:pageSize, offset if(name) condition.where = name:[Op.like]:`%$name%` const rows, count = await Web.findAndCountAll(condition) success(res,站点列表查询成功, webs:rows, pagination: total:count, currentPage, pageSize ) catch(error) failure(res,error) )/** 查询站点详情 */router.get(/:id,async (req,res)= try const web = await getDataById(req) success(res,站点详情查询成功,web) catch(error) failure(res,error) )/** 新建站点 */router.post(/,async (req,res)= try const body = ...getFilterBody(req), view:0 const web = await Web.create(body) success(res,创建站点成功,web,201) catch(error) failure(res,error) )/** 删除站点 */router.delete(/:id,async (req,res)= try const web = await getDataById(req) await web.destroy() success(res,删除站点成功) catch(error) failure(res,error) )/** 更新站点 */router.put(/:id,async (req,res)= try const web = await getDataById(req) const body = getFilterBody(req) await web.update(body) success(res,站点更新成功,web) catch(error) failure(res,error) )/** * 根据id获取指定数据 * @param req * @returns Promisevoid */async function getDataById(req) const id = req.params const data = await Web.findByPk(id) if(!data) throw new NotFoundError(`未找到ID为：$id 的站点`) return data/** * 获取到过滤后的body参数 * @param request */function getFilterBody(req) const href, name, webIcon, webCover, content, categoryId, github, blogHref = req.body return href, name, webIcon, webCover, content, categoryId:Number(categoryId), github, blogHref module.exports = router;"},{"title":"6-数据库设计","path":"/wiki/Node/clwy_06_dbTable.html","content":"用户表User用户表 表格属性id（编号）：integer，主键，不为null，无符号，自增email（电子邮箱）：varchar，不为null，unique索引username（用户名）：varchar，不为null，unique索引password（密码）：varchar，不为nullrole（用户组）：tinyint，不为null，无符号，index索引，默认为00为普通用户100为管理员modelmigrationseed 应用类型表Type应用类型表 表格属性id（编号）：integer，主键，不为null，无符号，自增name（名称）：varchar，不为nullrank（顺序）：integer，无符号，不为null，默认为1modelmigrationseed 分类类型表Category分类类型表 表格属性id（编号）：integer，主键，不为null，无符号，自增name（名称）：varchar，不为nullrank（顺序）：integer，无符号，不为null，默认为1typeId（类型id）：integer，无符号，不为null，默认为1modelmigrationseed 开发应用表app应用表 表格属性id（编号）：integer，主键，不为null，无符号，自增name（应用名称）：varchar，不为null，icon（图标）: varcharcover（封面）：varcharvideo（视频）：varcharcontent（介绍）：textgithub（源码地址）：varcharblogHref（博客地址）：varcharviewCount（观看数量）：integer，无符号，不为null，默认0categoryId（类型分类）：inter，无符号，不为null，index索引typeId（应用类型）：inter，无符号，不为null，index索引modelmigrationseed 访客记录表View访问记录表 表格属性id（编号）：integer，主键，不为null，无符号，自增userId（访客id）：integer，无符号，不为null，index索引applicationId（访问的应用id）：integer，无符号，不为null，index索引modelmigration 设置表Setting设置表 表格属性id（编号）：integer，主键，不为null，无符号，自增name（项目名称）：varcharicp（备案号）：varcharcopyright（版权信息）：varcharmodelmigrationseed"},{"title":"7-身份认证","path":"/wiki/Node/clwy_07_auth.html","content":"密码加密bcryptjs 使用bcryptjs对密码进行加密，安装bcryptjs库：npm i bcryptjsbcryptjs使用方法：const bcrypt = require(bcryptjs)// 生成10位数的盐const salt = bcrypt.genSaltSync(10)// 对字符进行加密const hash = bcrypt.hashSync(明字符串, salt)简写：const hash = bcrypt.hashSync(明文字符串, 10)当表单获取到用户设置的password后，需要在传入数据库的过程中，对密码进行加密，这一步需要在model字段对应的set函数中处理：password: type:DataTypes.STRING, allowNull:false, // validate: // notNull:msg:密码必须存在, // notEmpty:msg:密码不能为空, // len: // args:[8,30], // msg:密码长度应当在8-30个字符之间 // // , set(value) if(!value) throw new Error(密码必须填写) if(value.length 6 || value.length 45) throw new Error(密码长度必须在6~45之间) // 进行加密 this.setDataValue( password, bcrypt.hashSync(value, 10) ) 将来的登录时，需要使用bcrypt.compareSync对加密后的字符串和明文字符串进行比较：const isPasswordValid = bcrypt.compareSync(12345,加密后的字符串)"},{"title":"第一章 Node简介","path":"/wiki/Node/pl_01_intro.html","content":"决定Web服务器性能的到底是什么？大多数人不能设计一种更简单和更有效率的程序的主要原因是他们用到了阻塞I/O的库 Node的发明者 Ryan Dahl 认为高性能Web服务器需要考虑到两个要点： 事件驱动 非阻塞IO 这也是 Ryan Dahl 选择 JavaScript 编写 Node 的原因，因为 JavaScript 具有的优点和他对高性能Web服务器的要求都对上了，JavaScript 在他眼中： 一是 高性能（V8引擎） 二是 符合事件驱动（浏览器中应用） 三是 历史短 Node与开源精神强制不共享任何资源 Node现在已经发展为一个 强制不共享任何资源 的单线程、单进程系统。并且它自身也非常简单，通过通信协议来组织许多Node，非常容易通过扩展来达成构建大型网络应用的目的。 对比Node与浏览器浏览器的两个主要引擎 JavaScript引擎： V8布局引擎： WebKit长久以来浏览器都是JavaScript运行的沙箱，它的能力取决于浏览器中间层提供的支持有多少。 对比浏览器与Node 除了浏览器具有HTML、WebKit和显卡这些 UI相关技术 的支持外，Node与浏览器结构十分相似，都是 基于事件驱动的异步架构总之，Node不处理UI，但用与浏览器相同的机制和原理运行。 浏览器通过事件驱动来服务 界面上的交互 Node通过事件驱动来服务 IO Node的特点异步IO 经典异步调用——ajax请求 Node中的异步读取文件操作 Ryan Dahl 在底层构建了很多异步IO的API，因此我们可以从语言层面很自然的进行 并行IO 操作 事件与回调函数 Node能够将事件点暴露给业务逻辑 事件编程 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步IO，将事件点暴露给业务逻辑这也就是所谓的事件编程，优点是：轻量级松耦合只关注事务点存在的问题是：多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。 回调函数 回调函数是最好的接受异步调用返回数据的方式异步编程思维要求熟悉：对业务的划分对事件的提炼 单线程 JavaScript与其余线程无法共享任何状态 单线程的弱点主要有： 无法利用 多核CPU 错误会 引起整个应用退出， 应用 健壮性 低 大量计算占用CPU 导致无法继续调用异步IO child_process Node使用child_process来解决单线程中大计算量的问题。通过将计算分发到各个子进程，再通过进程之间的事件消息来传递结果 跨平台 借助libuv组件，Node实现了跨平台的兼容 Node应用场景IO密集型 Node面向网络且擅长并行IO，能够有效组织起更多的硬件资源 事件循环处理 Node利用事件循环处理密集IO，而不是启动每一个线程为每一个请求服务，资源占用极少 CPU密集型Node的运行效率算得上高效吗？ 答： Node当然足够高效，主要归功于V8的深度性能优化。 CPU密集型给Node带来的挑战是什么？ 对于长时间的运算（如大循环）会导致CPU时间片长时间无法释放，由于Node单线程的特点，后续IO无法发起。 Node的对应策略 方法1：分解适当调整和分解大型运算任务为多个小任务。方法2：异步IONode的异步IO已经解决了单线程上CPU与IO之间阻塞无法重叠利用的问题"},{"title":"第三章 异步I/O","path":"/wiki/Node/pl_03_IO.html","content":"异步与前端的不解之缘 前端编程算是 GUI编程 的一种, 因此驱动程序的很大部分都是异步事件，但糟糕的是： 人类天生就不擅长异步思维 PHP：知道这一点我就放心了 PHP算是彻头彻尾的单线程同步语言 在小规模站点中几乎没有缺点， 但是在复杂网络应用中会因为阻塞导致无法很好的并发。 事实上就算是提供了异步API，很多人也用不习惯 异步IO还有两个好兄弟： 事件驱动 单线程 同样在这两个方向有出色设计理念的产品还有下面这位： Nginx Nginx具备面向客户端管理连结的强大能力， 但是它依然受限于背后各种同步方式的编程语言。 为什么要异步IO用户体验 《高性能JavaScript》- Nicholas C.Zakas 前端获取两个同样的资源： 同步方式 getData(from_db); // 消费时间为MgetData(from_remote_api); //消费时间为B 总耗时：M+N 异步方式 getData(from_db,function(result) // 消费时间为M)getData(from_remote_api,function(result) // 消费时间为N) 总耗时：max(M, N) 不同的I/O类型对应的开销 I/O类型 消耗CPU时钟周期 CPU一级缓存 3 CPU二级缓存 14 内存 250 硬盘 41000000 网络 240000000 分布式应用会使M和N值呈线性增长， 这也是分布式应用会放大同步和异步差异的原因。 资源分配资源分配主要涉及到两部分计算机组件： IO设备 计算设备 主流的资源分配的方法有以下两种： 单线程串行依次执行 IO设备 为主 易于表达 阻塞IO导致硬件资源得不到更优使用 多线程并行完成 计算设备为主 能够提高多核CPU设备的CPU利用率 创建线程和执行期线程上下文切换开销大 经常面临锁、状态同步等问题 Node给出的方案 - 单线程还是多线程？ - **单线程** - 同步还是异步？ - **异步** 如何弥补单进程缺点？ Node无法有效利用多核CPU设备资源， 但是提供了**子进程机制**（类似前端浏览器中的 *Web Workers*） 异步IO实现现状同步、异步、阻塞、非阻塞、回调、事件…这些概念的引入实际上都是为了达成一个目的：并行IO。但实际考虑到操作系统时，只涉及到两种IO方式： 阻塞IO 非阻塞IO 阻塞和非阻塞 阻塞I/O 应用程序需要等待I/O完成才返回结果。 调用之后一定要等到系统内核完成所有操作之后才算做调用结束。 非阻塞I/O 应用程序在调用后立刻能获取到返回值。 需要通过文件描述符再次读取。 阻塞IO 非阻塞IO 操作系统如何实现非阻塞IO（文件描述符）首先要知道操作系统是如何进行IO操作的：IO设备在操作系统中，实际上都是被抽象成了文件，IO设备抽象成的文件有一个关键属性：文件描述符，应用程序如果需要实现IO调用： 首先打开文件描述符 根据文件描述符实现文件读写 因此文件描述符就是应用程序与系统内核之间的交互凭证，也是非阻塞IO方式获取数据的关键所在。 轮询非阻塞IO调用后能立即返回内容，但返回的并不是实际数据，而只是当前调用的状态。实际需要反复发起IO调用来确认是否完成（复读机）。目前有几类轮询技术： 机制 示意图 补充 read 单纯的重复调用检查IO状态方式 select 相比read，select检查的不是IO的状态而是文件描述符的状态 采用一个1024长的数组存储状态 poll 相比select的数组结构，采用了链表方式避免长度限制，过滤掉不必要的检查 epoll 采用了轮询-休眠-唤醒的事件通知机制，Linux下效率最高的轮询机制 equeue 类似epoll机制，仅在FreeBSD系统下存在 总结这几种方法之后，发现在应用程序发出请求之后，CPU不是在遍历IO状态，就是在遍历文件描述符状态，或者在休眠，因此实际上仍旧是一种同步机制。 理想的非阻塞异步IO既然各种轮询的方式都不能很好的实现异步IO，那么到底什么才是理想的非阻塞异步IO机制呢？ 大致如下： 应用程序发出IO请求 直接开始处理下一个任务 IO处理完成后通过信号或回调将数据传递给应用程序 之所以异步IO的实现如此困难的原因，就在于 通过信号和回调传递数据 这一步 Linux内核IO中的O_DIRECT方式读取数据时使用的AIO方式实际实现了这种机制 现实的异步IO在Windows和*nix平台下，Node采用了不同的异步IO方案： *nix：libeio 采用线程池和阻塞IO模拟异步IO Windows：IOCP 同样是线程池原理，不同之处在于线程池由系统内核接手管理 Node中，用于处理平台差异的层即libuv： libuv作为抽象封装层，用于平台兼容性判断 保证上层Node与下层自定义线程池（libeio）和IOCP各自独立 IO的两个误区： IO不仅仅限于磁盘文件读写，实际范围包括几乎所有计算机资源，包括： 磁盘文件 硬件 套接字 Node仅仅只是JavaScript执行在单线程中 Node内部完成IO任务实际需要依赖线程池机制 Node的异步IONode异步IO的三个主要机制： 事件循环 观察者 请求对象 事件循环进程启动时Node会发起事件循环，循环体单位又称Tick每个Tick实际就是查看是否有事件待处理 观察者对于每种事件都有相应的观察者，当事件被触发时，由对应观察者收集到事件循环中处理。观察者将事件进行了分类，Node中的事件主要来源于： 网络请求 文件IO 请求对象从JavaScript发起异步调用，到内核执行完IO操作的过渡过程中，存在一种中间产物，即请求对象 fs.open()调用过程 JavaScript调用Node核心模块 核心模块调用C++内建模块 内建模块通过libuv进行系统调用 回调函数的实现在第三步： 调用uv_fs_open()方法 其中创建请求对象FSReqWrap 回调函数放在FSReqWrap.oncomplete_sym中req_wrap-object_-Set(oncomplete_sym, callback) FSReqWrap包装完毕 将请求对象推入线程池中等待执行调用QueueUserWorkItem() 请求对象执行 回调通知 请求对象推入线程池方法QueueUserWorkItem(uv_fs_thread_proc, req, WT_EXECUTEDEFAULT) 参数1：uv_fs_thread_proc将要执行的方法的引用根据传入req类型调用相应底层函数如uv_fs_open()实际调用的是fs__open() 参数2：req参数1方法运行时所需要的参数 参数3：WT_EXECUTEDEFAULT执行的标志 执行回调回调通知的具体步骤如下： 事件处理完毕，存储结果 结果在req-result属性上 状态改变 调用PostQueuedCompletionStatus通知IOCP 提交状态，返还线程 等待检测 调用GetQueuedCompletionStatus检测完成状态请求 事件包装 被检测出完成的请求被加入观察者队列，包装成事件处理req_wrap-object_-Set(oncomplete_sym, callback) 事件回调取出result-oncomplete_sym属性作为回调方法执行 回调通知方法：PostQueuedCompletionStatus((loop)-iocp, 0, 0, ((req)-overlapped)) 方法作用是： 向IOCP提交执行状态 将线程归还线程池 检查线程池任务状态方法：GetQueuedCompletionStatus() 用于检查线程池中是否有执行完的请求： 如果有，将请求对象加入IO观察者队列，当做事件处理（onData） 非IO的异步API setTimeout() setInterval() setImmediate() process.nextTick() 定时器 setTimeout 单次定时执行任务 setInterval 多次定时执行任务 定时器算是不需要IO线程池参与的事件插入，由定时器观察者观察。 定时器存在的问题在于并非精确，严格来说它不是异步执行的，如果一次循环占用时间较多会导致超时 setTimeout(function() // 任务1：花费9ms // 任务2: 花费5ms,10)// 超时： 9+5-10=4ms process.nextTick()let process = require(node:process)process.nextTick(callback) 同样是为了进行异步操作：process.nextTick和定时器的区别： 定时器 需要动用红黑树，创造定时器对象和迭代等操作 时间复杂度：O(lg(n)) process.nextTick 只会将回调函数放入事件循环队列中，在下一轮Tick时取出执行 时间复杂度：O(1) setImmediatesetImmediate与process.nextTick功能很相似，不同点有下面这些： 执行优先级不同 nextTick setTimeout setImmediate setTimeout(() = console.log(setTimeout) ,0) setImmediate(() = console.log(setImmediate) ) process.nextTick(() = console.log(nextTick) ) console.log(normal) // normal // nextTick // setTimeout // setImmediate 观察者不同 setImmediate属于check观察者 process.nextTick属于idle观察者 idle观察者 check观察者 IO观察者 回调函数存储结构不同 process.nextTick存在数组里 setImmediate存在链表里 执行方式不同 process.nextTick将数组中的回调函数全部执行完 setImmediate执行链表中的一个回调函数 事件驱动与高性能服务器异步实现的两个基本要点： 主循环 事件触发 网络套接字的处理（Node构建Web服务器） 从网络套接字上侦听到请求 将请求形成网络IO事件交给IO观察者 触发对应IO事件的回调函数 经典服务器模型 同步式 一次只能处理一个请求 易阻塞 每进程每请求 为每个请求启动一个进程 扩展性差 每线程每请求（Apache） 为每个请求启动一个线程 扩展性稍强 大并发情况下服务器缓慢 事件驱动服务器模型（Node，Nginx） 事件驱动线程少，操作系统上下文切换代价低，但需要注意： 一旦事件循环中存在阻塞IO，实际效果和同步式服务没有区别，性能会急剧下降"},{"title":"第二章 模块机制","path":"/wiki/Node/pl_02_module.html","content":"JavaScript的鸡汤时间 JS酱の不受重视的童年JavaScript当初被仓促的创造出来，主要就是为了实现2个功能：表单校验网页特效JS酱の进化但随着BS应用的兴起，JavaScript也越来越收到重视，渐渐地就经历了一系列进化：工具（浏览器兼容）组件（功能模块）框架（功能模块组织）应用（业务模块组织）后端の新星JS酱但是JavaScript先天就缺乏模块功能，script标签引入代码的方式毫无章法，非常蛋疼，于是就出现了 命名空间 的人为规范来约束代码。开发者：还能不开发了咋地，加入命名空间凑合着写吧最终经历了十多年的发展，CommonJS规范 终于被提出，JavaScript的模块化功能也得以完善，最终成功破壁，进入后端开发领域。 CommonJS规范CommonJS出发点在CommonJS没有被提出之前，JavaScript一直使用的是官方规范 ECMAScript，但是JavaScript在实际环境中，表现能力始终都取决于宿主环境对API的支持程度在缓慢の进化过程中的JS酱，常常因为这些原因被后端开发拒之门外：没有模块系统标准库较少没有标准接口缺乏包管理系统但是在引入CommonJS之后，JS酱终于具备了跨宿主环境执行的能力。于是除了客户端应用，JavaScript此后还能开发以下应用：服务器端JavaScript应用程序命令行工具桌面图形界面应用程序混合应用 Node、浏览器、W3C、CommonJS、ECMAScript之间的关系 浏览器： HTML、 CSS 、 JavaScript 的运行环境W3C： 对 BOM 和 DOM 进行规范化ECMAScript： 对 JavaScript 进行规范化CommonJS： 对 JavaScript 进行脱离宿主环境规范化Node： 同时兼容 ECMAScript 和 CommonJS 规范的js服务器端语言 CommonJS模块规范 模块的意义在于将类聚的方法和变量等限定在私有的作用域中 模块定义的3个部分 模块引用使用 require() 方法 let myModule = require(myModule);模块定义使用 module.exports 对象 // math.jsexports.add = function() let sum = 0, i = 0, args = arguments, l = args.length; while(il) sum+=args[i++]; return sum;; // program.jslet math = require(math);exports.increment = function(val) return math.add(val,1);模块标识let myModule = require(模块标识) 模块标识就是 require() 方法接收的参数，它可以遵从以下几种格式： 符合小驼峰命名的字符串 以...开头的相对路径 绝对路径 Node的模块实现Node中引入模块主要有3个步骤： 下面这行代码就好像叫你的下属 Node酱 给你找一份叫做 myModule 的东西出份材料：let myModule = require(myModule)和大多数被Boss搞蒙圈的社畜一样，Node酱一上来就是三个问题：路径分析Node：我上哪去取这个东西呢？文件定位Node：你说的这个myModule，它是个什么东西？编译执行 Node：我怎么用这个东西出材料呢？ Node的两类模块 核心模块Node提供静态内存加载速度快文件模块用户编写动态加载速度慢 文件加载优先级Node的缓存策略 Node会对引入过的模块进行缓存，以减少二次引入时的开销浏览器缓存策略也差不多：浏览器：缓存文件Node：缓存编译和执行之后的对象 加载优先级 优先级遵循两个顺序：缓存优先教科书式废话，要不然干嘛引入缓存策略核心模块优先于文件模块把这两个原则缝合一下就得出了完整的缓存优先级排序：缓存核心模块 缓存文件模块 核心模块 文件模块 路径分析和文件定位路径分析 Node:我上哪去取呢（挠头）？核心模块路径形式文件模块非路径非核心文件模块如 http、fs、path等特殊情况：自定义模块标识符核心模块标识符如果是路径文件模块的话撞名还好说，但自定义模块没有路径标识，什么都不处理百分百会被核心模块覆盖，所以还是考虑换个模块名吧或者换个路径吧。又划分为相对路径形式：以 ... 开头绝对路径形式：以 开头路径首先会被转为 真实路径，之后如果二次加载该模块，就直接用这个 真实了路径 作为索引到指定位置取就好了。编译成功的模块的文件路径作为索引缓存在 Module._cache对象上比如：let myModule = require(./myModule)Node首先会 .myModule 转化为绝对路径 path：D:\\CS_Demo\\V_Demo\\NodeJs_Demo\\深入浅出NodeJS\\day1_module\\myModule.js然后将path作为索引，下一次我再用到myModule模块，就直接会找到path对应的文件也就是 自定义模块，这类文件模块由于 文件路径一般比较深，因此查找起来比较费时。 模块路径 Node将文件定位策略涉及到的查找路径放在了一个数组中，即 module.paths console.log(module.path) //输出路径数组 // 输出结果[ D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\深入浅出NodeJS\\\\day1_module\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\\\深入浅出NodeJS\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\\\NodeJs_Demo\\ ode_modules, D:\\\\CS_Demo\\\\V_Demo\\ ode_modules, D:\\\\CS_Demo\\ ode_modules, D:\\ ode_modules] 即从当前路径起，直到根目录 ode_modules，依次向父级递归直到找到为止。 文件定位 两个细节文件扩展名分析Node：你让我找的模块是个什么文件？别一会儿给你找来了又说不是你要的目录和包的处理Node：你说的的那个模块我没找到，但我找到个同名目录，凑合着用吧文件扩展名分析目录分析和包你和Node说：// 帮我从食堂带份番茄炒鸡蛋let dinner = require(./番茄炒鸡蛋)Node一共就知道食堂有三个窗口卖番茄炒鸡蛋：js窗口json窗口node窗口然后Node就开始一个窗口一个窗口的找，看还有没有卖番茄炒鸡蛋的。这就是Node中文件扩展名分析的策略，当然也可以一开始就指定好你要的文件的类型，注意这里Node跑窗口是要花时间的，需要 调用fs模块同步阻塞式判断 文件是否存在，所以指定json和node类型模块时，和Node一开始说清楚你要的模块会省去扩展名分析花费的时间。你叫Node帮你去一家叫做摩卡的咖啡店买杯摩卡：let dinner = require(./Mocha)结果Node一去发现店里没有卖摩卡的，结果把整家店都给买下来了（不愧是你）这里需要了解Node分析目录的一些规则：首先，在目录下寻找 package.json 文件Node找到咖啡厅的餐厅手册——package.jsonNode开始翻看起来——JSON.parse()Node在手册的main菜单查看是否有卖摩卡的package.json：CommonJS包规范定义的包描述文件package.json被解析后，其中的 main属性 会被提取出来作为文件名进行定位，当main属性的路径错误或根本没指定时…（Node：你丫玩我是吧？白解析了）Node发现main菜单里没写卖摩卡Node心想那就买杯index美式凑合一下吧Node会把 index 作为默认文件名，挨个查找：index.jsindex.nodeindex.json如果还是没有找到的话…结果Node一问店员，什么？连index美式都没有？Node震惊了，但是店员又和Node推荐了一家更大的父级咖啡厅，让它去那买还记得 module.path 吗？没错，顺着路径找到父级目录再重复一遍上面的操作。 模块编译模块对象 万物可对象，每个文件模块也是作为对象包装的：function Module(id, parent) this.id = id this.exports = this.parent = parent if (parent parent.children) // parent喜当爹 parent.children.push(this) this.filename = null this.loaded = false this.children = [] 模块编译 万物可对象(这话好像刚才说过)，连编译载入的方法也被作为对象包装在require中：不同文件的加载方式放在了 require.extensions 中console.log(require.extensions);输出结果： .js: [Function (anonymous)], .json: [Function (anonymous)], .node: [Function (anonymous)]也可以通过对 require.extensions 的扩展来实现自定义扩展名文件的加载：require.extensions[.duck] = function(module, filename) // 加载.duck文件 .js文件.node文件.JSON文件通过fs模块同步读取文件后编译执行Step1 对js源代码进行头尾包装(function (exports, require, module, __filename, __dirname) //包装头 let math = require(math); exports.area = function (radius) return Math.PI * radius * radius; ); // 包装尾这样就实现了 作用域隔离Step2 使用包装后的代码创建一个具体的function对象使用的是vm原生模块的 runInThisContext()返回一个具体function对象Step3 传参执行Step1中包装成的函数参数主要如下：exports 当前模块对象的exportsrequire 引入方法module 当前模块对象自身__filename 文件定位的完整路径__dirname 文件目录.node是用 CC++ 编译后生成的模块文件，加载和执行方法：process.dlopen()总之就是在 dlopen() 中让exports和.node产生联系（别问怎么产生的联系，问就是量子纠缠）通过fs模块同步读取文件后编译执行解析方法：JSON.parse()解析后直接赋给模块对象的exports 核心模块核心模块的两个部分 CC++文件放在src目录下JavaScript文件放在lib目录下（lib*.js）src目录下的node.js（srcnode.js） JavaScript核心模块的编译过程Step1：转存为C/C++代码Step2：开始编译怎么把核心代码中的js部分加载到内存中呢？0分答案： 第一步，取出js代码，第二步：放入内存你搁这搁这呢 实际上是需要将js转存为CC++，然后再加载到内存之中。问题又来了：如何将js转化为CC++呢？答： Node采用的是V8的 js2c.py。 Step1 转换成C++数组这里需要把js代码以字符串形式存储在node命名空间中Step2 生成node_natives.h头文件存储在node命名空间中，无法直接执行Step3 加载进内存中在启动Node之后，js代码会被加载进内存中核心模块和文件模块的缓存位置不同：核心模块 NativeModule._cache文件模块 Module._cachefunction NativeModule(id) this.filenmae = id + .js this.id = id this.exports = this.loaded = false// 取出源代码NativeModule._source = process.binding(native)// 缓存NativeModule._cache = CC++核心模块的编译过程Node核心代码的两种形式 单一模式全部由CC++编写复合模式C++实现核心部分JavaScript实现封装Node提高性能的常用模式 内建模块 由 纯CC++ 编写的部分又称为 内建模块，内建模块组织形式1-内部结构struct node_module_struct int version; void *dso_handle; const char *filename; // 模块的具体初始化方法 void (*register_func) (v8::Handlev8::Object target); const char *modname;2-定义模块被创建后就自然要被定义到 node命名空间 中，需要通过 NODE_MODULE宏 #define NODE_MODULE(modename, regfunc) extern C NODE_MODULE_EXPORT node::node_module_struct modname ## _module = NODE_STANDARD_MODULE_STUFF, regfunc, NODE_STRINGIFY(modename) 3-取出Node提供了 get_builtin_module() 从 node_module_list 数组取出这些模块 内建模块导出Node使用 Binding() 方法实现内建模块的加载,具体步骤如下：step1-创建一个exports空对象exports = Object::New();step2-取出内建模块对象modp = get_builtin_module(*module_v);step3-填充exports对象modp-register_func(exports);step4-按模块名缓存exports对象binding_cache-Set(module, exports);step5-核心模块编译内容的取出使用到Node提供的全局变量processNativeModule._source = process.binding(natives); 核心模块的引入流程以os模块的引入为例 Step1-用户请求模块require(os)Step2-分析确定是核心模块的请求NativeModule.require(os)Step3-需要取出模块为字符串数组并转化为字符串process.binding(os)Step4-需要取出模块对象get_builtin_module(node_os)Step5-需要定义模块对象NODE_MODULE(node_os, reg_func) 编写核心模块内建模块hello的实现 1-编写头文件2-编写C/C++文件3-添加进扩展数组中4-编译进执行文件5-运行核心模块头文件node_hello.h存放到src目录下#ifndef NODE_HELLO_H_#define NODE_HELLO_H_#include v8.hnamespace node // 预定义方法 v8::Handlev8::Value SayHello(const v8::Arguments args);将用于实现预定义方法的 node_hello.cc 存储到 src 目录下#include node.h#include node_hello.h#include v8.hnamespace node using namespace v8; // 实现预定义方法 HandleValue SayHello(const Arguments args) HandleScope scope; return scope.Close(String::New(Hello world!)); // 给传入的目标对象添加sayHello方法 void Init_Hello(HandleObject target) target-Set( String::NewSymbol(sayHello), FunctionTemplate::New(SayHello) ) // 注册方法到内存中NODE_MODULE(node_hello, node::Init_Hello)需要修改 srcnode_extensions.h ，将node_hello模块添加进node_module_list数组中修改Node项目生成文件 node.gyp，然后编译整个Node项目let hello = process.binding(hello)hello.sayHello() // Hello World! CC++扩展模块CC++模块引入的最佳场合是什么 答： 频繁出现 位运算 的场合,如 转码、 编码 等过程。这是因为JS酱的位运算很弱啦（傲娇）C++：哎，拜托，弱哎，你很弱哎——JavaScript只有 double类型 的数据类型，位运算时需要转换为 int类型，因此效率不高。 CC++扩展模块的跨平台问题 之前提到CC++扩展模块会预先编译为 .node 文件，这就存在一个问题，就是这个 .node 后缀只是个包装，包装之下的内容实际如下：windows系统下是 .dll*nix系统下是 .sodlopen方法实际上对两种文件分别进行处理。 前提条件GYP工具V8引擎libuv库Node内部库其他库全称 Generate Your Projects，用于生成各个平台下的项目文件，node-gyp是为Node提供的专有扩展构建工具npm install -g node-gypV8引擎本身就是用 C++ 写成的，因此能够实现 JavaScript 和 C++ 的相互调用Node能够实现跨平台的诀窍，它支持Node调用底层操作（事件循环、文件操作等）Node自身提供的一些C++代码。存在 deps目录 下。 CC++扩展模块的编写CC++扩展模块的编译CC++扩展模块的加载模块调用栈模块之间的调用关系 核心模块CC++内建模块：最底层的模块JavaScript模块：作为内建模块的 封装层和桥阶层供文件模块调用文件模块CC++扩展模块JavaScript模块：纯粹功能模块 包与NPMnpm官网https://www.npmjs.org/ 一个对npm包下载数量进行排名的网站http://npmrank.net/ anvaka统计的19年之前安装次数前1000名npm包https://gist.github.com/anvaka/8e8fa57c7ee1350e3491 CommonJS的包规范 包和NPM就是将模块联系起来的一种机制，就像是将不同生物联系到一起的食物链CommonJS包规范规定包由两个部分组成：包描述文件包结构文件 包结构包这个概念可能过于抽象，具体些说，包实际就是一个存档文件（.ziptar.gz） 完全符合CommonJS规范的包目录 package.json 包描述文件lib 可执行二进制文件目录bin JavaScript文件目录doc 文档目录test 单元测试用例目录 包描述文件与NPMpackage.json package.json位于包的根目录下，CommonJS为其定义了一些描述字段：必需字段 name 包名 包名不能出现空格，可以包含如下字符： 小写字母 数字 . _ “name”: “goodbye-world” description 包简介 “description”: “world:why everybody has to say hello to me?” version 版本号 语义化版本号的详细定义https://semver.org/ “version”: “1.0.0” keywords 关键词数组 用于做分类搜索 “keywords”: [“jeusttest”, “dontdownload”, “goaway”] maintainers 包维护者列表 每个维护者包含 name email web maintainers: [{name:God, email:highestgod@heaven.com,web:www.notwelcomemotals.com}] 用于权限认证的字段 contributors 贡献者列表 bugs 一个可以反馈bug的地址 licenses 许可证列表 repositories 托管源代码位置 dependencies 依赖包列表 可选字段 hoempage 包的网站地址 os 操作系统支持列表 包括 aix、freebsd、linux、macos、solaris、vxworks、windows 等 cpu CPU架构支持列表 包括 arm、mips、ppc、sparc、x86、x86_64 等 engine 支持的JavaScript引擎列表 包括 v8、ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal 等 builtin 底层内建模块的标志 directories 包目录说明 implements 实现规范列表 scripts 脚本说明对象 NPM实际需要的字段 author 包作者 bin 用于添加到执行路径在命令行工具中调用的脚本 main 指定模块入口 DevDependencies 只在开发时需要的依赖 NPM最初是由 Isaac Z. Schlueter 单独创建的，但在v0.6.3版本时被集成进Node作为 默认包管理器 局域NPM考虑到模块保密性，企业一般搭建自己的NPM仓库。 如何搭建局域NPM仓库？ 与搭建镜像站方式几乎一样，附录D待补充 原文作者提到局域NPM仓库搭建的一个用处，很有趣： ”不至于让各个小项目各自维护相同功能的模块，（重复劳动）杜绝通过复制粘贴实现代码共享的行为。（无脑重复）“ 怎样评价一个包的质量NPM平台上有成千上万个包，对模块品质进行判断并不容易， 特别是： 包质量 安全问题 因此开发采纳包很多时候也是根据 口碑效应。 模块口碑参考方式 NPM模块首页依赖榜 https://www.npmjs.com/ GitHub 观察者数量 流行度 包结构 测试用例 文档状况 包安全检查 安全检查的难点主要在于 CC++扩展模块，对于模块安全的检查，Isaac Z. Schlueter 提出了一个有趣的词：Kwalitee“Kwalitee” is something that looks like quality, sounds like quality,but is not quite quality.意思就是很多模块表面看上去很优质，但也不一定真正是高质量模块。比较常用的考查点可以参考下面这些：覆盖率较高的测试模块文档编码规范"},{"title":"第四章 异步编程","path":"/wiki/Node/pl_04_async.html","content":"函数式编程高阶函数 即将函数作为参数或返回值的函数function foo(x) return function() return x; 高阶函数是回调函数和深层嵌套的基础 偏函数 偏函数用于创建一系列具有相同特征的函数，即所谓的工厂函数。偏函数案例1重复实现类型判断函数：let isString = function(obj) return toString.call(obj) == [object Stirng]let isFunction = function(obj) return toString.call(obj) == [object Function]引入类型判断工厂函数：let isType = function(type) return function(obj) return toString.call(obj) == `[object $type]`; 偏函数案例2源自著名类库Underscore的 after() 方法的实现：// 生成一个需要调用多次才能执行的函数let _after = function(time,func) if(time=0) return func() return function() if(--time = 0) return func.apply(this,arguments) let after_hello = _after(3,function()console.log(hello))after_hello() // -after_hello() // -after_hello() // hello 异步编程的优势与难点实现异步的一般方式即事件循环和线程池机制，但还有一种方式： 通过CC++调用操作系统底层接口，手动实现异步IO 优势Node与云计算 非阻塞IO可以使CPU与IO不用相互等待，这种组织资源的方式符合分布式和云的需要 异步I/O调用示意图 同步I/O调用示意图 IO密集与CPU密集 事件循环中，JavaScript和IO线程池分饰两角：JavaScript（政客）：分配任务+处理结果IO线程池（公务员）：执行任务最典型的应用即UI编程，因此Node更适合IO密集型场景Node在CPU密集型应用的优化V8的优化使得JavaScript本身的性能就很出色，但Node在CPU密集型上的性能还需要考虑JavaScript代码组织的方式，简单来说：只要CPU计算不影响IO的调度，就没有问题。建议CPU耗用不超过10ms，可以将大量的计算分解为小量计算，然后通过setImmediate调度 难点异常处理函数嵌套过深阻塞代码多线程编程异步转同步无法通过trycatch操作抓住异步IO回调函数的错误 const async = function (callback) process.nextTick(callback)const err = function () throw new Error(Catch me if you can)try async(err) catch (e) console.log(catch you!) // catch无效 为了捕捉回调函数的异常，出现一种约定： 将异常作为回调函数的第一个实参 function async(callback) process.nextTick(function () let results = hello try // 处理过程存在错误 throw new Error(catch me if you can) catch (e) callback(e) // 返回错误 return callback(null,results) )function callback(err, results) if (err) console.log(catch you!) else console.log(results) async(callback)当多个操作之间存在依赖关系时，就会出现下面这种结构： // 先获取模板fs.readFile(template_path, utf_8, function(err, template) db.query(sql, function(err, data) // 再获取数据 110n.get(function(err,resources) // 最终获取资源 ) ))JavaScript无法实现线程沉睡功能，下面是一种相当糟糕的模拟sleep的方式： let start = new Date()// CPU：这什么失眠操作？while(new Date() - start1000)当提到JavaScript的单线程执行时， 浏览器层面指的是 UI渲染和JavaScript执行用的是同一个线程 Node层面则指 Node进程无法充分利用多核CPU执行 Web Workers 浏览器端提出的Web Workers具有以下几种作用：将JavaScript执行与UI渲染分离使用CPU减少阻塞UI渲染问题但并没有优化UI渲染效率可利用多核CPU进行大量计算利用消息机制的理想模型Web Workers的消息机制 Web Workers由于浏览器标准原因并没有广泛推广开来，但Node中借鉴了Web Workers的模式：child_process作为基础应用cluster模块为更深层次应用异步编程风格对开发者的副作用不少，如： 嵌套回调 业务分散 但通过良好的流程控制，还是能够将逻辑梳理成顺序形式 异步编程解决方案事件发布订阅模式events Node documentation - Eventshttps://nodejs.org/docs/latest/api/events.htmlconst EventEmitter = require(node:events)class MyEmitter extends EventEmitterconst myEmitter = new MyEmitter()myEmitter.on(event,()= //添加监听器 console.log(event occured!))myEmitter.emit(event) // event occured!emit调用的回调函数是异步触发的const emit = new EventEmitter() //事件发布者const eventName = event // 事件名称emit.on(eventName, 侦听器1)emit.on(eventName, 侦听器2)emit.on(eventName, 侦听器3) 事件发布订阅模式的几个主要作用 解耦业务逻辑钩子机制一个事件能够绑定多个侦听器，事件发布者无需关注订阅侦听器如何实现业务逻辑。事件的设计关乎外部调用组件时是否优雅钩子（hook）机制即导出内部数据或状态给外部调用者， const http = require(http)const options = host: 127.0.0.1, port: 8080, path: /anypath, method: POSTconst req = http.require(options, function (res) console.log(`STATUS: $res.statusCode`) console.log(`HEADERS: $JSON.stringify(res.headers)`) res.setEncoding(utf8) // 获取数据钩子 res.on(data, function (chunk) console.log(`BODY: $chunk`) ) // 结束连接钩子 res.on(end,function()) // 报错钩子 res.on(error, function (e) console.log(`problem with request: $e.message`) ) req.write(data ) req.write(data ) req.end()) 事件发布订阅机制的健壮性 一个事件添加了超过10条侦听器会得到一条警告：/** * MaxListenersExceededWarning: * Possible EventEmitter memory leak detected. * 11 triggers listeners added to [EventEmitter]. * Use emitter.setMaxListeners() to increase limit */const EventEmitter = require(node:events)const emitter = new EventEmitter()for (let i = 0; i 11; i++) emitter.on(event,function())emitter.emit(event)这是为了防止内存泄漏而设置的警告，可以通过调用setMaxListeners去掉限制：const emitter = new EventEmitter()emitter.setMaxListeners(0) //for (let i = 0; i 11; i++) emitter.on(event,function())error事件如果错误触发了error事件，EventEmitter会对error事件进行检测：注册过error事件，将交由侦听器处理未注册过，作为异常抛出 补充点 继承events模块Node的util模块中封装了继承的方法inherits const events = require(events)const util = require(util)function Stream() events.EventEmitter.call(this)// Stream继承了EventEmitterutil.inherits(Stream, events.EventEmitter)const emitter = new Stream()emitter.on(event, function () console.log(hello world))emitter.emit(event) // hello world利用事件队列解决雪崩问题 雪崩的一种典型场景：用户重试导致系统负载升高，集中到服务器端即重复事件响应 所谓雪崩，就是在高访问量、大并发量的情况下缓存失效的情景，如下是一次sql查询的调用 let select = function (callback) db.select(SQL, function (results) callback(results) ) 这时如果同时出现下面两种情况就会出现雪崩： 站点刚启动，缓存中不存在数据 访问量巨大，同一条SQL发送到数据库中重复查询 因此可以引入状态锁： let _status = ready // 状态锁const select = function (callback) if (_status === ready) _status = pending //暂时拒绝受理其他请求 db.select(SQL, function (results) _status = ready //受理结束后将状态重新修改为ready callback(results) ) 但只有第一个发送的请求能获取到数据，其他的请求都被pending拒之门外了 解决方法：once 通过once添加的侦听器只会执行一次 const events = require(events)const proxy = new events.EventEmitter()let status = readyfunction selected(callback) proxy.once(select, callback) if (status === ready) status = pending db.select(SQL, function (results) proxy.emit(selected, results) status = ready ) Gearman异步应用框架也能实现这种效果多异步之间的协作方案当一个业务逻辑需要依赖多个通过回调或事件传递的结果时，就可能出现嵌套过深的问题： function handle() // 有些回调函数看起来是并行执行，实际完全是串行 onehandler(()= twohandler(()= threehandler(()= // 别问，问就是回调艺术 ) ) ) 案例：回调嵌套过深的避免 渲染页面需要异步请求三类资源：模板数据本地化资源let count = 0 // 哨兵变量let results = function done(key, value) count++ results[key] = value if (count = 3) render(results) // 读取模板fs.readFile(template_path, utf8, (err, template) = done(template, template))// 读取数据db.query(sql, (err, data) = done(data, data))// 读取本地化资源l10n.get((err, resources) = done(resources, resources))哨兵变量：借助一个第三方函数变量来处理异步协作的结果 偏函数+哨兵变量 function after(time, callback) let result = let count = 0 return function (key, value) result[key] = value count++ if (count = time) callback(result) const done = after(3, render) 事件与侦听器的关系 一对多 通过订阅模式实现侦听器发散emitter.on(event,listener1)emitter.on(event,listener2)多对一 通过偏函数实现事件收敛const done = after(times, callback)emitter.on(event1, done)emitter.on(event2, done)EventProxy的原理npm - eventproxyhttps://www.npmjs.com/package/eventproxy EventProxy.all EventProxy.all(e1,e2,…,listener)listener参数顺序与订阅组合事件列表的参数是一一对应的当每个事件都被触发之后，侦听器才会执行const EventProxy = require(./node_modules/eventproxy/index)const proxy = new EventProxy()proxy.all( template, data, resources, function (template, data, resources) console.log(...arguments) // template data resources )proxy.on(template, res = res)proxy.on(data, res = res)proxy.on(resources, res = res)proxy.emit(template,template)proxy.emit(data,data)proxy.emit(resources,resources) EventProxy.tail EventProxy.tail与all的区别在于：组合事件中某个事件被再次触发，侦听器会使用最新的数据继续执行const EventProxy = require(./node_modules/eventproxy/index)const proxy = new EventProxy()proxy.on(eventA, res = res)proxy.on(eventB, res = res)proxy.all(eventA, eventB, (a, b) = console.log(`all: $a $b`))proxy.tail(eventA, eventB, (a, b) = console.log(`tall: $a $b`))proxy.emit(eventA, AAA)proxy.emit(eventB, BBB)proxy.emit(eventA, AAAAAAA)// output:// all: AAA BBB// tail: AAA BBB// tail: AAAAAAA BBB EventProxy.after EventProxy.after(event, time, listener)listener会在event事件触发time次后执行const EventProxy = require(./node_modules/eventproxy/index)const proxy = new EventProxy()proxy.after(event, 3, (data) = console.log(data) // [AAA, BBB, CCC])proxy.on(event, res = res)proxy.emit(event, AAA)proxy.emit(event, BBB)proxy.emit(event, CCC) EventProxy基本原理 npm - backbonehttps://www.npmjs.com/package/backboneEventProxy来自于BackboneJs的事件模块EventProxy的异常处理手动捕捉每一个异步请求的异常非常麻烦： const EventProxy = require(./node_modules/eventproxy/index)const ep = new EventProxy()ep.all(tpl, data, function (tpl, data) callback(null, template: tpl, data: data ))// 手动绑定异常处理ep.bind(error, function (err) ep.unbind() callback(err))fs.readFile(template.tpl, utf-8, function (err, content) if (err) return ep.emit(error,err) ep.emit(tpl, content))db.get(some sql, function (err, result) if (err) return ep.emit(error, err) ep.emit(data,result)) fail done EventProxy.fail 绑定错误处理函数EventProxy.done 进行异常处理 function callback(err, res) if (err) console.log(err) return console.log(res)const EventProxy = require(./node_modules/eventproxy/index)const ep = new EventProxy()ep.all(eventA, eventB, function (returnA, returnB) callback(null, returnA, returnB ))ep.fail(callback)ep.on(eventA, res = res)ep.on(eventB, res = res)ep.done(eventA)(null, AAA)ep.done(eventB)(eventB-error, BBB) // eventB-errorfailep.fail(callback)等同于ep.fail(function(err) callback(err))等同于ep.bind(error, function(err) ep.unbind() callback(err))donedone方法实际上是对事件触发的一种包装ep.done(eventName)ep.done(event)等同于function (err, content) if(err) return ep.emit(error, err) ep.emit(event, content)ep.done(contentFun)done中也只传一个回调函数，但需要在函数中手动emitep.done((content)= ep.emit(event,content))等同于function(err,content) if(err) return ep.emit(error,err) (function(content) ep.emit(event,content) (content))ep.done(eventName, contentFun)也可以即传入事件名称，又传入回调函数，这里的回调函数主要是用于处理返回值的ep.done(event,function(content) // 对content做一些处理 return content)等同于function(err, content) if(err) return ep.emit(error, err) ep.emit(event,(function(content) // 对content做一些处理 return content )(content)) PromiseDeferred模式在事件订阅模型中，事件执行后的回调函数需要在注册时就明确指定 emitter.emit(event,callback) PromiseDeferred模式可以说是一种先执行异步调用延迟处理的模式，这种模式最早出现在Dojo中： Dojo Tookithttps://dojotoolkit.org/ 异步PromiseDeferred模型 PromisesA对异步操作下了三个抽象定义：Promise操作仅存在3种状态：未完成态完成态失败态Promise状态只存在两种转化过程：未完成态 → 完成态未完成态 → 失败态Promise状态一旦转变，将不能被更改then方法then方法实际做的事就是：将回调函数存放起来then(fulfilledHandler, errorHandler, progressHandler)fullfilledHandler 完成态回调方法errorHandler 错误态回调方法progressHandler progress事件回调方法使用events完成then的简单实现const EventEmitter = require(events).EventEmitterconst Promise = function () EventEmitter.call(this)util.inherits(Promise, EventEmitter)Promise.prototype.then = function (fullfilledHandler, errorHandler, progressHandler) if (typeof fullfilledHandler === function) this.once(success, fullfilledHandler) if (typeof errorHandler === function) this.once(error, errorHandler) if (typeof progressHandler === function) this.once(progress, progressHandler) return this事件都注册之后，如何触发这些事件？Deferred 延迟对象let Deferred = function () this.state = unfilfilled this.promise = new Promise()Deferred.prototype.resolve = function (obj) this.state = fulfilled this.promise.emit(success, obj)Deferred.prototype.reject = function (err) this.state = failed this.promise.emit(error, err)Deferred.prototype.progress = function (data) this.promise.emit(progress, data)响应对象的封装典型响应对象的封装：res.setEncoding(utf8)res.on(data, function (chunk) console.log(BODY: + chunk))res.on(end, function () // Done)res.on(error, function (err) // Error)使用then进行封装：res.then(function () // Done , function (err) // Error, function (chunk) console.log(BODY: + chunk))引入Deferred对象的封装const promisify = function (res) let deferred = new Deferred() let result = res.on(data, function (chunk) result += chunk deferred.progress(chunk) ) res.on(end, function () deferred.resolve(result) ) res.on(error, function (err) deferred.reject(err) ) return deferred.promisepromisify(res).then(function () // Done, function (err) // Error, function (chunk) // progress console.log(BODY: + chunk))Promise DeferredDeferred 用于内部维护异步模型状态封装业务中的不变部分Promise 用于外部通过then方法给外部提供添加自定义逻辑入口控制业务的可变部分Deferred与业务的简化并不是使用Deferred都可以简化业务，因为对于不同的业务场景，都需要封装和改造Deferred，对于不常使用的场景，考虑到封装和改造Deferred花费的时间，并不一定真正简洁划算。Promise与eventPromise高级接口一旦定义，不太容易变化，缺少灵活性方便解决典型问题events低级接口方便构造更加复杂的场景Q modelnpm - Qhttps://www.npmjs.com/package/qconst Q = require(q)const fs = require(fs) const readFile = function (file, encoding) let deferred = Q.defer() fs.readFile(file, encoding, deferred.makeNodeResolver()) return deferred.promisereadFile(hello.txt, utf-8).then(function (data) // success case console.log(data), function (err) // failed case console.log(err))异步编程中异常的判断和处理非常重要，Promise能够实现：正向用例（success）和反向用例（error）的分离逻辑处理延迟（then） Promise的多异步协作 all的简单实现Deferred.prototype.all = function (promises) let count = promises.length let that = this let results = [] promises.forEach(function (promise, i) promise.then(function (data) count-- results[i] = data if (count === 0) that.resolve(resolves) , function (err) that.reject(err) ) ) return this.promiseall的使用let promise1 = readFile(hello.txt, utf-8)let promise2 = readFile(world.txt, utf-8)let deferred = new Deferred()deferred.all([promise1, promise2]).then( res = , err = ) Promise进阶知识 Promise需要根据具体使用场景进行不同的封装，与原生事件相比灵活性低一些，但是更加适用于一些经典场景。前端自动化测试在编写自动化测试时，前端程序员使用JavaScript可以减轻切换环境的麻烦，但是使用Node与远程服务器进行指令发送时，使用到的网络库是完全异步的（而其它语言都是同步调用的），因此在多个异步操作之间存在逻辑关系时，会采用Deferred模式 Pyramid of Doom作为介绍Promise队列操作的铺垫，有必要提一下大名鼎鼎的Pyramid of Doom，即恶魔金字塔。可爱nie~~~为了完成一系列彼此间存在逻辑关系的异步操作，有如下三种地狱模式可供选择：回调地狱函数调用地狱事件触发地狱obj.api1(function (value1) obj.api2(value1, function (value2) obj.api3(value2, function (value3) obj.api4(value3, function (value4) callback(value4) // Pyramid of Doom!!! ) ) ))let handler1 = function (value1) obj.api2(value1, handler2)let handler2 = function (value2) obj.api3(value2, handler3)let handler3 = function (value3) obj.api4(value3, handler4)let handler4 = function (value4) callback(value4)obj.api1(handler1)// 保证你同事看到会口吐芬芳的代码const events = require(events)const emitter = new events.EventEmitter()emitter.on(step1, function () obj.api1(function (value1) emitter.emit(step2, value1) ))emitter.on(step2, function (value1) obj.api2(value1, function (value2) emitter.emit(step3, value2) ))emitter.on(step3, function (value2) obj.api3(value2, function (value3) emitter.emit(step4, value3) ))emitter.on(step4, function (value3) obj.api4(value3, function (value4) callback(value4) ))// 同事：你在这打地鼠呢？emitter.emit(step1)Promise链式调用原理promise() .then(obj.api1) .then(obj.api2) .then(obj.api3) .then(obj.api4) .then(function (value4) // success , function (err) // error ) .done()改造Promise以实现链式调用（两步）：准备好回调队列逐个执行回调，当回调返回新的Promise对象时：新Promise对象继承回调队列Deferred对象更新为新Promise对象constructorresolverejectcallbackthenlet Promise = function() this.queue = [] this.isPromise = truelet Deferred = function() this.promise = new Promise()Deferred.prototype.resolve = function(obj) let promise = this.promise let handler while((handler = promise.queue.shift())) if(handler (handler.fulfilled)) let ret = handler.fulfilled(obj) if(ret ret.isPromise) ret.queue = promise.queue this.promise = ret return Deferred.prototype.reject = function (err) let promise = this.promise let handler while ((handler = promise.queue.shift())) if (handler handler.error) let ret = handler.error(err) if (ret ret.isPromise) ret.queue = queue.queue this.promise = ret return Deferred.prototype.callback = function() const that = this return function(err, file) if(err) return that.reject(err) return that.resolve(file) Promise.prototype.then = function(fulfilledHandler, errorHandler) let hander = if(typeof fulfilledHandler === function) handler.fulfilled = fulfilledHandler if(typeof errorHandler === function) hander.error = errorHandler this.queue.push(handler) return this使用链式调用改造回调地狱案例：obj.api1(value1) .then((value2)= return obj.api2(value2) ) .then((value3)= return obj.api3(value3) ) .then((value4)= callback(value4) ) 批量将方法Promise异步化 这样如果希望能实现依次读取文件的功能，需要对读取文件函数进行异步包装：const fs = require(fs)const Q = require(q)// 异步包装函数function readFile(file, encoding) let defer = Q.defer() fs.readFile(file, encoding, defer.makeNodeResolver()) return defer.promisereadFile(file1.txt, utf-8) .then(res = console.log(res) return readFile(res,utf-8) ) .then(res = console.log(res) )也可以构建能够对任何方法进行异步包装的偏函数：const fs = require(fs)const Q = require(q)// 批量对方法进行Promise化function smooth(method) return function () let deferred = Q.defer() // new Deferred() let args = Array.prototype.slice.call(arguments, 0) args.push(deferred.makeNodeResolver()) //deferred.callback() method.apply(null, args) return deferred.promise const readFile = smooth(fs.readFile)readFile(file1.txt, utf-8) .then(res = console.log(res) return readFile(res,utf-8) ) .then(res = console.log(res) ) 流程控制库除了事件订阅和PromiseDefer模式以外，还有一些尝试用的流程控制库： Connect async Step wind 尾触发与Next 尾触发： 指需要手工调用才能持续执行后续调用的方法next: 尾触发的常见关键词Connect中间件： 尾触发目前应用最多的地方connect - npmhttps://www.npmjs.com/package/connectconst connect = require(connect)const fs = require(fs)let app = connect()app.use(function middleware1(req, res, next) next())app.use(function middleware2(req, res, next) next())请求对象、响应对象、尾触发函数处理流MiddleWare 中间件机制中间件机制在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能，不与业务逻辑产生耦合关联面向切面编程 AOPAOP Aspect Oriented Program简单来说，就是在运行中动态将代码切入到类的指定方法、指定位置，是对OOP编程的一种补充。 connect核心实现connectuselistenhandlenextapp.stack存放服务器内部维护的中间件队列function createServer() function app(req, res) app.handle(req, res) utils.merge(app, proto) utils.merge(app, EventEmitter.prototype) app.route = / app.stack = [] // 中间件队列 for (let i = 0; i arguments.length; ++i) app.use(arguments[i]) return appapp.use用于将中间件放入stack队列app.use = function(route, fn) this.stack.push( route: route, handle: fn ) return thisapp.listen监听函数借助http模块实现const http = require(http)app.listen = function() const server = http.createServer(this) return server.listen.apply(server, arguments)app.handle，每一个监听到的网络请求都从此处开始处理app.handle = function(req, res, out) next()将队列中的中间件取出并执行，随后递归调用、持续触发function next(err) // some code // next callback layer = stack[index++] layer.handle(req, res, next)Connect的流式处理Connect中的尾触发一般用于拆分对网络请求的处理，能够将串行逻辑扁平化const connect = require(connect)const app = connect()app.use(/, function (req, res, next) // step1 next())app.use(/, function (req, res, next) // step2 next())app.use(/, function (req, res, next) // step3 res.end() )http.createServer(app).listen(3000) async npm - asynchttps://www.npmjs.com/package/async流程控制模块async提供用于处理异步的各种协作模式：异步串行执行异步并行执行异步依赖处理自动依赖处理async.series 无依赖的异步串行执行const async = require(async)const fs = require(fs)async.series([ function (callback) fs.readFile(file1.txt,utf-8,(err,data)=callback(null,data)) , function (callback) fs.readFile(file2.txt,utf-8,(err,data)=callback(null,data)) ], function (err, results) if (err) throw err console.log(results) //[file1 context,file2 context])async.series第一个参数事件数组中元素有如下结构：(callback)= // do something callback(result)这里的callback实际上与connect.next类似，用于结束本次执行，开始下次执行，并且其传参是用于将本次执行的结果保存起来的手动实现异步并行执行let counter = 2let results = []let hasErr = falsefunction done(data) counter -= 1 results.push(data) if (counter == 0) callback(null, results) function fail(err) if (!hasErr) hasErr = true callback(err) function callback(err, result) if (err) throw err console.log(result)fs.readFile(file1.txt, utf-8, (err, data) = if (err) fail(err) return done(data))fs.readFile(file2.txt, utf-8, (err, data) = if (err) fail(err) return done(data))EventProxy实现异步并行执行const EventProxy = require(eventproxy)const fs = require(fs)const proxy = new EventProxy()function callback(err, res) if (err) throw err console.log(result,res) proxy.all(content, data, function (content, data) callback(null, [content, data]))proxy.fail(callback)fs.readFile(file1.txt, utf-8, proxy.done(content))fs.readFile(file2.txt, utf-8, proxy.done(data))parallel 异步并行执行async.parallel([ function (callback) fs.readFile(file1.txt,utf-8,callback) , function (callback) fs.readFile(file2.txt,utf-8,callback) ], function (err, res) if (err) throw err console.log(res) // [file1 content,file2 content] )waterfall 结果存在依赖关系的异步串行执行async.waterfall([ function (callback) fs.readFile(file1.txt, utf-8, function (err, content) // err后面的参数代表传递给下一步的参数 callback(err,content) ) , function (arg1, callback) // arg1 = file2.txt fs.readFile(arg1, utf-8, function (err, content) callback(err,content) ) ], function (err, res) if (err) throw err console.log(res) // file content)auto 自动依赖处理对于存在复杂依赖关系的业务环境，auto能够实现：根据依赖关系自动分析，以最佳的顺序执行业务（强！！！）let deps = fun1:callback=callback(), // fun2 依赖 fun3、fun4 fun2:[fun3,fun4,callback=callback()], // fun3 依赖 fun1 fun3:[fun1,callback=callback()], // fun4 依赖 fun1 fun4:[fun4,callback=callback()]async.auto(deps)比如有以下一系列业务需要实现：从磁盘读取配置文件 readConfig根据配置文件连接MongoDB connectMongoDB依赖readConfig根据配置文件连接Redis connectRedis依赖readConfig编译静态文件 complieAsserts上传静态文件到CDN uploadAsserts依赖 compieAsserts启动服务器 startup依赖以上所有EventProxy实现此场景 asap 用于指定一个事件的回调函数尽快执行 assp 指定一组事件的回调函数按照特定顺序执行 const EventProxy = require(eventproxy)const proxy = new EventProxy()proxy.asap(readtheconfig, function () // 读取配置文件 proxy.emit(readConfig)).on(readConfig, function () // 连接数据库 proxy.emit(connectMongoDB)).on(readConfig, function () // 连接Redis proxy.emit(connectRedis)).assp(complieasserts, function () // 编译静态文件 proxy.emit(complieAsserts)).on(complieAsserts, function () // 上传静态文件 proxy.emit(uploadAsserts)).all(connecctMongoDB, connectRedis, uploadAsserts, function () // 启动服务器)生成依赖树如下：async.auto( readConfig: function (callback) // read config file callback() , connectMongoDB: [readConfig, function (callback) // connect to mongodb callback() ], connectRedis: [readConfig, function (callback) // connect to redis callback() ], complieAsserts: function (callback) // complie asserts callback() , uploadAsserts: [complieAsserts, function (callback) // upload to assert callback() ], startup: [ connectMongoDB, connectMongoDB, complieAsserts, uploadAsserts, function (callback) // start up callback() ]) Step 更加轻量级的流程控制库：Tim Caswell 的 Step// step提供的唯一接口用于串行任意数量的任务step(task1,task2,task3)step的this关键字实际上发挥的是next方法的作用const step = require(step)const fs = require(fs)step( function readFile1() fs.readFile(file1.txt,utf-8,(err,data)=this(data)) , function readFile2(param) // param = file2.txt fs.readFile(param,utf-8,this) , function done(err, content) console.log(content) //file content )并行任务执行 parallelparallel： 告诉Step需要等所有任务完成时才能进行下一个任务注意：step只能取到异步方法传回来的前2个参数,此方法的原理在于计数器let asyncCall = function (callback) process.nextTick(function () callback(null,result1,result2) )step( function readFile1() fs.readFile(file1.txt, utf-8, this.parallel()) fs.readFile(file2.txt, utf-8, this.parallel()) asyncCall(this.parallel()) , function done() /** * 0:undefined * 1:file2.txt * 2:file content * 3:result1 */ console.log(arguments) )结果分组 groupgroup 从流程控制上说和parallel很相似，但是会将结果打包成数组传回step( function readDir() fs.readdir(__dirname, this) , function readFiles(err, results) if (err) throw err let group = this.group() results.forEach(filename = if (/\\.txt$/.test(filename)) fs.readFile(__dirname+/+filename,utf-8,group()) ) , function showAll(err, files) if (err) throw err console.dir(files) //[ file2.txt, file content, file3 content ] )为什么要调用两次group？第一次调用：告知step要并行执行let group = this.group()第二次调用：用于生成回调函数接受返回值按组存储fs.readFile(__dirname+/+filename,utf-8,group()) wind Monadic 单子monadic，是一种用于处理具有副作用的计算，如IO操作、异常处理和状态管理等。 wind算是对JavaScript实现的一种Monadic扩展，为了说明wind的具体使用场景，我们先提出一个比较特殊的需求：实现冒泡排序的动画冒泡排序代码如下：function swap(a, i, j) let t = a[i] a[i] = a[j] a[j] = tfunction compare(a, b) return (a-b) 0function bubbleSort(array) for (let i = 0; i array.length; i++) for (let j = 0; j array.length-i-1; j++) if (compare(array[j], array[j + 1])) swap(array,j,j+1) return array如果需要添加动画效果的话，只要在swap函数中添加就可以，但是动画效果存在延时，在延时时段中动画还没有执行完，数组中的数据就又开始变化了，因此该如何让动画执行完之后再进行下一次的数据交换呢？需要达成的效果同样需要通过延时实现的动画效果使用yield实现sleep也可以使用ES6中的yield实现流程控制，在每次冒泡交换之后添加yield阻塞流程，转而花费n秒控制动画延时，动画执行结束，再手动调用生成器函数的next方法。 核心代码如下： function * bubbleSort(array) for(let i=0;iarray.length;i++) for(let j=0;jarray.length-i-1;j++) if(compare(array[j],array[j+1])) swap(array,j,j+1) yield stop //交换后阻塞 function next(gen) // 需要迭代调用进行流程控制 let n = gen.next() if(n.done) return paint().then(()=next(gen)) //异步绘制后再次调用next通过下一次yieldlet gen = bubbleSort(arr)next(gen) 使用wind实现此功能代码如下：const Wind = require(wind)// swap进行异步包装let swapAsync = eval(Wind.compile(async, function swap(a, i, j) $await(Wind.Async.sleep(500)) // 暂停500s var t = a[i] a[i] = a[j] a[j] = t console.log(repaint) //重绘))function compare(a, b) return (a - b) 0let bubbleSort = eval(Wind.compile(async, function (array) for(var i = 0;iarray.length;i++) for(var j = 0; j array.length - i -1;j++) if(compare(array[j],array[j+1])) $await(swapAsync(array,j,j+1)) ))bubbleSort([7,-3,10,-1,0,99]).start()输出结果wind的特异之处异步任务定义$await()与任务模型异步方法转换辅助函数Wind.compile()对普通函数进行编译，再交给 eval() 执行定义异步任务eval(Wind.compile(async,function()))内置对setTimeout()的封装Wind.Async.sleep()$await(asyncFun())$await 实际是一个等待的 占位符，表示等待完成异步方法任务模型每一个异步操作都可以转换为一个任务，这也就是wind基于的任务模型。正式的任务创建方法：Task.create()complete()const Wind = require(wind)const Task = Wind.Async.Taskconst fs = require(fs)// 任务包装let readFileAsync = function (file, encoding) return Task.create(function (t) fs.readFile(file, encoding, function (err, file) if (err) t.complete(failure, err) else t.complete(success, file) ) )// 异步执行let serial = eval(Wind.compile(async, function () var file1 = $await(readFileAsync(file1.txt, utf-8)) console.log(file1) var file2 = $await(readFileAsync(file2.txt, utf-8)) console.log(file2) try var file3 = $await(readFileAsync(file4.txt,utf-8)) catch (err) console.log(err) ))// file1 content// file2 content// Errorserial().start()异步并行直接使用 $await(asyncTask()) 的方式能实现异步任务串行执行，实现了不阻塞CPU阻塞代码的目的Wind实现异步任务并行执行：Task.whenAlllet parallel = eval(Wind.compile(async, function () var results = $await(Task.whenAll( file1: readFileAsync(file1.txt, utf-8), file2: readFileAsync(file2.txt,utf-8) )) console.log(results)))// file1: file2.txt, file2: file content parallel().start()let series = eval(Wind.compile(async,function() // ... $await(asyncTask()) // to do))可以看到引入wind之后，异步函数实际上已经和同步调用十分近似了因此很适合用于从已有的同步代码向Node端迁移wind提供了两个辅助方法：Wind.Async.Binding.fromCallbackWind.Async.Binding.fromStandardfromCallback 转换无异常的调用 无异常的调用通常只有一个参数返回：fs.exists(/etc/passwd,function(exists) // exists表示指定路径文件是否存在)// 异步包装let existsAsync = Wind.Async.Binding.fromStandard(fs.exists)fromStandard 转换带异常的调用带异常的调用的第一个参数作为异常标识fs.readFile(file1.txt,function(err,data) // err表示异常)let readFileAsync = Wind.Async.Binding.fromStandard(fs.readFile) 小结方案对比 事件发布订阅模式比较原始PromiseDeferred模式对异步任务模型进行抽象重点在于封装异步的调用流程控制库自由度较高重点在于回调函数的注入源码编译方案streamline 异步并发控制所谓异步并发性能的关键可以总结为这样一个问题： 怎样发起异步并发，能够实现既充分压榨底层系统的性能，同时给予其一定过载保护，防止过犹不及？ 泪目，资本家竟是我自己 如果不对并发量作限制的话，连续大量的并发请求会迅速用光下层服务器的资源，针对并发量的限制问题，这里给出了两个解决方案： bagpipe async.parallelLimit async.queue bagpipe解决方案bagpipe解决思路 let allTaskList = [] // 调用缓存队列let activeTaskList = [] // 活跃（调用发起但并未执行回调）的异步调用let limitNumber = 100 // 并发限定量function parallelControl() // 如果还有多余的任务名额，取出执行 if(allTaskList.length activeTaskList.lengthlimitNumber) let task = allTaskList.shift() activeTaskList.push(task) task.then((res)= activeTaskList.del(task) //销毁 parallelControl() // 下一次取出 ) else parallelControl() 实际使用到两个bagpipe的API： push方法 full事件 const Bagpipe = require(bagpipe)const fs = require(fs)let bagpipe = new Bagpipe(3)bagpipe.on(full,function(length) console.log(`query block：[$length]`))for(let i = 0; i5; i++) bagpipe.push(fs.readFile,file1.txt,utf-8,function(err,data)) bagpipe的配置 disabled 限流开关refuse拒绝模式针对对实时性要求高的场景限流分批发起请求可能导致一部分请求必须等待一段时间，无法满足丢时间要求较高的数据请求并行队列一旦阻塞就返回失败报错timeout用于防止执行过慢的请求长时间占用并发名额 async的解决方案async.parallelLimit const async = require(async)const fs = require(fs)async.parallelLimit([ function (callback) fs.readFile(file1.txt,utf-8,callback) , function (callback) fs.readFile(file2.txt,utf-8,callback) ], 1, function (err, results) if (err) throw err //[ file2.txt, file content ] console.log(results))async.parallelLimit( [], //异步并发任务队列 limit, //并发数 callback) async.queue async.parallelLimit无法动态增加并行任务，但是async.queue支持此需求：let q = async.queue(function (file, callback) fs.readFile(file,utf-8,callback), 2)q.drain = function () // done listfs.readdirSync(.).forEach(function (file) q.push(file, function (err, data) ))"},{"title":"Python基础语法","path":"/wiki/Python/base_01_hello_01.html","content":"Python变量变量定义与赋值 同时对多个变量赋值# a = 1# b = 2a, b = 1, 2 变量删除 可以使用del删除已经定义的变量del value_name, value_name_2 Python数据类型 数字 Numbers 整型 int 浮点型 float 布尔型 bool 复数型 complex 字符串 String 列表 List 元组 Tuple 集合 Sets 字典 Dictionaries 序列sequence的内置函数 python3中有以下几种seq类型的变量listtuplesetdictseq数据类型提供了以下内置函数：lenmaxminliststrsumsortedreversedenumerate 变量检测函数 type ### Numbersprint(type(1)) # class intprint(type(1.1)) # class floatprint(type(True)) # class boolprint(type(3+4j)) # class complex### Stringprint(type(1213)) # class str### Listprint(type([1, 2, 3])) # class list### Tupleprint(type((1,2,3))) # class tuple### Setsprint(type(1, 2, 3)) # class set### Dictionariesprint(type(1: 2, 3: 4)) # class dict 类检测 isinstance print(isinstance(1, int)) # Trueisinstance 和 type 的区别在判定子类与其继承的父类的关系时会体现出来：class Parent: passclass Children(Parent): pass typeprint(type(Children()) == Children) # Trueprint(type(Children()) == Parent) # False isinstanceprint(isinstance(Children(), Parent)) # True Numberpython的除法 python中存在两种除法：print(5/2) # 2.5print(5//2) # 2ab 除法，返回float类型数值ab整除，返回int类型数值 数字类型转换 int(x)float(x)complex(x)complex(x, y)x: 实数部分y: 虚数部分 String前缀 在字符串前加r前缀，能够使转义字符无效化print(abc\\tdef) # abc defprint(rabc def) # abc def 续行 使用 “””…””” 或 ‘’’…’’’ 表示续行print( div pHello World/p /div)print( div pHello World/p /div) 索引 正向索引从左向右从0开始递增负向索引从右向左从-1开始递减string = 123456789print(string[0]) # 1print(string[-1]) # 9 切片 string[[start_index] : [end_index]]string = 123456789print(string[1:5]) # 2345print(string[:]) # 123456789print(string[:5]) # 12345print(string[5:]) # 6789print(string[-5:-1]) # 5678 字符串不能通过索引值引用的方式改变 子串 str = Hello Worldprint(ll in str) # Trueprint(m in str) # False 格式化 字符串格式化和CC++的printf方法类似# Its 18 oclock, lets go off workprint(Its %d oclock, lets %s % (18, go off work))f-string与JavaScript的模板字符串类似time, event = 18, get off work# its 18 oclock, lets get off workprint(fits time oclock, lets event) List列表运算 列表加法list_A = [1,2,3,4,5]list_B = [2,3,4,5,6]print(list_A+list_B) # [1, 2, 3, 4, 5, 2, 3, 4, 5, 6]列表乘法list_A = [1,2,3]print(list_A*2) # [1, 2, 3, 1, 2, 3]乘法也能用于初始化指定长度的列表：print([None]*5) # [None, None, None, None, None] 切片 List可以通过切片进行增删改查操作增删改查arr = list(123456789)arr[0:0] = [m, n]print(arr) # [m, n, 1, 2, 3, 4, 5, 6, 7, 8, 9]arr = list(123456789)arr[2:3] = []print(arr) # [1, 2, 4, 5, 6, 7, 8, 9]arr = list(123456789)arr[0:2] = [m, n]print(arr) # [m, n, 22, 3, 4, 5, 6, 7, 8, 9]arr = list(123456789)print(arr[2:3]) # [3] List内建函数 添加删除查询appendextendinsertlist_A = []list_A.append(1)print(list_A) # [1]list_A.insert(0, 2)print(list_A) # [2, 1]list_A.extend([3,4])print(list_A) # [2, 1, 3, 4]popremoveclearlist_A = [1,2,3,4,3,5]list_A.pop()print(list_A) # [1,2,3,4,3]list_A.remove(3)print(list_A) # [1,2,4,3]list_A.clear()print(list_A) #[]countindexlist_A = [1,2,3,4,3,5]print(list_A.count(3)) # 2print(list_A.index(3)) # 2 堆栈队列append 入栈pop 出栈from collections import dequequeue = deque([1, 2, 3])queue.append(4)queue.append(5)print(queue.popleft()) # 1print(queue.popleft()) # 2print(queue) # deque([3, 4, 5]) 列表推导式 [expression(x) for x in seq]vec = [2, 4, 6]str_arr = [key1:value1, key2:value2, key3:value3]print([3*x for x in vec]) # [6, 12, 18]print([[x,x**2,x**3] for x in vec]) # [[2, 4, 8], [4, 16, 64], [6, 36, 216]]print(dict(str.split(:) for str in str_arr)) # key1: value1, key2: value2, key3: value3加入if过滤[expression(x) for x in seq if expression(x)]vec = [2, 4, 6]str_arr = [key1:value1, key2:value2, key3:value3]print([3*x for x in vec if x != 4]) # [6, 18]print(dict(str.split(:) for str in str_arr if 1 not in str)) # key2: value2, key3: value3嵌套循环[expression(n_1, n_2, …) for n_1 in arr_1 for n_2 in arr_2 …]vec1 = [1,-1,2,-2,3,-3]vec2 = [3,-3,4,-4,5,-5]print([x*y for x in vec1 if x0 for y in vec2 if y 0]) 嵌套列表解析 matrix_m_n = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]matrix_n_m = [[row[i] for row in matrix_m_n] for i in range(len(matrix_m_n[0]))]print(matrix_n_m) # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 切片删除 del list[start:end]arr = [1,2,3,4,5]del arr[1:2]print(arr) # [1, 3, 4, 5] zip 根据索引同时访问多个序列 Tuple创建规则 元组元素无法修改，当元组中只有一个元素时，需要在唯一元素后加一个逗号，否则会被当做括号运算符tup1 = ()tup2 = (2,)tup3 = (2)print(tup1) # ()print(tup2) # (2,)print(tup3) # 2甚至可以不加括号的创建元祖：t = 123, hello, True, (abc, False)print(t) # (123, hello, True, (abc, False))Tuple支持加法拼接：tup_1 = (1,)tup_2 = (2,)print(tup_1 + tup_2) # (1, 2) 元组的比较：operator operator是专门用来实现数据比较功能的模块import operatortup_1 = (1, 2)tup_2 = (2, 1)tup_3 = (2, 1)print(operator.eq(tup_1, tup_2)) # Falseprint(operator.eq(tup_2, tup_3)) # True Sets空字典和空集合 创建空集合需要使用set，方便和空字典区分开：blank_set = set()blank_dict = 集合运算 set_A = 1, 2, 3, 4, 5, 4, 3, 2, 1set_B = 4, 5, 6, 7, 8, 6, 5, 4# 差集print(set_A - set_B) # 1, 2, 3# 并集print(set_A | set_B) # 1, 2, 3, 4, 5, 6, 7, 8# 交集print(set_A set_B) # 4, 5# 异或print(set_A ^ set_B) # 1, 2, 3, 6, 7, 8 Set内置方法 添加删除查询add 添加单个update 保留并集添加元素discard和remove的区别discard 移除不存在的集合元素时不会报错remove 移除不存在的集合元素时会报错clear 清除所有difference_update 移除差集intersection_update 保留交集symmetric_difference_update 保留异或集pop 随机删除discard 删除指定remove 删除指定difference 差集intersection 交集symmetric_difference 异或集union 并集isdisjoint 是否存在交集issubset 判断子集 Dictionaries构建字典 dict的key只能是不可改变类型的数据numberstring方式1 {}方式2 dict方式3 tuple方式4 list方式5 set方式6 推导式dict_A = 1: 123, a: 321dict_A = dict(a=1, b=2, c=3)print(dict_A) # a: 1, b: 2, c: 3tup = ( (a, 1), (b, 2), (c, 3))print(dict(tup)) # a: 1, b: 2, c: 3dict_list = [ [a, 1], [b, 2], [c, 3]]print(dict(dict_list)) # a: 1, b: 2, c: 3set_dict = [ a, 1, b, 2, c, 3]print(dict(set_dict)) # a: 1, b: 2, 3: cset是无序集合，因此创建出来的字典键值关系随机组合for_dict = x: y**2 for x, y in [[a, 1], [b, 2], [c, 3]]print(for_dict) # a: 1, b: 4, c: 9成员测试dict_list = [ [a, 1], [b, 2], [c, 3]]new_dict = dict(dict_list)print(a in new_dict) # Trueprint(1 in new_dict) # False Dict 内置方法 快速创建新字典dict.fromkeys(seq[, value])new_dict = dict.fromkeys([a, b, c], 123)print(new_dict) # a: 123, b: 123, c: 123获取指定键值dict.get(key[, default=None])new_dict = a: 1, b: 2, c: 3print(new_dict.get(a, 123)) # 1print(new_dict.get(e, 123)) # 123属性获取+判断+赋值dict.setdefault(key[, default=None])new_dict = a: 1, b: 2, c: 3print(new_dict.setdefault(a, 123)) # 1print(new_dict.setdefault(e, 123)) # 123print(new_dict) # a: 1, b: 2, c: 3, e: 123字典更新target_dict.update(source_dict)dict_A = a: 1, b: 2, c: 3dict_B = a:111, e:123dict_A.update(dict_B)print(dict_A) # a: 111, b: 2, c: 3, e: 123 运算符对于一些简单通用运算符，python和其他语言的差别不大： 算术运算符 比较运算符 赋值运算符 位运算符 逻辑运算符 and or not 成员运算符 in not in 身份运算符 is is not 成员运算符 new_list = [x for x in [1, 2, 3]]new_set = x for x in [1, 2, 3]new_tuple = (1, 2, 3)new_dict = x: x + 1 for x in [1, 2, 3]print(1 in new_list) # Trueprint(1 in new_set) # Trueprint(1 in new_tuple) # Trueprint(1 in new_dict) # True 身份运算符 (A is B) = (id(A) == id(B)) 循环for-inrange()函数 range(start, end, step)利用range控制循环次数num_list = list(0123456789)for i in range(0, len(num_list), 3): print(i) # 0 3 6 9利用range创建数字序列print(list(range(0, 10, 3))) # [0, 3, 6, 9]print(tuple(range(0, 10, 3))) # (0, 3, 6, 9)print(set(range(0, 10, 3))) # 0, 9, 3, 6 for-inwhile + elsefor-in-else 进入else的条件：穷尽列表循环没有被break终止for n in range(2,10): for m in range(2,n): if n%m == 0: print(n, equals, m, *, n//m) break else: print(n, is a prime number) while-else 进入else的条件：while条件为False循环没有被break终止n = 2while n10: m = 2 while mn: if n%m == 0: print(fn = m * n//m) break m+=1 else: print(fn is prime number) n+=1 迭代器生成器迭代器 iter 可用于创建迭代器的数据类型：StringListTupleSetDict迭代器的两个主要函数：iter() 创建迭代器next(iter) 访问下一个元素it_list = iter(list(123))while True: try: print(next(it_list)) except: break 生成器 generator 使用了yield的函数被称为generator函数，每次运行到yield语句时，都将返回yield后的值，在执行next()时触发生成器的执行def fibonacci(n): a, b, counter = 0, 1, 0 while counter = n: counter += 1 yield a a, b = b, a + b returnit = fibonacci(10)print(list(it)) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 函数关键字参数 def printinfo(name, age=35): print(name, age) returnprintinfo(age=20, name=a) # a 20 缺省参数 def printinfo(name, age=35): print(name, age) returnprintinfo(name=a) # a 35printinfo(name=b , age=20) # b 20 可变参数 def fun(*args) args以Tuple类型传入def fun(**args)args以Dict类型传入可变Tuple参数 *arg推荐写法： 可变参数放最后def printinfo(arg1, *args): print(arg1, args)printinfo(abc, 1, 2, 3) # abc (1, 2, 3)printinfo(abc) # abc ()可变参数写在前， 固定参数需使用关键字参数传入def printinfo(*args, arg1=123): print(args, arg1)printinfo(1, 2, 3, arg1=1) # (1, 2, 3) 1printinfo(arg1=1) # () 1printinfo(1, 2, 3) # (1, 2, 3) 123可变Dict参数 **argsdef printinfo(**args): print(args)# a: 1, b: 2, c: 3printinfo(a = 1, b = 2, c = 3) 匿名函数 lambda lambda 只是一个表达式lambda 无法访问自有参数以外的任何参数lambda [args, [args2,....argn]]: expressionarr_add1 = lambda arg: int(arg)+1arr = list(123)print(list(map(arr_add1, arr))) # [2, 3, 4]"},{"title":"模块、I/O、异常、面向对象","path":"/wiki/Python/base_02_hello_02.html","content":"模块import语句python的搜索路径 import语句执行之后，python解释器会按照搜索路径来搜索对应模块，搜索路径由一系列目录名组成import sysprint(sys.path)[‘D:\\CS_Demo\\后端\\Python Demo\\2023_python_demo’,‘D:\\CS_Demo\\后端\\Python Demo\\2023_python_demo’,‘D:\\PyCharm\\PyCharm 2020.3.3\\plugins\\python\\helpers\\pycharm_display’,‘D:\\python\\python39.zip’,‘D:\\python\\DLLs’,‘D:\\python\\lib’,‘D:\\python’,‘D:\\python\\lib\\site-packages’,‘D:\\PyCharm\\PyCharm 2020.3.3\\plugins\\python\\helpers\\pycharm_matplotlib_backend’]搜索路径是何时被确定的？答： 在Python编译或安装的时候被确定的也可以通过定义环境变量的方式来确定搜索路径 因此，可以通过手动添加sys.path修改搜索路径 name 当A模块引用B模块内变量或方法时，B模块中会运行的代码不仅仅只有被引用的部分，事实上，B模块的整个主程序都将运行如何分辨程序是自身执行还是引用执行呢？答： nameif __name__ == __main__: print(自身运行)else: print(引用运行) 调用模块内的所有可引用方法 dir(model) 获取模块内定义的所有名称的字符串列表getattr(obj, str) 根据字符串名称str获取obj中的某个属性obj.strfor fun in [i for i in dir(model) if not i.startswith(__)]: getattr(model, fun)() 包包 目录只有在包含**init.py**文件时才会被认作是一个包：root_package init.py package_A init.py AAA.py BBB.py … package_B init.py CCC.py DDD.py …使用点模块名称获取某个包内的模块时，如：A.B.C，访问到的每一层包结构都会调用其中的**init.py** IOoutput字符串转换 str 返回用户易读的表达形式s = hello world hello worldprint(str(s))repr 返回解释器易读的表达形式s = hello worldprint(repr(s)) # hello world 字符串格式化 固定长度以下三个方法全是用于创建指定len长度字符串的，但是在源字符串长度小于目标长度时，填充的方法不同：rjust(len) 向字符串左侧填充空格ljust(len)向字符串右侧填充空格center(len)像字符串两侧填充空格格式化 format仅占位 {}index1: index2: index3:.format(index1,index2,index3)指定索引 {index}print(index2:1 index3:2 index1:0.format(1, 2, 3))指定关键字 {keyword}print(key2 key1 key3.format(key1=dog,key2=you,key3=!!!))指定索引和格式 {index:format}print(0:2d 1:3d 2:4d.format(10, 10**2, 10**3))print(Math.pi = 0:0.2f.format(math.pi))格式化之前进行附加操作 {!a|!s|!r}!a ascii()!s str()!r repr()print(!a !s !r.format(index1, index2, index3))传入字典team = John:Doctor, Nancy:Fighter print(John is our 0[John]:10, and Nancy is our 0[Nancy]:10.format(team))使用参数解构的方式同样也能实现传入字典的功能team = John:Doctor, Nancy:Fighterprint(John is our John:10, and Nancy is our Nancy:10.format(**team))zfill() 字符串左侧填充0print(0.1.zfill(5)) # 000.1 文件读写文件 open(filename, mode)mode有如下几种选项：r 默认值，只读w 写a 追加r+ 读写 文件操作方法 read(size) 读取size长度的字符串字节对象readline() 读取一行readlines() 读取所有行next() 读取文件下一行truncate([size]) 截取文件write(string) 写入文件 string 需要写的内容return 写入的字符串长度writelines(sequence) 写入一个序列字符串列表tell() 文件对象所处索引位置seek(offset, from_what) 移动文件对象索引位置from_what 0 从首行首字开始移动from_what 1 从当前位置往后移动from_what 2 从结尾往前移动-offset个字符close() 关闭释放文件资源flush() 刷新文件内部缓冲fileno() 返回整型文件描述符用于底层操作isatty() 文件是否连接到一个终端设备一个根据目录文件引入指定模块的功能：import importlibrequire = open(static/require.txt, r)while True: try: model_name = require.readline() if not model_name: print(文件读取结束) break model_name = str(model_name).replace( , ) model_path = fstatic.model_name globals()[model_name] = importlib.import_module(model_path) except: print(文件读取错误)require.close() pickle模块pickle功能 序列化程序对象 → 文件程序对象存储到文件pickle.dump(obj, file, [,protocol])反序列化文件 → 程序对象使用文件内容创建程序对象x = pickle.load(file) 序列化import pickledata1 = a:[1, 2.0, 3, 4+6j], b:string, uUnicode string, c:Noneselfref_list = [1, 2, 3]selfref_list.append(selfref_list)output = open(static/data.pk1, wb)pickle.dump(data1, output)pickle.dump(selfref_list, output, -1)output.close() 反序列化import pprint, picklepkl_file = open(static/data.pk1, rb)data1 = pickle.load(pkl_file)pprint.pprint(data1)data2 = pickle.load(pkl_file)pprint.pprint(data2)pkl_file.close() 异常异常捕获 try: ....except 错误类型: .....不写就是捕获全部错误：except:一次捕获多个错误：except (TypeError, NameError, ...):捕获同时生成错误信息：except TypeError as error:分类捕获：except TypeError: passexcept NameError: passexcept: passtry-except-else:try: ...except: ...else: # 只有当try下的代码没有异常抛出时才会运行 异常抛出 raise ErrorTraceback (most recent call last): File XXXXXXXXXXXX, line 1, in module raise NameError(its not a error, i just like my console be red)NameError: its not a error, i just like my console be redraise NameError(its not a error, i just like my console be red) 自定义异常 异常类需要继承自Exception类class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value)try: raise MyError(must be a masochism who wrote this error for himself)except MyError as e: # must be a masochism who wrote this error for himself print(e.value) 当某个模块可能抛出多种异常错误时，一般为这个包建立一个基础异常类，基于此类创建不同的子类class Error(Exception): def __str__(self): return repr(self.message)class InputError(Error): def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 清理行为 try: print(执行入口) raise NameError(name error)except NameError: print(有异常时执行)else: print(没有异常时执行)finally: print(有没有异常都执行) 预定义的清理行为 f = open(xxx,wb)# 开始进行文件操作f.close()当上面文件操作过程中出现错误时，程序会直接退出，无法保证close方法的执行 标准清理行为python中一些对象定义了标准的清理行为，一旦系统不需要它，标准清理行为就会执行如何保证标准清理行为被正确调用？答： 使用关键词with语句with语句保证定义了标准清理方法的对象在使用完后指定会正确执行清理方法with open(XXX) as f: # 其他操作 面向对象类的方法 类方法的第一个参数必须是selfself就是实例自身实例化方法私有方法专有方法init类在实例化操作时会自动调**init**方法进行初始化操作def __方法名(params):只能在类内调用的方法重写专有方法能实现运算符重载class Dog: def __init__(self): self.count = 1 # 加法运算符重载 def __add__(self, other): self.count+=other.count print(fdog number: self.count) return selfdog = Dog()dog += Dog() # dog number: 2dog += Dog() # dog number: 3dog += Dog() # dog number: 4 多继承 class DerivedClassName(Base1, Base2, ...): pass当多继承的类调用一个属性或方法时，会按照如下顺序对属性进行查找：子类自身中查找继承参数从左到右进行查找"},{"title":"Flask Start","path":"/wiki/Python/flask_01_start.html","content":"Flask中文文档https://dormousehole.readthedocs.io/en/latest/#api 此教程内容涉及内容很浅，仅为快速上手Flask提供关键注意要点 项目配置（针对Pycharm） 开启debug 热更新模式 edit configurations FLASK_DEBUG on修改flask项目运行的host edit configurations Additional options –host0.0.0.0修改flask项目运行的port edit configurations Additional options –host0.0.0.0 –port8060关于flask：debug模式的开启方式一app.run(debug=True)方式二 配置系统环境变量为flask开发模式配置系统换环境变量，打开flask调试模式import osos.environ[FLASK_ENV] = developmentos.environ[FLASK_DEBUG] = 1 URL与视图的映射url的组成 http://127.0.0.1:5000/abc/url一般由三部分组成：协议 如http(80)https(443)访问域名时，下面两种方式的含义相同：127.0.0.1:80http://127.0.0.1ip域名路由 初始化文件 from flask import Flask, request, render_templatefrom datetime import datetime# __name__表示当前模块名 app为中心调用对象app = Flask(__name__)@app.route(/)def hello_world(): return hello # 排除引用触发运行的情况if __name__ == __main__: app.run() 路由映射配置 @app.route(/path) # 路由配置def path_mapping(): # 映射函数 return render content # 返回渲染内容在访问装饰器配置的路由时，会执行下方的函数，函数返回值就是渲染内容 template flask的template引入是通过Jinjia模板引擎的Jinjia官方文档https://jinja.palletsprojects.com/en/3.1.x/仅需要在flask项目下的 templates 文件夹中加入对应html模板，然后在路由映射函数的返回值中使用flask.render_template(‘指定模板.html’) route+template实例演示路由传参 带参数url限定参数类型默认参数类型定义时使用 包裹变量名称，在映射函数的参数中加入对应变量名称，在映射函数被调用时，传入变量值，参数会通过url传入@app.route(/user/id)def user(id): return fWelcome, user id参数类型:参数名称@app.route(/page/int:page_num)def page(page_num): return fpage page_num通过 path?key1value1?key2value2 的格式传递的参数都存储在 request.args 中request 需要从 flask 内引入@app.route(/list/)def list(): page = request.args.get(page, 1) return flist page： page 模板 渲染模板渲染+传参传入可变类型参数需要从flask中引入render_template方法 !--template/index.html--h1Jinjia2 template/h1@app.route(/path)def get_path_template(): return render_template(index.html)render_template(url[,**args])index.htmlh1title/h1pcontent/p路由配置@app.route(/path/title/content)def path_render(title, content): return render_template(index.html, title=title, content=content)index.htmlbody user.name / user.email /body路由配置# 类定义class User: def __init__(self, **args): self.name = args[name] self.email = args[email]@app.route(/path)def path_render(): user = User( name=request.args.get(name, default name), email=request.args.get(email, 123456@default.com) ) # 可变参数也通过关键字指定方式传参 return render_template(index.html, user=user) jinjia语法 自定义过滤器控制语句模板继承加载静态资源过滤器语法h1 变量名|指定过滤器 /h1jinjia过滤器部分文档https://jinja.palletsprojects.com/en/3.1.x/templates/#list-of-builtin-filtersjinjia提供了如下这些过滤器：jinjia提供的过滤器自定义过滤器需要用到add_template_filter方法# filter_fun 过滤器方法，入参为被过滤的值，返回过滤后值# filter_name 过滤器名称app.add_template_filter(filter_fun, filter_name)下面提供的是一个对datetime类型数据进行格式化的自定义过滤器：index.htmlbody mytime|dformat /body路径映射# 1 定义过滤器def data_format(time, format=%Y-%m-%d): return time.strftime(format)# 2 绑定过滤器到appapp.add_template_filter(data_format, dformat)# 3 路由映射中使用@app.route(/path)def path_render(): mytime = datatime.now() return render_template(index.html, mytime=mytime)jinjia模板中提供两种基本的流程控制语句：if-else% if exp_A % ...% elif exp_B % ...% else exp_C % ...% endif % for-in% for i in arr %...% endfor %用法类似于slot插槽父模块里加入命名插槽：父模块中定义插槽% block 插槽名 %% endblock %子模块中使用插槽名定位插槽插入子模块中接入插槽% extends 父模块.html %% block 插槽名 %...% endblock %需要用到url_for方法jinjia模板通过url_for获取静态文件的默认地址在template同级目录下的static文件夹中有如下目录结构：staticcssindex.cssimgtoby_dog.jpgjsmain.jstemplatesstatic.htmlurl_for方法的作用是：根据视图函数的名称生成url# static表示路径static# filename表示文件路径url_for(static, filename)html lang=enhead meta charset=UTF-8 titleTitle/title link rel=stylesheet href=url_for(static, filename=css/index.css) script src=url_for(static, filename=js/main.js)/script/headbodyimg src=url_for(static, filename=img/toby_dog.jpg) alt=/body/html"},{"title":"Flask Project","path":"/wiki/Python/flask_03_project.html","content":"项目结构 blueprintviews 存放各个路由映射模块 static 存放静态文件 templates 存放jinjia模板 config 存放配置文件信息 config.py app配置信息 db_config.py 数据库配置信息 app.py 入口文件 decorator.py 装饰器文件 exts.py 扩展文件 models.py ORM文件 功能简述 用户注册后生成账号 登录账号 参与心理测试 心理测试结果发送到用户邮箱 数据库数据库配置数据库配置 将config信息单独提取到config文件下进行配置：config/config.py app配置SECRET_KEY = oh its secrect key # flask.session需要用到的密钥config/db_config.py 数据库配置HOSTNAME = 127.0.0.1PORT = 3306USERNAME = rootPASSWORD = root123DATABASE = psychological_testSQLALCHEMY_DATABASE_URL = fmysql+pymysql://USERNAME@HOSTNAME:PORT/DATABASE?charset=utf8mb4app.py 配置信息注入from config import db_config, configapp.config.from_object(db_config) # 数据库配置app.config.from_object(config) # app配置 exts.js如果我们把db的创建放在app文件中，如下代码： app.pydb = SQLAlchemy()db.init_app(app)migrate = Migrate(app, db) 同时，如果想migrate在进行数据迁移时注意到ORM模型的更新，就必须要在app.py中引用模型类： app.pyfrom models import UserModel, EmailModel, TestModel, OptionModel, ResultModel 在models.py中，为了使ORM模型继承db.Model类，也必须将db引入： app.pyfrom app import dbclass UserModel(db.Model): pass 这时，引用循环的问题就出现了: ImportError: cannot import name XXX from partially initialized module XXX (most likely due to a circular import) db的更新与从models中引用来的模型相关，而models中的模型又与db的Model类相关，此处需要引入扩展文件exts.py，专门用于创建一些app需要用到的扩展对象exts.pyfrom flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() ORM映射ORM UserModelTestModelResultModelEmailModelOptionModel Blueprint视图拆分Blueprint蓝图 color Blueprint可以为路由、视图、静态文件等需要url映射的功能提供便捷的模块拆分方法在blueprint文件夹下创建视图模块文件：blueprint/index.pyfrom flask import Blueprintindex = Blueprint(index, __name__, url_prefix=)@index.route(/)def welcome(): return blueprint文件下的蓝图对象需要在app中注册app.pyfrom blueprint.index import indexapp.register_blueprint(index) wtforms 表单验证wtforms主要用于验证前端提交的数据是否符合规范flask-wtf是flask对wtforms的封装 wtforms的使用步骤如下：定义表单注意表单项name字段要和验证类中的验证属性名对应定义验证类一定要继承自wtforms.Form类验证属性验证方法需要用validate_验证属性名的格式为方法命名方法必须包含self和field两个参数，用field访问获取验证属性值，用self访问其他字段使用验证类表单定义form action= method=post div class=form-item pLIAME/p input type=text name=email /div div class=form-item pEMAN/p input type=text name=name /div div class=form-item pNOITATNACNI/p input type=password name=password /div input type=submit value=TCEJNI NOITATNACNI/formwtforms类定义import wtformsfrom wtforms.validators import Email, Lengthfrom models import UserModelclass RegisterForm(wtforms.Form): email = wtforms.StringField(validators=[Email(message=strange, something seems going wrong)]) name = wtforms.StringField(validators=[Length(min=1,max=20,message=strange, something seems going wrong)]) password = wtforms.StringField(validators=[Length(min=4,max=20,message=strange, something seems going wrong)]) def validate_emial(self, field): email = field.data user = UserModel.query.filter_by(email=email).first() if user: raise wtforms.ValidationError(message=strange, something seems going wrong)使用验证类from .forms import RegisterForm@index.route(/register, methods=[POST, GET])def register(): if request.method == POST: form = RegisterForm(request.form) if form.validate(): ... return ... else: print(form.errors) return ... werkzeugWSGL WSGL Web Server Gateway InterfaceWSGL是Python Web应用程序和Web服务器之间的标准接口Werkzeug是python提供的WSGL库 使用werkzeug.security进行数据加密 generate_password_hash 加密check_password_hash 比较加密数据和未加密数据是否包含相同信息加密from werkzeug.security import generate_password_hash, check_password_hashdef register(): .... password = generate_password_hash(form.password.data) user = UserMode( name=form.name.data, email=form.email.data, password=password ) 比较@index.route(/login, methods=[POST, GET])def login(): ... user = UserModel.query.filter_by(email=form[email]).first() if user and check_password_hash(user.password, form[password]): session[user_id] = user.id return ... 钩子函数Flask中的钩子函数使用装饰器的形式定义 一些常用的钩子函数 before_request 请求之前、视图函数执行之前after_request 请求之后、响应发送给用户之前调用teardown_request 请求之后、响应发送给用户之后调用before_first_request 应用启动时处理第一个请求之前调用after_request 应用关闭时处理最后一个请求之后调用 before_request使用 # 请求之前全局存入用户信息@app.before_requestdef before_request(): user_id = session.get(user_id) if user_id: user = UserModel.query.filter_by(id=user_id).first() setattr(g, user, user) else: setattr(g, user, None) Decorator装饰器装饰器 装饰器实际上是对函数的包装操作的语法糖，装饰器函数接收一个函数参数，并返回一个新的函数作为输出，接收的参数类似于callback回调函数flask提供了一些常用的装饰器：如@app.errorhandler(error_code) 定义错误处理的装饰器@app.errorhandler(404)def page_not_found(error): return Page Not Fount, 404@app.context_processor 上下文处理器存放在上下文处理器中的变量值能在所有模板中获取到@app.context_processordef my_context_processor(): return user:g.user 自定义装饰器 自定义装饰器方法def my_decorator(func): # func即被包装的函数 @wraps(func) # 用来保留函数信息 def inner(): # 对func进行包装 pass return inner # 最终调用实际是inner函数 进入路径映射函数之前对用户信息进行检测的装饰器 sessionsession对象用于在Client和Server之前存储用户会话数据默认情况下，Flask使用签名的cookie来实现会话存储（浏览器端），而不是存储在服务器端浏览器端签过名的cookie数据为了进行cookie加密，需要配置会话密钥密钥配置app.secret_key = your_secret_keysession的常见操作新增修改session值session[key] = value获取session数据temp = session.get(key)删除session数据session.pop(key, None) # 删除键为key的会话数据session.clear() # 清空所有会话数据 SMTP邮件服务如何在flask项目中发送邮件给指定邮箱 获取POP3SMTPIMAP服务授权码如何获取授权码https://help.mail.163.com/faq.do?m=list文档）异步发送邮件exts.pyfrom flask_mail import Mailmail = Mail()mail_config.py# 邮件服务的服务器地址MAIL_SERVER = smtp.163.com# 使用SSL协议加密MAIL_USE_SSL = True# SSL端口号MAIL_PORT = 465# 邮箱账号MAIL_USERNAME = piuyixiu@163.com# 开启SMTP服务时生成的授权码MAIL_PASSWORD = ...# 邮箱账号MAIL_DEFAULT_SENDER = piuyixiu@163.comapp.pyfrom config import mail_configfrom exts import mailapp.config.from_object(mail_config)mail.init_app(app)发送时会使用到flask_mail.Message类Message邮件常用属性sender 发送者recipients 接收者subject 主题body 纯文本邮件内容html HTML邮件内容attach 添加附件添加附件时需注意，代码中读取附件文件的路径是相对于执行该应用程序的当前工作目录的，即项目主入口app.py所在的文件路径with open(static/img/makima.png,rb) as f: data = f.read() message.attach(Makima.png, image/png, data) mail.send(message)from exts import mailfrom flask_mail import Message@app.route(/send_to_email)def send_to_email(): email = request.args.get(email) message = Message( subject=邮件主题, recipients=[email], body=邮件内容 ) mail.send(message) return jsonify(code=200, message=send success, data=None)"},{"title":"Flask DateBase","path":"/wiki/Python/flask_02_db.html","content":"数据库配置# 主机名HOSTNAME = 127.0.0.1# MySQL端口PORT = 3306# 用户名USERNAME = root# 密码PASSWORD = root123# 数据库名称DATABASE = books# 数据库路由app.config[SQLALCHEMY_DATABASE_URI] = fmysql+pymysql://USERNAME:PASSWORD@HOSTNAME:PORT/DATABASE?charset=utf8mb4 准备数据库对象SQLAlchemy Flask框架支持使用SQLAlchemy进行数据库操作Flask-SQLAlchemyhttps://flask-sqlalchemy.palletsprojects.com/en/3.1.x/SQLAlchemyhttps://www.sqlalchemy.org/直接根据app.config创建出db对象db = SQLAlchemy(app) 先创建空数据库对象，再注入app进行数据库配置db = SQLAlchemy()db.init_app(app)进行数据库连接测试：with app.app_context(): #拉取app上下文 with db.engine.connect() as conn: # 操作数据库执行查询语句：select 1 rs = conn.execute(text(select 1)) migrate SQLAlchemy浅更新with app.app_context(): db.create_all()SQLAlchemy会将所有继承了 db.Model 的 ORM模型 映射成数据库表，但这种自动化的映射仅限于表的首次创建（浅更新）如果修改已存在表内部的结构，SQLAlchemy不会对已存表的数据库结构进行更新，此处根据ORM模型进行数据库迁移更新的操作可以使用 flask_migrate 来实现migrate的配置from flask_migrate import Migratemigrate = Migrate(app, db) Migrate ORM映射成表的三步1. 初始化数据库，仅执行一次 flask db init 2. 识别ORM模型的改变，生成迁移脚本（migrationn/versions下的迁移脚本） flask db migrate 3. 运行迁移脚本 flask db upgrade 在执行完第1步，初始化数据库之后，会在项目根目录下新创建一个migrations文件，文件结构如下：versions 存放每次更新的数据库对应的更新命令（以版本号命名），支持根据数据库版本号进行回退操作alembic.ini : A generic, single database configuration.env.py : Alembic Config objectREADMEscript.py.mako 创建ORM模型ORM O Object 对象R Relationship 关系M Map 映射ORM模型需要：继承自db.Model拥有表名属性 tablenameBookclass Book(db.Model): __tablename__ = book # 整型 主键 自增 id = db.Column(db.Integer, primary_key=True, autoincrement=True) # 200长度字符串 非空 name = db.Column(db.String(200), nullable=False) # 整型 被引用外键author.id author_id = db.Column(db.Integer, db.ForeignKey(author.id)) # 在Author表中反向聚集book序列 author = db.relationship(Author, backref=book)Authorclass Authro(db.Model): __tablename__ = author id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False) country = db.Column(db.String(200), nullable=False) birthday = db.Column(db.Date)ForeignKey relationshipdb.ForeignKey(target_table.key_name)通过提供指定表的主键值，能够将对应的整条数据拉取过来，相当于摇人时手机里的电话号码，比如希望John过来，只需要John的手机号码，但是把John叫过来之后，需要给John流出一个座位安顿，对应的，我们也需要为被拉取的数据提供一个存放的位置（甚至可以是其他表！）target_value = db.relationship(target_table_Model, back_populates=back_target_table)第一个参数代表目标表的ORM模型名称（字符串）back_populates 定义反向引用，用于建立双向关系现在Book和Author是多对一的关系Book中拉取对应author的信息，（这本书的作者是X君）同时也需要在author中收集Books的信息，（X君写了A、B、C等书）因此为了建立起多对一的关系，需要同时对两张表进行配置： BookModelclass Book(db.Model):....author_id = db.Column(db.Integer, db.ForeignKey(author.id))author = db.relationship(Author, back_populates=book) AuthorModelclass Author(db.Model):...book = db.relationship(Book, back_populates=author) 为了简化这种双向配置的操作，也可以直接使用backref进行反向聚集配置：BookModelclass Book(db.Model): ... author_id = db.Column(db.Integer,db.ForeignKey(author.id)) author = db.relationship(Author, backref=books)常用的SQLAlchemy关系函数参数 数据库关系配置 一对多多对一一对一多对多WriterModel：一class Writer(db.Model): __tablename__ = writer id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False) books = db.relationship(Book, backref=writer)BookModel：多class Book(db.Model): __tablename__ = book id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False) writer_id = db.Column(db.Integer, db.ForeignKey(writer.id))CitizenModel：多class Citizen(db.Model): __tablename__ = citizen id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False) city_id = db.Column(db.Integer, db.ForeignKey(city.id)) city = db.relationship(City)City：一class City(db.Model): __tablename__ = city id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False, unique=True)Country：一class Country(db.Model): __tablename__ = country id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False, unique=True) capital = db.relationship(Capital, uselist=False)Capital：一class Capital(db.Model): __tablename__ = capital id = db.Column(db.Integer, primery_key=True, autoincrement=True) name = db.Column(db.String(200), nullable=False) country_id = db.Column(db.Integer,db.ForeignKey(country.id)) country = db.relationship(Country)}association_tbale：辅助表association_table = db.Table( association, db.Column(student_id,db.Integer,db.ForeignKey(student.id)), db.Column(teacher_id,db.Integer,db.ForeignKey(teacher.id)))StudentModel：多class Student(db.Model): __tablename__ = student id = db.Column(db.Integer, primery_key=True, autoincrement=True) teachers = db.relationship( Teacher, secondary = association_table, back_populates = students )TeacherModel：多class Teacher(db.Model): __tablename__ = teacher id = db.Column(db.Integer, primery_key=True, autoincrement=True) students = db.relationship( Student, secondary= association_table, back_populates=teachers ) 基本数据库操作需要写入数据库的操作都需要在最后进行commit提交db.session.commit()增删改查db.session.addbook = Book(name=name, author_id=author)db.session.add(book)db.session.commit()db.session.deletebook = Book.query.get(id)db.session.delete(book)db.session.commit()book = Book.query.get(id)book.name = new_namedb.session.commit()Obj.query是继承自db.Model的属性，查询需要调用ORM模型的query属性get(primary_key) 通过主键查询book = Book.query.get()filter_by(keyvalue,…)注意： filter_by()[0]和filter_by().first()的区别：filter_by[0] 为空时会报错filter_by().first() 为空时不会报错book = Book.query.filter_by(name=name)"},{"title":"text文本效果","path":"/wiki/UI/IxD_02_text.html","content":"Typing Effect 打字效果搜索关键字： Typing Effect打字效果有各种各样的：仅实现打字实现打字与回退实现多行连续打字实现任意内容的打字如果仅仅要实现静态文本打字效果，只用到css就足够了：head style .wrapper height:100vh; display: grid; place-items:center; .typing-demo /* 这里宽度和动画步数都被写死了 */ width:10ch; animation: typing 2s steps(5), blink .5s step-end infinite alternate; white-space: nowrap; overflow: hidden; border-right: 3px solid; font-family: monospace; font-size: 2em; @keyframes typing from width:0; @keyframes blink 50%border-color:transparent; /style/head!-- https://codepen.io/denic/pen/GRoOxbM --body div class=wrapper div class=typing-demo打出这行字/div /div/body比较关键的是用到的字体单位是ch，ch以字体中0为标准，进行相对字体大小设置，因此总是能将动画卡在每一个字上，而不会有一半字露出来的情况，纯css的方法一般要将字体数量写死在css里，非常不灵活自定义内容通过js获取要显示的文本，然后通过setTimeout控制字数一点一点增加（删除效果同理，一点一点减少），很方便能实现文字输入效果：const typingSpeed = 50, erasingSpeed = 25let captionLength = 0const typingInput = document.querySelector(#test-caption)const typingBtn = document.querySelector(#test-typing)const erasingBtn = document.querySelector(#test-erasing)const caption = document.querySelector(#caption)const cursor = document.querySelector(#cursor)let captionText = window.onload = () = typingBtn.addEventListener(click, typing) erasingBtn.addEventListener(click, erasing)// 打字/删除时禁用按钮function btnControl(enable) let fun = enable?removeAttribute:setAttribute typingBtn[fun](disabled,undefined) erasingBtn[fun](disabled,undefined)// 打字function typing() captionText = typingInput.value if(captionText.length=0 ) return btnControl(false) caption.innerHTML = let curText = cursor.classList.remove(blink) Array.from(captionText).forEach((ch,index)= setTimeout(()= // 一个字一个字加上 curText += ch caption.innerHTML = curText if(index == captionText.length - 1) btnControl(true) cursor.classList.add(blink) , index*typingSpeed) )// 回退function erasing() if( captionText.length=0 ) return btnControl(false) cursor.classList.remove(blink) for(let i = captionText.length -1 ; i = 0; i--) // 对内容一个字一个字删减 let curText = captionText.slice(0, i) setTimeout(()= caption.innerHTML = curText if(i == 0) btnControl(true) cursor.classList.add(blink) captionText = ,(captionText.length - i)*erasingSpeed) 打字效果"},{"title":"Easter egg","path":"/wiki/Python/flask_04_easter_egg.html","content":"Toby dog Tarot Card"},{"title":"grid布局","path":"/wiki/UI/css_01_grid.html","content":"参考博客：阮一峰的网络日志 基本概念flex和grid的区别 flex：轴线布局一维布局grid：行列布局二维布局 容器项目 容器：被划分成网格的根元素项目：被布局的子元素 基本属性 grid的开启：display: grid;display: inline-grid;行列宽高的指定：/*指定列宽 */grid-template-columns: 50px 50px 50px; /*指定行高 */grid-template-rows: 50px 50px 50px; repeat函数使用repeat，类似于for循环快速指定宽度模式。repeat有2个参数：参数1：重复次数可以是auto-fill参数2：重复值可以是多个值grid-template-columns: repeat(3, 33.33%);grid-template-rows: repeat(3, 33.33%);repeat的第2个参数也可以是多个值：grid-template-columns: repeat(3, 100px 20px 80px);repeat第1个参数可以使用自适应关键字auto-fillgrid-template-columns: repeat(auto-fill, 100px);fr单位fr关键字类似于flex或者span，将宽度进行等分也可以和绝对单位混合使用grid-template-columns: 1fr 1fr 1fr; grid-template-columns: 150px 1fr 2fr; minmax函数生成一个长度范围grid-template-columns: 1fr 1fr minmax(100px, 1fr); auto关键字auto关键字，表示自适应尺寸grid-template-columns: 100px auto 100px; 网格线名称使用方括号指定网格线名称，一根线可以有多个名称：grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];grid-template-rows: [r1 row1] 100px [r2] 100px [r3] auto [r4]; 容器属性网格容器 gap 间距/* row-gap 行间距 column-gap 列间距 gap: grid-row-gap grid-column-gap*/row-gap:10px;column-gap: 10px;gap:10px; areagrid-template-areas属性用于划分区域，区域的命名会影响到网格线的命名，网格线自动以，区域名-startend命名.grid-root /* ... */ display: grid; grid-template-areas: a b c d e f g h i; 子组件中需要使用grid-area属性标明所属区域：.grid-item-1 grid-area:a;grid-auto-flow划分好网格之后，需要将网格容器之下的项目依次填入，填入的顺序由grid-auto-flow控制：/* 先行后列 */grid-auto-flow: row; /* 先列后行 */grid-auto-flow: column; 控制项目的属性 项目布局justifyalignplace-items用于控制项目在网格中的布局/* justify-items 网格内物体的横向布局 align-items 网格内物体的纵向布局 place-items: align-items justify-items*/justify-items: stretch; place-items:center start; justifyalignplace-content用于控制网格的行列相对于容器的布局/* justify-content 横向分列的布局 align-content 纵向分行的布局 place-content:align-contents justify-contents*/justify-content: space-around;align-content: center;grid-auto-columnsrows当给项目指定的行列超出在容器中，使用grid-template-columnsrowsareas创建的行列数时，浏览器会自动创建多余的网格，使用grid-auto-columnsrows控制自动创建的行列的尺寸grid-template-columns: 1fr 1fr;grid-template-rows: 100px 100px;grid-auto-rows: 50px; 项目属性项目属性 指定位置通过下面的属性，可以在容器网格中指定项目的位置：grid-column-startgrid-column-endgrid-row-startgrid-row-end.grid-item grid-column-start: 1; grid-column-end: 2; grid-row-start:1; grid-row-end:3;除了通过索引指定外，也可以直接指定栅格线的名称：.grid-box display: grid; grid-template-columns: [c1] 1fr [c2] 1fr [c3] 1fr [c4]; grid-template-rows: [r1] 1fr [r2] 1fr [r3] 1fr [r4];.grid-item-1 grid-column-start:c2; grid-column-end: c4;span关键字可以用来表示跨越的网格数，使用span时，grid-column-startend所表示的意思完全一致.grid-item-2 grid-column-start: span 3;可以直接通过合并的方式简写row和column的范围：.grid-item-4 /* grid-column: start-line / end-line grid-row: start-line / end-line */ grid-column: 1 / 3; /* 也可以直接加入span关键字 */ grid-row: 4 / span 2; background:pink还可以直接使用area简写行列：.grid-item-3 /* grid-area: row-start / column-start / row-end / column-end */ grid-area: 6 / 2 / 7 / 3;justify-self和justify-item的区别2者的使用效果非常相似，不同点在于：justify-self由项目控制自身的布局justify-item由容器控制所有项目的布局"},{"title":"基础样式","path":"/wiki/UI/IxD_01_style.html","content":"跟随滚动变色的图片原网址：ElementUI中文官网https://element.eleme.cn/#/zh-CN 实现对角线的几种方式children:tabs 对角线样式方式1：border方式2：background方式3：clip-path HTMLdiv class=border-wrapper div class=border-inner/div div class=border-mask/div/divCSS.border-wrapper width:100px; height:100px; border:1px solid #000000; position:relative; overflow: hidden;.border-inner position:absolute; top:0; left:0; border-left: 100px solid #000000; border-top:100px solid rgba(0, 0, 0, 0); background: #fff;.border-mask position:absolute; top:1px; left:0; border-left: 100px solid #ffffff; border-top:100px solid rgba(0, 0, 0, 0); background: #00000000;HTMLdiv class=background-wrapper/divCSS.background-wrapper width:100px; height: 100px; border:1px solid #000000; background: linear-gradient(45deg,#fff 49%,#000,#fff 50%); HTMLdiv class=clip-path-wrapper div class=clip-path-inner/div/divCSS.clip-path-wrapper width:100px; height:100px; border:1px solid #000000;.clip-path-inner width:100%; height:100%; background: #000; clip-path: path(M0.5 0 L100 99.5 L99.5 100 L0 0.5); sprite精灵图实现gif效果精灵图效果参考地址精灵图实现动态图片效果的原理类似与电影胶卷，通过快速分布平移，实现动态效果：div class=sprite-bg/div.sprite-bg width:100%; height:100%; background-image: $spriteBgImg; background-position: top; background-size:100% auto; filter:brightness(1.3); animation: anime-effect 0.5s steps(30); animation-iteration-count: infinite; @keyframes anime-effect 0% background-position: 0px 0px; 100% background-position: 0px -15015px; 最终实现效果："},{"title":"Media Queries 媒体查询","path":"/wiki/UI/css_02_media_queries.html","content":"MDN文档：使用媒体查询可查询参数 width常见屏幕尺寸适配：手机尺寸：320px-480px平板电脑： 481px - 1024px大屏幕电脑： 1025px以上@media (max-width: 480px) .phone background-color: #023047; @media (min-width: 481px) and (max-width:1024px) .tablet background-color: #ffb703; @media (min-width: 1025px) .pc background-color: #fb8500;"},{"title":"24个svg示例","path":"/wiki/UI/svg_01_24demos.html","content":"24个示例 Hunor Márton Borbély 原视频地址 b站搬运地址 在html5之后，html中可以直接书写svg，无需再将svg标签单独拉出。 svg和html不能混用标签 svg标签属性 widthheight 外部尺寸viewBox( sx, sy, w, h) 内部尺寸sxsy 左上角起始坐标wh 宽度高度坐标系 左上角开始（0, 0）右下角结束（100, 100）宽50px，高50px，绘制（0,0）-（100,100）的图像 svg width=50 height=50 viewBox=0 0 100 100 circle cx=50 cy=50 r=25 fill=#00ff00/circle/svg宽100px，高100px，绘制（0,0）-（100,100）的图像 svg width=100 height=100 viewBox=0 0 100 100 circle cx=50 cy=50 r=25 fill=#00ff00/circle/svg宽100px，高100px，绘制（0,0）-（50,50）的图像 svg width=100 height=100 viewBox=0 0 50 50 circle cx=50 cy=50 r=25 fill=#00ff00/circle/svg宽100px，高100px，绘制（-50,-50）-（50,50）的图像 svg width=100 height=100 viewBox=-50 -50 100 100 circle cx=50 cy=50 r=25 fill=#00ff00/circle/svg 圣诞球 .ball{ animation: changeHue infinite 750ms; } @keyframes changeHue { 0%{ filter:hue-rotate(0deg) brightness(1.5); } 100%{ filter:hue-rotate(360deg) brightness(1.5); } } svgxmlns=http://www.w3.org/2000/svgwidth=200height=200viewBox=-100 -100 200 200 circle cx=0 cy=20 r=70 fill=#d1495b /circle circle cx=0 cy=-75 r=12 stroke=#f79257 stroke-width=5 fill=none /circle rect x=-17.5 y=-65 width=35 height=20 fill=#f79257 /rect/svg 圣诞树 svgwidth=200height=230viewBox=-100 -100 200 230 polygon points=0,-20 80,100 -80,100 fill=#234236/polygon polygon points=0,-60 60,40 -60,40 fill=#0C5C4C/polygon polygon points=0,-100 40,-20 -40,-20 fill=#38755b/polygon rect x=-20 y=100 width=40 height=30 fill=brown/rect/svg 姜饼人"},{"title":"Three.js Tutorial for Absolute Beginners","path":"/wiki/ThreeJs/Wael_01_threejs_for_beginners.html","content":"源项目仓库： npm安装 parcel.js 程序打包工具 three.js 图表库 threejs尽量安装稳定版本，最新版本可能存在各种问题 npm install three@0.133.0npm install parcel parcel.js parcel将多个源文件打包成一个dist，支持开发时热更新。文件结构如下时：rootsrcjsmain.jsindex.html 主页面入口package.json在项目根目录路径root\\下使用parcel命令：parcel index.htmlparcel会在项目根目录root\\下创建一个dist文件夹，即真正运行的文件 渲染器Renderer场景Scene摄像机Camera场景Scene const scene = new THREE.Scene() 摄像机Camera const camera = new THREE.PerspectiveCamera( 75, //fov window.innerWidth / window.innerHeight, //aspect 0.01, //near 10000 //far)scene.add(camera)camera.position.set(20, 20, 20)camera.lookAt(0,0,0) Renderer渲染器 const renderer = new THREE.WebGLRenderer()renderer.setSize(window.innerWidth, window.innerHeight)document.body.append(renderer.domElement)renderer.render(scene, camera) 坐标系辅助线AxesHelper物体Object动画Animate轨道控制器OrbitControlsAxesHepler const axesHelper = new THREE.AxesHelper(15)scene.add(axesHelper) Object const boxGeometry = new THREE.BoxGeometry(3,3,3)const boxMetarial = new THREE.MeshBasicMaterial( color:0x00ff00)const box = new THREE.Mesh(boxGeometry, boxMetarial)scene.add(box) Animate 记得每次调用animate时都要调用render进行重绘renderer.setAnimationLoop(animate)function animate(time) box.rotation.x = time / 1000 box.rotation.y = time / 1000 renderer.render(scene, camera) OrbitControls 每次对相机进行修改后，都需要调用orbit.update()进行更新import OrbitControls from three/examples/jsm/controls/OrbitControls// ...const orbit = new OrbitControls(camera, renderer.domElement)orbit.update() Geometry几何构造Material材质GridHelper网格辅助器GeometryMaterial // plane geometryconst planeGeometry = new THREE.PlaneGeometry(30, 30)const planeMaterial = new THREE.MeshBasicMaterial( color: 0xffffff, side:THREE.DoubleSide)const plane = new THREE.Mesh(planeGeometry, planeMaterial)scene.add(plane)plane.rotation.x = -Math.PI / 2// sphere geometryconst sphereGeometry = new THREE.SphereGeometry(4)const sphereMaterial = new THREE.MeshBasicMaterial( color:0xffff00)const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)scene.add(sphere)sphere.position.set(-10,10,10) GridHelper GridHelper：param1: sizeparam2: divisionsconst gridHelper = new THREE.GridHelper(30, 30)scene.add(gridHelper) dat.gui交互界面npm安装dat.gui npm install dat.gui dat.gui import GUI from dat.guiconst options = sphereColor: 0xb16c4b, wireframe: false, speed: 0.05const gui = new GUI()gui.addColor(options, sphereColor).onChange((e) = sphere.material.color.set(e))gui.add(options, wireframe).onChange(e = sphere.material.wireframe = e)gui.add(options, speed, 0, 0.1)function animate(time) // ... sphere.position.y = 10*Math.abs(Math.sin(Math.PI*(time/100)*options.speed)) renderer.render(scene, camera) AmbientLight环境光DirectionalLight直射光SpotLight聚光灯Shadow阴影将之前创建的物体材质改成受光照影响的MeshStandardMaterial AmbientLight const ambientLight = new THREE.AmbientLight(0xffffff)scene.add(ambientLight) DirectionalLight const directionalLight = new THREE.DirectionalLight(0xffffff)scene.add(directionalLight)directionalLight.position.set(-30,30,30)const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight ,5, 0x0000ff)scene.add(directionalLightHelper)DirectionalLight的阴影底部范围默认为5，需要通过改变light.shadow.camera.bottom来控制底部范围directionalLight.shadow.camera.bottom = -10 Shadow 要投射阴影，首先要将renderer的shadowMap属性打开renderer.shadowMap.enabled = true然后需要将光源的castShadow属性打开，需要投射阴影物体的castShadow设为true，被投射阴影的面的receiveShadow设为truedirectionalLight.castShadow = truesphere.castShadow = trueplane.receiveShadow = true SpotLight const spotLight = new THREE.SpotLight(0xffffff)scene.add(spotLight)spotLight.position.set(-30, 30, 30)spotLight.castShadow = trueconst spotLightHelper = new THREE.SpotLightHelper(spotLight)scene.add(spotLightHelper) Fog雾SceneBackground场景背景Texture纹理Fog 方式1：指定雾的范围scene.fog = new THREE.Fog(0xffffff,20, 200)方式2：指定雾的密度scene.fog = new THREE.FogExp2(0xffffff,0.01) textureLoader 单个textureLoader：import nebula from ../img/nebula.jpgconst textureLoader = new THREE.TextureLoader()scene.background = textureLoader.load(nebula)cubeTextureLoader：import starts from ../img/stars.jpgimport nebula from ../img/nebula.jpgconst cubeTextureLoader = new THREE.CubeTextureLoader()scene.background = cubeTextureLoader.load([ nebula, starts, starts, nebula, nebula, starts]) Texture 物体添加纹理：import nebula from ../img/nebula.jpgconst textureLoader = new THREE.TextureLoader()const boxGeometry2 = new THREE.BoxGeometry(3,3,3)const boxMetarial2 = new THREE.MeshBasicMaterial( map:textureLoader.load(nebula))const box2 = new THREE.Mesh(boxGeometry2, boxMetarial2)scene.add(box2)同一个物体添加多个材质：import starts from ../img/stars.jpgimport nebula from ../img/nebula.jpgconst textureLoader = new THREE.TextureLoader()const boxGeometry2 = new THREE.BoxGeometry(3,3,3)const boxMetarial2 = [ new THREE.MeshBasicMaterial(map:textureLoader.load(nebula)), new THREE.MeshBasicMaterial(map:textureLoader.load(nebula)), new THREE.MeshBasicMaterial(map:textureLoader.load(starts)), new THREE.MeshBasicMaterial(map:textureLoader.load(nebula)), new THREE.MeshBasicMaterial(map:textureLoader.load(nebula)), new THREE.MeshBasicMaterial(map:textureLoader.load(starts)),]const box2 = new THREE.Mesh(boxGeometry2, boxMetarial2)scene.add(box2) Select选中selection 选中一个物体，首先需要在绘制区域创建一个二维坐标系：let mousePosition = new THREE.Vector2()window.onmousemove = function (e) mousePosition.x = (e.clientX / window.innerWidth * 2) - 1 mousePosition.y = 1 - (e.clientY / window.innerHeight * 2)这里实现选中物体的原理是从摄像机Camera和鼠标Mouse之间发射出一条射线，所有被射线穿透的物体即视为选中状态，因此，我们需要创建一条射线：let rayCaster = new THREE.Raycaster()然后在loop函数中持续对选中物体进行检测function animate(time) // ... rayCaster.setFromCamera(mousePosition, camera) let intersects = rayCaster.intersectObjects(scene.children) for (let obj of intersects) if (obj.object.id === sphere.id) obj.object.material.color.set(0xffff00) else if (obj.object.name === box2.name) obj.object.rotation.x += 0.01 obj.object.rotation.z += 0.01 renderer.render(scene, camera) VertexPosition顶点坐标ShaderMaterial渲染器材质ModelImport模型导入Vertext.attribute.position 通过直接修改obj.geometry.attributes.position数组中数值进行顶点修改，注意：修改后需要将needsUpdate设置为truelet posArray = plane.geometry.attributes.position.array;for (let i = 0; i posArray.length; i++) if (i % 3 == 2) let extent = (Math.abs(i-posArray.length/2)/posArray.length)*5 posArray[i] = (2+extent)*Math.sin(Math.PI*time/1000/Math.max(extent,i/posArray.length*5)) plane.geometry.attributes.position.needsUpdate = true ShaderMaterial 方式1：shader程序用字符串变量常量定义：const vShader = ` void main() gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); `const fShader = ` void main() gl_FragColor = vec4( 0.7, 0.5, 1.0, 1.0); `const sphereMaterial = new THREE.ShaderMaterial( vertexShader: vShader, fragmentShader: fShader)方式2：shader程序使用script标签写在html文件中:script id=vShader type=x-vertex void main() gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); /scriptscript id=fShader type=x-fragment void main() gl_FragColor = vec4( 0.7, 0.5, 1.0, 1.0); /scriptconst sphereMaterial = new THREE.ShaderMaterial( vertexShader: document.getElementById(vShader).textContent, fragmentShader: document.getElementById(fShader).textContent,) import model 这里以导入gltf格式模型为例，对于不同模型，threejs提供了不同loader：import GLTFLoader from three/examples/jsm/loaders/GLTFLoaderconst gltfLoader = new GLTFLoader()由于项目内使用了parcel作为打包工具，因此模型文件的路径需要动态获取：const monkeyUrl = new URL(../assets/monkey.glb, import.meta.url)通过loader读取模型数据并绘制：gltfLoader.load(monkeyUrl.href, function (gltf) let model = gltf.scene scene.add(model) model.position.set(0, 10, 0) model.scale.set(2,2,2), undefined, function (err) console.err(err)) CanvasResponsive响应式画布onresize 在屏幕尺寸发生变化时，需要对相机camera的比例进行更新，renderer需要重绘：window.onresize = function () camera.aspect = window.innerWidth / window.innerHeight camera.updateProjectionMatrix() renderer.setSize(window.innerWidth,window.innerHeight)"},{"title":"Solar System 模拟太阳系","path":"/wiki/ThreeJs/Wael_02_SolarSystem.html","content":"项目及资源来源 原项目仓库：行星texture来源: JHT’s PLANETARY PIXEL EMPORIUM土星环来源：DEVIANT ART天王星环来源：FAVPNG 星空、太阳与点光源星空背景 使用一张星空背景图为天空盒的六面贴图const cubeTextureLoader = new THREE.CubeTextureLoader()scene.background = cubeTextureLoader.load([ stars, stars, stars, stars, stars, stars,]) 太阳 太阳位于星系中心点位置let sunGeometry = new THREE.SphereGeometry(16, 30, 30)let sunMetarial = new THREE.MeshBasicMaterial( map:textureLoader.load(sunTexture))let sun = new THREE.Mesh(sunGeometry, sunMetarial)scene.add(sun) 点光源 为太阳添加pointLight点光源，可以对pointLight的一些属性进行初始化：color 颜色intensity 强度distance 延伸距离const pointLight = new THREE.PointLight(0xffffff, 2, 300)sun.add(pointLight) 行星的自转与公转行星 一共要创建九个行星（算上冥王星），方便起见我们需要写一个创建函数：function createPlanet(radius,texture,position) const geometry = new THREE.SphereGeometry(radius,30,30) const metarial = new THREE.MeshStandardMaterial( map:textureLoader.load(texture) ) const mesh = new THREE.Mesh(geometry,metarial) mesh.position.set(position,0,0) scene.add(mesh) return mesh再为每个行星调用const mercury = createPlanet(3.2, mercuryTexture,28)const venus = createPlanet(4.2, venusTexture,44)const earth = createPlanet(3, earthTexture,62)const mars = createPlanet(2.8, marsTexture,78)const jupiter = createPlanet(15, jupiterTexture,100)const saturn = createPlanet(10, saturnTexture,138)const uranus = createPlanet(7, uranusTexture,176)const neptune = createPlanet(8, neptuneTexture,200)const pluto = createPlanet(2.8, plutoTexture,216) 自转与公转 如果需要所有行星都围绕太阳转动，可以把所有行星都加在太阳的子类中，这样当太阳自时，其它行星也都随之转动，但是这样存在一个问题：不同行星的公转速度不同。因此需要给每个行星都配置一个幽灵恒星，假设这些恒星全都位于太阳位置，以不同速度自转：function createPlanet(radius,texture,position,ring) const obj = new THREE.Object3D() // 创造行星mesh... obj.add(mesh) scene.add(obj) return obj:obj,mesh:mesh再在animate中进行公转和自转的操作：function animate() sun.rotateY(0.004) // 公转 mercury.obj.rotateY(0.004) venus.obj.rotateY(0.002) earth.obj.rotateY(0.02) mars.obj.rotateY(0.018) saturn.obj.rotateY(0.038) jupiter.obj.rotateY(0.04) uranus.obj.rotateY(0.03) neptune.obj.rotateY(0.032) pluto.obj.rotateY(0.008) // 自转 mercury.mesh.rotateY(0.04) venus.mesh.rotateY(0.015) earth.mesh.rotateY(0.01) mars.mesh.rotateY(0.008) saturn.mesh.rotateY(0.0009) jupiter.mesh.rotateY(0.002) uranus.mesh.rotateY(0.0004) neptune.mesh.rotateY(0.0001) pluto.mesh.rotateY(0.00007) renderer.render(scene , camera) 行星环土星和天王星都有星环，因此需要修改行星工厂函数，绘制星环"},{"title":"导入模型","path":"/wiki/ThreeJs/Wael_03_blender_to_three.html","content":"源项目仓库： 动画模型的播放狗狗模型是项目原作者WaelYasmina做的（kawaii捏）模型导出成glb格式之后，一般首先在threejs提供的官方编辑器中导入，看看模型、动画能不能正常执行三个要素THREE.AnimationMixer 是Three.js中用于管理和播放模型动画额度组件THREE.AnimationClip模型中包含的动画片段THREE.Clock时间指挥棒下面的步骤是为了创建好mixer，类似于合成一条视频轨道：let mixergltfLoader.load(doggo.href,function(gltf) const model = gltf.scene scene.add(model) mixer = new THREE.AnimationMixer(model) const clips = gltf.animations // 传入所有动画 clips.forEach(clip= const action = mixer.clipAction(clip) action.play() ),undefined,function(err) console.error(err))仅仅是合成好视频轨道之后，还需要创建一个时间指示器，用于告诉mixer动画执行到哪里，并且需要早animate函数中更新mixer：const clock = new THREE.Clock()function animate() if(mixer) mixer.update(clock.getDelta()) renderer.render(scene , camera) 导入模型加入阴影为导入的模型整体加上castShadow属性无效，因为导入模型是由各个部位组成的，需要遍历模型整体下的各个部分，分别开启castShadow。遍历子部位使用的是ThreeJs中Group类的traverse方法，traverse的参数是一个回调函数，作用和用法与forEach相类似const gltfLoader = new GLTFLoader()gltfLoader.load(/assets/Wolf.gltf, gltf = // ... gltf.scene.traverse(node = if (node.isObject3D) node.castShadow = true )) 动画拼接如果同时开启多个clipAction，多个动画之间的关系不会是连续串行，而是并行，想要实现串行动画，首先需要关闭动画的无限循环选项（动画默认是loop），这样就可以触发mixer的finished事件。finish事件会在动画全部结束后触发，只要在finishing事件中，reset初始化并paly播放另一个动画：let mixerconst gltfLoader = new GLTFLoader()gltfLoader.load(/assets/Alpaca.gltf, gltf = scene.add(gltf.scene) mixer = new THREE.AnimationMixer(gltf.scene) const action_eat = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, Eating)) action_eat.loop = THREE.LoopOnce action_eat.play() const action_walk = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, Idle)) action_walk.loop = THREE.LoopOnce // action_walk.play() mixer.addEventListener(finished, function (e) if (e.action._clip.name === Eating) action_walk.reset() action_walk.play() else if (e.action._clip.name === Walk) action_eat.reset() action_eat.play() ))"},{"title":"Shader Tutorial 着色器","path":"/wiki/ThreeJs/Wael_04_shader_tutorial.html","content":"原项目视频https://www.youtube.com/watch?v=xZM8UJqN1eY&t=907s 稍稍修shader绘制的顶点坐标一个10*10的网格平面，正常绘制时，其VertexShader如下：void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);但是如果稍稍做一些修改，将使用三角函数对position进行变换：sin变换void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(sin(position), 1.0);cos变换void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(cos(position), 1.0);tan变换void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(tan(position), 1.0); 传入uniform变量vertex shader中使用uniform变量 shader存在两种可以从js传入的变量类型，一种是attribute，另一种是uniform，attribute针对不同顶点提供不同的值，uniform类型的变量能够作用于每一个顶点，使用threejs传入uniform类型的变量的位置，和传入shader程序的位置相同，也是在定义Shader材质的时候作为属性传入：const uniforms = u_time:type:f,value:0const material = new THREE.ShaderMaterial( vertexShader:document.getElementById(vertex-shader).textContent, fragmentShader:document.getElementById(fragment-shader).textContent, wireframe:true, uniforms // 传入shader);动画的关键属性就是时间，因此还需要考虑属性随时间的变化，可以在animate函数中对属性进行修改：function animate() uniforms.u_time.value = clock.getElapsedTime() //... renderer.render(scene, camera)以上是在js中的配置，着色器程序中也需要定义需要接收的uniform变量：script id=vertex-shader type=x-vertex uniform float u_time; void main() float newX = sin(position.x * u_time) * sin(position.y * u_time); vec3 newPosition = vec3(newX, position.y, position.z); gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0); /scriptshader中参与计算的数据附着上时间属性后，构成了动画： fragment shader中使用uniform变量 要实现片元颜色沿x轴显现出渐变色，首先需要知道该片元的x轴坐标，这个值在FragmentShader中是提供的：gl_FragCoord.x，这是这个片元的绝对位置，除此之外还需要知道这个x值相对整个画布的位置，因为只有这样才能把x值归一化到-1和1之间，因此画布大小这个变量就需要从js中传入：const uniforms = // ... u_resolution : type:v2, // vec2 类型 // 按照设备像素比例计算尺寸 value: new THREE.Vector2(window.innerWidth,window.innerHeight) .multiplyScalar(window.devicePixelRatio) 在fragment shader中接收画布分辨率之后，计算出片元的相对位置，再根据这个相对位置设置片元颜色：script id=fragment-shader type=x-fragment uniform vec2 u_resolution; void main() vec2 st = gl_FragCoord.xy / u_resolution; gl_FragColor = vec4(0.0,st.x, 0.0, 1.0); /script最终绘制的结果呈现渐变效果： 鼠标控制颜色变化 鼠标坐标需要从js中传入，需要注意的是鼠标依赖的是浏览器坐标系，从左上角开始到右下角，其y轴方向与webgl中的y轴方向相反因此一方面需要对鼠标坐标进行归一化处理，另一方面需要对y轴反向const uniforms = // ... u_mouse: type:v2, value:new THREE.Vector2(0,0) window.onmousemove= e= uniforms.u_mouse.value.set( e.offsetX/window.innerWidth, 1-e.offsetY/window.innerHeight )uniform vec2 u_mouse;uniform vec2 u_resolution;void main() vec2 st = gl_FragCoord.xy / u_resolution; gl_FragColor = vec4(st.x, u_mouse, 1.0); shader绘制纹理纹理的传入使用的也是uniform类型变量，纹理类型需要限制为sampler2D取样器类型，gles中的取样方法为texture2D这个方法接收两个参数：sampler2D类型的图片取样器vec2类型的图片坐标在Vertex Shader中，ThreeJs提供了uv变量作为当前被渲染物体的纹理坐标可以直接拿来使用第一步：将纹理图片作为uniform变量传入import nebula from ../img/nebula.jpg;const uniforms = //... image : type:t, value:textLoader.load(nebula) 第二步：将uv纹理坐标使用varing变量从vertex shader传入fragment shader中varying vec2 v_uv;void main() v_uv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);第三步： 在fragment shader中读入传入的纹理图片，然后绘制uniform vec2 u_resolution;uniform vec2 u_mouse;uniform float u_time;uniform sampler2D image;varying vec2 v_uv;void main() vec2 st = gl_FragCoord.xy / u_resolution; vec4 texture = texture2D(image, v_uv); gl_FragColor = vec4(vec3(texture),1.0); GLSL Snacks视口大小变化导致光标偏移使用ShaderMaterial创建一个材质，要求材质的颜色以 距离鼠标的位置 为标准变化，v-shaderscript type=x-vertex id=v-shader void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptf-shaderscript type=x-fragment id=f-shader uniform vec2 u_resolution; uniform vec2 u_mouse; void main() vec2 st = gl_FragCoord.xy/u_resolution; float c = 1.0 - distance(st, u_mouse); float color = pow(c, 10.0); gl_FragColor = vec4(vec3(color), 1.0); /script需要向Fragment Shader中传入两个vec2类型的uniform变量：u_resolution 分辨率u_mouse 鼠标坐标const uniforms = u_resolution: type: v2, value:new THREE.Vector2(window.innerWidth, window.innerHeight) , u_mouse: type: v2, value:new THREE.Vector2() window.onmousemove = e = uniforms.u_mouse.value.x = e.offsetX / window.innerWidth; uniforms.u_mouse.value.y = 1 - e.offsetY / window.innerHeight;const planeGeo = new THREE.PlaneGeometry(4, 4)const planeMat = new THREE.ShaderMaterial( uniforms, vertexShader: document.getElementById(v-shader).textContent, fragmentShader: document.getElementById(f-shader).textContent)const planeMesh = new THREE.Mesh(planeGeo, planeMat)scene.add(planeMesh)实现效果但是在屏幕尺寸改变时，会发现对鼠标位置的计算出现偏差，对于这个问题，可以在resize函数中更新分辨率变量u_resolution的值：window.addEventListener(resize, function() // ... uniforms.u_resolution.value.x = window.innerWidth; uniforms.u_resolution.value.y = window.innerHeight; // ...); 纹理镂空效果这里的纹理镂空指的是对纹理进行动态映射，根据 片元坐标相对视口位置 来获取 纹理的映射范围，vertex shaderscript type=x-vertex id=v-shader void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptfragment shaderscript type=x-fragment id=f-shader uniform vec2 u_resolution; uniform sampler2D image; void main() vec2 st = gl_FragCoord.xy / u_resolution; vec4 texture = texture2D(image, st); gl_FragColor = vec4(vec3(texture), 1.0); /script使用ShaderMaterial传入uniform变量：const uniforms = u_resolution: type:v2, value:new THREE.Vector2(window.innerWidth, window.innerHeight) , image: type:t, value:new THREE.TextureLoader().load(./assets/ice.png) 实现镂空效果： 将 纹理镂空 效果转换为 纹理映射 效果，只需要对 texture2D 采样使用的坐标进行修改，这里传入的uVu(uv)参数，通常代表的是 当前顶点的纹理坐标 ： script type=x-vertex id=v-shader varying vec2 uVu; void main() uVu = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptscript type=x-fragment id=f-shader varying vec2 uVu; uniform vec2 u_resolution; uniform sampler2D image; void main() vec2 st = gl_FragCoord.xy / u_resolution; vec4 texture = texture2D(image, uVu); gl_FragColor = vec4(vec3(texture), 1.0); /script 纹理动画效果动画的实现需要引入一个重要的变量：时间步骤1：实现半透明蒙版效果首先有一张渐变灰度图：将这张渐变灰度图映射到目标物体表面，为了实现半透明的效果:将纹理的r通道映射到alpha通道中开启纹理材质的transparent属性script type=x-fragment id=f-shader uniform sampler2D image; varying vec2 vUv; void main() vec4 textureColor = texture2D(image, vUv); gl_FragColor = vec4(vec3(0.3, 0.2, 0.6), textureColor.r); script/这样能够实现半透明的渐变效果：步骤2：实现纹理旋转效果要做出旋转的效果：传入u_time时间参数在纹理映射的时候，对uv坐标进行旋转处理script type=x-fragment id=f-shader uniform float u_time; uniform sampler2D image; varying vec2 vUv; vec2 rotate(vec2 uv, float rotation) return vec2( cos(rotation) * uv.x + sin(rotation) * uv.y, cos(rotation) * uv.y - sin(rotation) * uv.x ); void main() vec2 vUv = vUv; vUv -= vec2(0.5); // 图像中心移动到左上角（旋转中心） vec2 vUv_rotate = rotate(vUv, u_time); vUv_rotate += vec2(0.5); // 将图像中心移回 vec4 textureColor = texture2D(image, vUv_rotate); gl_FragColor = vec4(vec3(0.3, 0.2, 0.6), textureColor.r); /scriptu_time的刷新：function animate(time) uniforms.u_time.value = time.toFixed(2)/1000 renderer.render(scene, camera);步骤3：实现纹理叠加效果将gl_FragColor的rgb通道，换成需要映射的纹理即可：script type=x-fragment id=f-shader uniform float u_time; uniform sampler2D image; uniform sampler2D golconda; varying vec2 vUv; vec2 rotate(vec2 uv, float rotation) // ... void main() vec2 vUv2 = vUv; // 保存原始纹理坐标 vec2 vUv = vUv; vUv -= vec2(0.5); vec2 vUv_rotate = rotate(vUv, u_time); vUv_rotate += vec2(0.5); vec4 textureColor = texture2D(image, vUv_rotate); vec4 imageTexture = texture2D(golconda, vUv2); gl_FragColor = vec4(vec3(imageTexture), textureColor.r); /script 过滤效果两张纹理之间的过渡，如果不引入任何效果，只需要使用 mix 函数就能实现。gl_FragColor = mix(i1Texel, i2Texel, mixRatio);想要实现其他过渡效果，需要引入一张纹理材质图片：使用 clump 函数将纹理图片映射到 mixer 处理过的图片的alpha通道上:vec4 transitionTexel = texture2D(transition, vUv); // 纹理vec4 i1Texel = texture2D(image, vUv); vec4 i2Texel = texture2D(image2, vUv);// mixRatio 代表混合程度float r = mixRatio * 1.6 - 0.3; // [-0.3, 1.3]float mixF = clamp((transitionTexel.r - r) * 3.33, 0.0, 1.0); gl_FragColor = mix(i1Texel, i2Texel, mixF);需要传入的uniform有这些：script type=x-fragment id=f-shader uniform sampler2D image; uniform sampler2D image2; uniform sampler2D transition; uniform float mixRatio; varying vec2 vUv; void main() vec4 transitionTexel = texture2D(transition, vUv); vec4 i1Texel = texture2D(image, vUv); vec4 i2Texel = texture2D(image2, vUv); float r = mixRatio * 1.6 - 0.3; float mixF = clamp((transitionTexel.r - r) * 3.33, 0.0, 1.0); gl_FragColor = mix(i1Texel, i2Texel, mixF); /script Perlin Noise 噪点动画讲到这里， Wael Yasmina 又甩出来一个很强的网站：Click to releasehttps://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/是一位大佬的技术分享网站噪点，需要在原物体顶点坐标的基础上进行偏移，能够实现光滑物体表面粗糙不平的效果，如果这种偏移是震荡连续的，就能够实现波浪形的动画效果。噪点的实现需要借助 Parcel Noise：Ashima写好的webgl噪点程序准备好基础球体，然后就开始…..复制粘贴，webgl-noisesrc下提供了各种噪点程序，复制粘贴需要的到vertex shader中，这里以 classicnoise3D 为例，里面提供了两种噪点程序：cnoisepnoise选用pnoise噪点程序，最后的vertex shader如下所示：script type=x-vertex id=v-shader uniform float u_time; // 辅助函数 vec3 mod289(vec3 x) return x - floor(x * (1.0 / 289.0)) * 289.0; vec4 mod289(vec4 x) return x - floor(x * (1.0 / 289.0)) * 289.0; vec4 permute(vec4 x) return mod289(((x*34.0)+10.0)*x); vec4 taylorInvSqrt(vec4 r) return 1.79284291400159 - 0.85373472095314 * r; vec3 fade(vec3 t) return t*t*t*(t*(t*6.0-15.0)+10.0); // Classic Perlin noise, periodic variant float pnoise(vec3 P, vec3 rep) vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec3 Pf0 = fract(P); // Fractional part for interpolation vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz; vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 gx0 = ixy0 * (1.0 / 7.0); vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5; gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0)); gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5); vec4 gx1 = ixy1 * (1.0 / 7.0); vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5; gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0)); gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5); vec3 g000 = vec3(gx0.x,gy0.x,gz0.x); vec3 g100 = vec3(gx0.y,gy0.y,gz0.y); vec3 g010 = vec3(gx0.z,gy0.z,gz0.z); vec3 g110 = vec3(gx0.w,gy0.w,gz0.w); vec3 g001 = vec3(gx1.x,gy1.x,gz1.x); vec3 g101 = vec3(gx1.y,gy1.y,gz1.y); vec3 g011 = vec3(gx1.z,gy1.z,gz1.z); vec3 g111 = vec3(gx1.w,gy1.w,gz1.w); vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))); g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w; vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))); g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w; float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz)); float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z)); float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)); float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1); vec3 fade_xyz = fade(Pf0); vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z); vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y); float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); return 2.2 * n_xyz; // 主体 void main() float noise = 5.0 * pnoise(position + u_time, vec3(10.0)); float displacement = noise / 10.0; vec3 newPosition = position + normal * displacement; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); /scriptfragment shader如下：script type=x-fragment id=f-shader uniform vec2 u_resolution; void main() vec2 st = gl_FragCoord.xy / u_resolution; gl_FragColor = vec4(vec3(st.x, st.y, 1.0),1.0); /scriptclassicnoise3D/perlin_noiseclassicnoise3D/classic_noise Audio Visualize Animation 音频可视化音频可视化在threejs中并不难实现，关键是： 音频值加入噪点的计算步骤1：创建网格物体const uniforms = u_time: type: f, value: 0.0 const mat = new THREE.ShaderMaterial( uniforms, wireframe:true, vertexShader: document.getElementById(v-shader).textContent, fragmentShader:document.getElementById(f-shader).textContent)const geo = new THREE.IcosahedronGeometry(4, 20)const mesh = new THREE.Mesh(geo, mat)scene.add(mesh)script type=x-vertex id=v-shader uniform float u_time; void main() gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptscript type=x-fragment id=f-shader void main() gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); /script步骤2：加入噪点script type=x-vertex id=v-shader // 噪点部分省略 uniform float u_time; void main() float noise = 5.0 * pnoise( position + u_time, vec3(10.0)); float displacement = noise / 10.0; vec3 newPosition = position + displacement; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); /script步骤3：加入音频官方文档-音频https://threejs.org/docs/index.html?q=AudioLi#api/en/audio/AudioListener音频作为一个实体，具有坐标属性，这里可以将音频加入camera中// 创建一个AudioListener，放入cameraconst listener = new THREE.AudioListener();camera.add(listener)// 创建一个全局音频资源const sound = new THREE.Audio(listener)// AudioLoader加载音频， 设置进Audio的buffer中const audioLoader = new THREE.AudioLoader();audioLoader.load(./assets/audio/ili.mp3, function (buffer) sound.setBuffer(buffer); sound.loop = true sound.play())准备好音乐，需要创建AudioAnalyser对音频进行解析const analyser = new THREE.AudioAnalyser(sound, 32)在animation中提取出每一帧的平均频率，作为变量传入vertex shader：const uniforms = // .... u_frequency: type: f, value: 0.0 function animate() // ... uniforms.u_frequency.value = analyser.getAverageFrequency()在顶点着色器中，加入u_frequency计算顶点偏移量script type=x-vertex id=v-shader // ... uniform float u_frequency; void main() float noise = 5.0 * pnoise(position + u_time, vec3(10.0)); // 加入u_frequency计算 float displacement = (u_frequency / 30.0) * (noise / 10.0); vec3 newPosition = position + normal * displacement; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); /script此处无声胜有声，没有声音凑合听步骤4：gui改变颜色引入gui，将r、g、b三个通道的颜色作为float类型变量传入。const uniforms = // ... u_red: type:f, value:1.0, u_green: type:f, value:1.0, u_blue: type:f, value:1.0,const gui = new GUI()const colorFolder = gui.addFolder(color)colorFolder.add(uniforms.u_red, value).min(0).max(1).name(red)colorFolder.add(uniforms.u_green, value).min(0).max(1).name(green)colorFolder.add(uniforms.u_blue, value).min(0).max(1).name(blue)script type=x-fragment id=f-shader uniform float u_red; uniform float u_green; uniform float u_blue; void main() gl_FragColor = vec4(u_red, u_green, u_blue, 1.0); /script步骤5：加入unrealBloom特效import RenderPass from three/examples/jsm/postprocessing/renderpass;import EffectComposer from three/examples/jsm/postprocessing/effectcomposer;import UnrealBloomPass from three/examples/jsm/postprocessing/unrealbloompass;import OutputPass from three/examples/jsm/postprocessing/outputpass;// ...const renderScene = new RenderPass(scene, camera)const effectComposer = new EffectComposer(renderer)const unrealBloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.2, 0.5)effectComposer.addPass(renderScene)effectComposer.addPass(unrealBloomPass)const outputPass = new OutputPass()effectComposer.addPass(outputPass)const unrealBloomFolder = gui.addFolder(unreal bloom)unrealBloomFolder.add(unrealBloomPass,strength,0,3)unrealBloomFolder.add(unrealBloomPass,radius,0,3)unrealBloomFolder.add(unrealBloomPass,threshold,0,1)unrealBloomFolder.add(renderer,toneMappingExposure,0,3)//...function animation() //... effectComposer.render()是特效！我加了特效！ 受光照影响的ShaderMaterial想让自定义的ShaderMaterial受光照影响，有2种方式：在shader程序中经过计算实现光照效果重写其它受光照影响的材质的部分shader已经有实现第二种方式的库： 引入customShaderMaterialnpm安装：npm install three-custom-shader-materialimport CustomShaderMaterial from three-custom-shader-material/vanillaconst custom_mat = new CustomShaderMaterial( baseMaterial: THREE.MeshPhysicalMaterial, // 需要修改的材质 metalness: 0.6, roughness:0.3, uniforms, vertexShader: document.getElementById(v-shader).textContent, fragmentShader: document.getElementById(f-shader).textContent)CustomShaderMaterial中使用shader，不能仅仅给原本GLSL输出变量进行修改，还需要修改一些以csm（custom shader material）开头的输出变量，比如：gl_Position → csm_Positiongl_FragColor → csm_FragColor引入vertexfragment shaderconst mat = new THREE.ShaderMaterial( uniforms, vertexShader: document.getElementById(v-shader).textContent, fragmentShader: document.getElementById(f-shader).textContent)const custom_mat = new CustomShaderMaterial( baseMaterial: THREE.MeshPhysicalMaterial, metalness: 0.6, roughness:0.3, uniforms, vertexShader: document.getElementById(v-shader).textContent, fragmentShader: document.getElementById(f-shader).textContent)script type=x-vertex id=v-shader uniform float u_time; void main() vec3 newPosition = position * sin(u_time); // csm_Position 必须修改 csm_Position = newPosition; glayerl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); /scriptscript type=x-fragment id=f-shader uniform vec2 u_resolution; void main() vec2 st = gl_FragCoord.xy / u_resolution; // csm_DiffuseColor 表示材质的原始颜色 csm_DiffuseColor = vec4(st.x / 0.6, st.y / 1.8, (st.x + st.y)/ 1.2, 1.0); /script"},{"title":"Cannon Tutorial 物理引擎","path":"/wiki/ThreeJs/Wael_05_cannon_tutorial.html","content":"原项目视频https://www.youtube.com/watch?v=xZM8UJqN1eY&t=907s cannon.js引入cannon dochttps://schteppe.github.io/cannon.js/ npm install cannon-es 模块引入： import * as CANNON from cannon-es World容器与Body实体CANNON.World cannon.js必须要创建一个World实例，相当于ThreeJs中必须存在一个Scene实例一样，World实例用于管理所有物体、约束、碰撞等物理元素const world = new CANNON.World( // 重力 gravity:new CANNON.Vec3(0,-9.89,0)) CANNON.Body CANNON.Body表示某个物体所对应的物理属性，CANNON.Body和Three.Mesh组合在一起，构成一个具有物理属性的物体CANNON 里 Mesh 表const planeBody = new CANNON.Body( mass: 1, shape:new CANNON.Plane())world.addBody(planeBody)将Body添加到world中之后，需要根据body每帧计算的值更新对应mesh的属性值：const stepTime = 1/60function animate() world.step(stepTime) // 推进wolrd planeMesh.position.copy(planeBody.position) planeMesh.quaternion.copy(planeBody.quaternion) renderer.render(scene, camera)根据这段代码，plane是一个质量为1的无限延长的平面，在向下的重力作用下，plane将会下坠： 物体碰撞水平平面 我们将平面水平放置（沿x轴旋转90度），作为静态物体，并且将平面的尺寸设置为30*30：const planeBody = new CANNON.Body( shape: new CANNON.Box(new CANNON.Vec3(15,15,0.5)), type:CANNON.BODY_TYPES.STATIC)groundBody.quaternion.setFromEuler(-Math.PI/2,0,0) 创建一个方形物体：（注意创建方形物体时，vec3的属性表示距物体中心点的位置）const boxGeo = new THREE.BoxGeometry(3, 3, 3)const boxMat = new THREE.MeshBasicMaterial( color:0x00ff00, wireframe:true)const boxMesh = new THREE.Mesh(boxGeo, boxMat)scene.add(boxMesh)///////////const boxBody = new CANNON.Body( shape: new CANNON.Box(new CANNON.Vec3(1.5, 1.5, 1, 5)), mass: 1, position:new CANNON.Vec3(1,20,0))world.addBody(boxBody)/////////function animate() //... boxMesh.position.copy(boxBody.position) boxMesh.quaternion.copy(boxBody.quaternion) //...再创建一个球体：const sphereGeo = new THREE.SphereGeometry(3)const sphereMat = new THREE.MeshBasicMaterial( color: 0xff00ff, wireframe:true,)const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat)scene.add(sphereMesh)////////////const sphereBody = new CANNON.Body( shape: new CANNON.Sphere(3), mass: 1, position:new CANNON.Vec3(0,15,0))world.addBody(sphereBody)///////////function animate() // ... sphereMesh.position.copy(sphereBody.position) sphereMesh.quaternion.copy(sphereBody.quaternion) // ... 运动属性 线性阻尼值的范围在0-1之间，值越大代表摩擦力越大：sphereBody.linearDamping = 0.3自旋角速度，自旋阻尼：boxBody.angularVelocity.set(10,0,0,0)boxBody.angularDamping = 0.3顺便一提，自旋角整得太大，方块会被创飞 物理材质材质 不同物理材质的物体接触时也会有不同的运动轨迹，也就是给每种物理材质赋予独有的一组运动属性,下面分别定义了平面、立方体、球体的材质const planePhysMat = new CANNON.Material()const boxPhysMat = new CANNON.Material()const spherePhysMat = new CANNON.Material()将材质和对应的Body联系在一起：const planeBody = new CANNON.Body( shape: new CANNON.Box(new CANNON.Vec3(15,15,0.5)), type: CANNON.BODY_TYPES.STATIC, material:planePhysMat)const boxBody = new CANNON.Body( shape: new CANNON.Box(new CANNON.Vec3(1.5, 1.5, 1, 5)), mass: 1, position: new CANNON.Vec3(1, 20, 0), material:boxPhysMat)const sphereBody = new CANNON.Body( shape: new CANNON.Sphere(3), mass: 1, position: new CANNON.Vec3(0, 15, 0), material:spherePhysMat) 相互作用 不同材质间相互作用，才能赋予运动以独特的物理属性，因此需要将不同的材质联系起来,下面的代码将立方体与平面的摩擦力设置为0，将球体与平面的弹跳系数设置为0.9const planeBoxContactMat = new CANNON.ContactMaterial( planePhysMat, boxPhysMat, friction:0 )const planeSphereContactMat = new CANNON.ContactMaterial( planePhysMat, spherePhysMat, restitution:0.9 // 回弹系数 )world.addContactMaterial(planeBoxContactMat)world.addContactMaterial(planeSphereContactMat) GLTF模型的碰撞这个部分踩坑无数，bug叠bug，难绷 要使物体间产生碰撞效果，首先要为碰撞物创建碰撞网格（Body），如何对GLTF模型创建碰撞网格，需要用到 CANNON.Trimesh我想要实现的效果是：一把钥匙模型从半空掉落到地板上使用CANNON.Trimesh，需要用到vertex和index两个数组，这两个数据源从gltf模型上都能取到：loader.load(assets/key.glb,gltf= key = gltf.scene.getObjectByName(Object_2) // 获取物体 key.scale.set(0.005,0.005,0.005) // 物体原模型过大，需要缩小 scene.add(key) const geo = key.geometry const keyShape = new CANNON.Trimesh( geo.attributes.position.array, // vertex geo.index.array // index ) keyBody = new CANNON.Body( mass:1, position:new CANNON.Vec3(0,3,0), shape:keyShape // 加载shape ) keyBody.quaternion.setFromEuler(Math.PI/2,0,0) world.addBody(keyBody))上面的代码里，将position和index数据直接取了出来，放入Trimesh中构建实体，但是还是不行，钥匙直接穿过平面掉落。chatGPT告诉我，之所以会出这个问题，是由于使用scale对模型进行缩小，但物体实际的position坐标依旧没有改变，我用Trimesh返回的顶点坐标信息创建了一个网格物体，发现它说的没错，顶点坐标依旧保持gltf模型刚被引入的尺寸:因此需要对原本的vertex进行手动缩放loader.load(assets/key.glb,gltf= gltf.scene.traverse(obj= if(obj.isMesh) obj.castShadow = true ) key = gltf.scene.getObjectByName(Object_2) // scale缩放 也可以在计算好scaledVertices之后， // 使用setAttribute对物体顶点进行更新 key.scale.set(0.005,0.005,0.005) scene.add(key) const geo = key.geometry let vertices = geo.attributes.position.array // 手动缩放 // for (let i = 0; i vertices.length; i += 3) // scaledVertices.push( // vertices[i] * 0.005, // vertices[i+1] * 0.005, // vertices[i+2] * 0.005, // ) // let scaledVertices = vertices.map(i=i*0.005) const keyShape = new CANNON.Trimesh(scaledVertices, geo.index.array) keyBody = new CANNON.Body( mass:1, position:new CANNON.Vec3(0,3,0), shape:keyShape ) keyBody.quaternion.setFromEuler(Math.PI/2,0,0) world.addBody(keyBody))手动缩放后，Shape和物体原本网格应该保持一致，试了一下，模型还是无限向下掉（shiiiiiiiit）这时我隐约觉得可能不是我用于构建TriMesh的数据有问题，于是我引用了一个普通盒子模型的vertex和index，发现Trimesh果然还是往下掉，和顶点、索引数据无关。上网搜了一下，发现原来这是CANNON.Trimesh的一个官方bug：CANNON.Trimesh构建的不规则Shape只能和PlaneSphere类型的Shape进行碰撞好吧……于是我把碰撞平面的Shape类型从Box改成了Plane，终于成功嘞const planeGeo = new THREE.PlaneGeometry(12,12)const planeMat = new THREE.MeshPhysicalMaterial( color:0xffffff, roughness:0,)const planeMesh = new THREE.Mesh(planeGeo, planeMat)planeMesh.rotation.x = Math.PI/2planeMesh.receiveShadow = truescene.add(planeMesh)const planeBody = new CANNON.Body( shape:new CANNON.Plane(), type:CANNON.BODY_SLEEP_STATES)planeBody.quaternion.setFromEuler(-Math.PI/2, 0,0)world.addBody(planeBody)"},{"title":"How to Create Objects on MouseClick？鼠标点击创建物体","path":"/wiki/ThreeJs/Wael_06_mouse_click_create_object.html","content":"原项目视频https://www.youtube.com/watch?v=mTPDaw2piKg&list=PLjcjAqAnHd1EIxV4FSZIiJZvsdrBc1Xho&index=7 实现原理Threejs中不提供获取鼠标在空间中位置的api因此作者研究出的方法如图所示：需要两个步骤：根据相机位置，创建一个一直正面对着相机的平面以相机和原点连线为法线，原点为交点，创建平面使用threejs提供的setFromNormalAndCoplanarPoint方法根据鼠标和屏幕的交点，判断点击坐标获取相机和鼠标连线与辅助平面的交点，即鼠标点击坐标 代码实现坐标计算 const mouse = new THREE.Vector2()const planeNormal = new THREE.Vector3()const plane = new THREE.Plane()const raycaster = new THREE.Raycaster()const interSectionPoint = new THREE.Vector3()window.onmousemove = function(e) mouse.x = e.offsetX/window.innerWidth*2 - 1 mouse.y = 1- e.offsetY/window.innerHeight*2 // 创建辅助平面 planeNormal.copy(camera.position) plane.setFromNormalAndCoplanarPoint(planeNormal, scene.position) // 射线交点 raycaster.setFromCamera(mouse,camera) raycaster.ray.intersectPlane(plane, interSectionPoint) 物体添加 window.onclick = function(e) const sphereGeo = new THREE.SphereGeometry(0.2) const sphereMat = new THREE.MeshStandardMaterial( color:0xffffff*Math.random(), metalness:0, roughness:0 ) const sphereMesh = new THREE.Mesh(sphereGeo,sphereMat) sphereMesh.position.copy(interSectionPoint) scene.add(sphereMesh) 非全屏的raycaster坐标计算全屏时，画布的宽高取的是：window.innerWidthwindow.innerHeight非全屏时，需要将大部分涉及到宽高的值替换成：dom.clientWidthdom.clientHeight// 鼠标射线const mousePosition = new THREE.Vector2()const raycast = new THREE.Raycaster()window.onmousedown = e = mousePosition.x = e.offsetX/renderBox.clientWidth*2 -1 mousePosition.y = 1- e.offsetY/renderBox.clientHeight*2 raycast.setFromCamera(mousePosition, camera) const intersections = raycast.intersectObjects(scene.children) if (intersections[0] intersections[0].object.isObject3D) intersections[0].object.layers.toggle(BLOOM_LAYER)"},{"title":"How to Create Bouncing Ball on MouseClick？鼠标点击创建弹跳小球","path":"/wiki/ThreeJs/Wael_07_create_bouncing_ball_on_click.html","content":"原项目视频https://www.youtube.com/watch?v=mTPDaw2piKg 要实现鼠标点击掉落小弹球，实际上就是鼠标点击创建小球 和 cannon物理引擎的结合，需要注意的是，每一个新建的小球都需要绑定一个CANNON.Body，需要在创建的同时留好数据的访问入口， 鼠标时间控制小球创建 const mouse = new THREE.Vector2()const planeNormal = new THREE.Vector3()const plane = new THREE.Plane()const raycaster = new THREE.Raycaster()const interSectionPointer = new THREE.Vector3()const BallList = []window.onmousemove = function(e) mouse.x = e.offsetX/window.innerWidth*2 - 1 mouse.y = 1 - e.offsetY/window.innerHeight*2 planeNormal.copy(camera.position) plane.setFromNormalAndCoplanarPoint(planeNormal, scene.position) raycaster.setFromCamera(mouse,camera) raycaster.ray.intersectPlane(plane, interSectionPointer)window.onclick = function(e) const sphereGeo = new THREE.SphereGeometry(0.2) const sphereMat = new THREE.MeshStandardMaterial( color:0xffffff*Math.random(), metalness:0, roughness:0 ) const sphereMesh = new THREE.Mesh(sphereGeo,sphereMat) sphereMesh.position.copy(interSectionPointer) scene.add(sphereMesh) sphereMesh.castShadow = true const ballBody = new CANNON.Body( shape:new CANNON.Sphere(0.2), mass:1, position:interSectionPointer, material:ballPhyMat ) world.addBody(ballBody) BallList.push([sphereMesh,ballBody]) 材质添加 const world = new CANNON.World( gravity:new CANNON.Vec3(0,-9.89,0))const planePhyMat = new CANNON.Material()const ballPhyMat = new CANNON.Material()const planeBallContactMat = new CANNON.ContactMaterial( planePhyMat, ballPhyMat, restitution:0.9 )world.addContactMaterial(planeBallContactMat) 动画控制 const timeStep = 1/60function animate() world.step(timeStep) groundMesh.position.copy(groundBody.position) groundMesh.quaternion.copy(groundBody.quaternion) BallList.forEach(([mesh,body])= mesh.position.copy(body.position) mesh.quaternion.copy(body.quaternion) ) renderer.render(scene, camera);renderer.setAnimationLoop(animate); 阴影锯齿 需要注意的是：如果不做任何处理，此处的球体阴影会因为锯齿变得参差不齐：渲染器创建时有抗锯齿选项antialias，设置为true的话抗锯齿效果会好一些：const renderer = new THREE.WebGLRenderer(antialias: true);看视频作者的操作，是将光源的shadow.mapSize属性进行放大：pointLight.shadow.mapSize.width = 1024pointLight.shadow.mapSize.height = 1024效果确实好了很多。 真的有这么Q弹吗？"},{"title":"Subdivide Plane 选中网格","path":"/wiki/ThreeJs/Wael_08_subdivide_plane.html","content":"鼠标选中网格高亮要实现的效果是：网格上的高亮块时刻跟踪鼠标的移动。 可以分成三步实现： 获取鼠标在网格上的坐标A 根据坐标A获取网格上方块的坐标B 高亮平面的坐标移动到坐标B位置 实际显示的网格是THREE.GridHelper（网格助手），需要创建一个不可见的辅助平面Plane，Plane的尺寸和位置和grid完全一致，鼠标在移动时，计算相机-鼠标raycaster射线和Plane的交点point。point需要经过偏移得到高亮块绘制位置：floor() 向下取整addScale(num) xz轴正向偏移0.5y轴为0创建辅助平面和高亮平面const plane = new THREE.Mesh( new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial( visible:false, ))plane.rotateX(-Math.PI/2)scene.add(plane)const highLight = new THREE.Mesh( new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial( color: 0xffffff ))highLight.rotateX(-Math.PI/2)highLight.position.set(0.5, 0, 0.5)scene.add(highLight)选中移动高亮块：const mousePosition = new THREE.Vector2()const raycaster = new THREE.Raycaster()window.onmousemove = e = mousePosition.x = e.offsetX / window.innerWidth * 2 - 1 mousePosition.y = 1 - e.offsetY / window.innerHeight * 2 raycaster.setFromCamera(mousePosition, camera) const interSections = raycaster.intersectObject(plane) if (interSections[0]) const position = interSections[0].point.floor().addScalar(0.5) highLight.position.set(position.x, 0, position.z) 创建物体鼠标点击事件中添加创建物体逻辑，但是在物体创建之前需要先判断当前网格内是否已经存在物体：使用的是坐标匹配的方式。为了做提示，鼠标移动到已经存在物体的网格中时，需要将网格标红。const mousePosition = new THREE.Vector2()const raycaster = new THREE.Raycaster()const objects = []const isExist = () = objects.find(obj = obj.position.x === highLight.position.x obj.position.z === highLight.position.z)window.onmousemove = e = mousePosition.x = e.offsetX / window.innerWidth * 2 - 1 mousePosition.y = 1 - e.offsetY / window.innerHeight * 2 raycaster.setFromCamera(mousePosition, camera) const interSections = raycaster.intersectObject(plane) if (interSections[0]) const position = interSections[0].point.floor().addScalar(0.5) highLight.position.set(position.x, 0, position.z) highLight.material.color.set( isExist()?0xff0000:0xffffff ) const sphereMesh = new THREE.Mesh( new THREE.SphereGeometry(0.4, 4, 2), new THREE.MeshBasicMaterial( color: 0xFFEF00, wireframe:true ))window.onmousedown = e = if (!isExist()) const sphere = sphereMesh.clone() sphere.position.copy(highLight.position) scene.add(sphere) objects.push(sphere) highLight.material.color.set(0xff0000) 动画效果高亮块闪烁效果控制透明度物体旋转浮动效果function animate(time) highLight.material.opacity = 1 + Math.sin(time / 120) objects.forEach(obj = obj.rotation.x = time / 1000 obj.rotation.z = time / 1000 obj.position.y = 0.5 + 0.5 * Math.abs(Math.sin(time/1000)) ) renderer.render(scene, camera);"},{"title":"GLTF Material 与 Skeleton","path":"/wiki/ThreeJs/Wael_09_model_material.html","content":"修改GLTF的材质 Clippart美工素材网站https://openclipart.org/ 一个有很多有趣的建模模型网站——PATREONhttps://quaternius.com/ threejs中支持通过object的名字获取到模型子类：getObjectByName通过这种方式就可以单独对导入模型的材质进行修改,通过将模型导入threejs官方的editor平台，可以更加方便的获知模型的相关信息：使用gui对模型子类进行实时操作，可以实现一个捏驴的功能：const gui = new dat.GUI()const options = Main: 0x787A79, Main_Light: 0xb9b9b9, Main_Dark: 0x383838, Hooves: 0x46423c, Hair: 0x383838, Muzzle: 0x3d3426, Eye_Dark: 0x181818, Eye_White: 0xe0e0e0const gltfLoader = new GLTFLoader()const donkeyUrl = new URL(../asserts/Donkey.gltf, import.meta.url)gltfLoader.load(donkeyUrl.href, gltf = const model = gltf.scene; scene.add(model) gui.addColor(options, Main).onChange(newVal = model.getObjectByName(Cube).material.color.set(newVal) ) gui.addColor(options, Main_Light).onChange(newVal = model.getObjectByName(Cube_1).material.color.set(newVal) ) gui.addColor(options, Main_Dark).onChange(newVal = model.getObjectByName(Cube_2).material.color.set(newVal) ) gui.addColor(options, Hooves).onChange(newVal = model.getObjectByName(Cube_3).material.color.set(newVal) ) gui.addColor(options, Hair).onChange(newVal = model.getObjectByName(Cube_4).material.color.set(newVal) ) gui.addColor(options, Muzzle).onChange(newVal = model.getObjectByName(Cube_5).material.color.set(newVal) ) gui.addColor(options, Eye_Dark).onChange(newVal = model.getObjectByName(Cube_6).material.color.set(newVal) ) gui.addColor(options, Eye_White).onChange(newVal = model.getObjectByName(Cube_7).material.color.set(newVal) ), undefined, err = console.error(err))赛博限定款驴 修改GLTF的骨骼gltf模型由许多骨架组成，类似children中包含的子实体，也需要通过 getObjectByName 选中单个骨架。const params = Neptune_01: 0, // 海王星 Uranus_02: 0, // 天王星 Saturn_03: 0, // 土星 Jupiter_04: 0, // 木星 Mars_05:0 , // 火星 Earth_06:0 , // 地球 Venus_07:0 , // 金星 Mercury_08:0 , // 水星 Sun_09:0 , // 太阳const loader = new GLTFLoader()let modelloader.load(assets/solar_system_model_orrery.glb,gltf= model = gltf.scene model.traverse(obj= if(obj.isMesh) obj.castShadow = true ) model.position.set(0, 0.732,0) model.scale.set(3,3,3) scene.add(model) Object.entries(params).forEach(([key,value])= gui.add(params,key,0,2*Math.PI).onChange(v= // 通过名称值获取骨架进行旋转 model.getObjectByName(key).rotation.y = v check() ) )) 控制Bone实现视线跟随鼠标效果 实现视线追踪鼠标，实际就是修改头部眼部的焦点（lookAt）从模型中抽取出头部眼部模型使用光线追踪器获取鼠标的3D坐标，参考 鼠标点击创建物体let knightModellet knightHead// 加载骑士loader.load(assets/medieval_knight.glb,gltf= knightModel = gltf.scene // 获取模型的头部 knightHead = knightModel.getObjectByName(mixamorigHead_06))// raycaster视线交点let target = new THREE.Vector3()target.z = 4const raycaster = new THREE.Raycaster()const raycaster_select = new THREE.Raycaster() // 选择物体用的raycasterconst mouse = new THREE.Vector2()const planeNormal = new THREE.Vector3()const interSectionPoint = new THREE.Vector3()const plane = new THREE.Plane()let intersections = []window.onmousemove = e = mouse.x = e.offsetX / window.innerWidth * 2 -1 mouse.y = 1- e.offsetY/window.innerHeight*2 planeNormal.copy(camera.position) plane.setFromNormalAndCoplanarPoint(planeNormal, scene.position) raycaster.setFromCamera(mouse, camera) // 扫描视线点 raycaster.ray.intersectPlane(plane,interSectionPoint) target.copy(interSectionPoint) target.z = 4 target.y = Math.max(interSectionPoint.y, 1)// loop函数let clock = new THREE.Clock()function animate(time) if(knightModel) knightHead.lookAt(target) // 移动模型头部的坐标 renderer.render(scene, camera);"},{"title":"Realistic Scenes 真实场景","path":"/wiki/ThreeJs/Wael_11_realistic_scenes.html","content":"原项目视频https://www.youtube.com/watch?v=6XvqaokjuYU&list=PLjcjAqAnHd1EIxV4FSZIiJZvsdrBc1Xho&index=11 maxroz HDRIhttps://www.maxroz.com/hdri HDRTone MappingGamma CorrectionsRGB Color SpaceHDR什么是DR？ DR全称Dynamic Range，表示传感器或显示屏能够捕捉图片中最亮和最暗点之间的差异，设备能能够捕捉的DR值越高，图片显示的细节程度就越高。HDR全称High Dynamic Range，要制作一张HDR图片（即光影分辨率较高的图片），摄影师需要先拍一张中间调的图片，然后拍几张亮度不同的图片，通过像Adobe Lightroom这样的软件合成在一起。 Tone MappingHDR和EXR格式的图片文件包含的数据量更大，因此选用1632bit编码，但是大多数显示屏都是8bit10bit的，因此在显示这些图片时会丢失很多细节。想要解决这个问题：可以用Photoshop等专业图像处理软件也可以使用Tone Map映射算法Tone Map映射方法能够解决这个问题，它可以使用算法映射的方式，使8bit编码中能够蕴含1632bit编码的信息 Gamma Correction随着实际亮度的增高，人眼对亮度的感受往往更弱，这是因为人眼对黑暗的反应比对光的反应更加敏感。与人眼相反，显示屏显示出的亮度往往要高于实际亮度Gamma Correction就是对这种差异进行校正的方法：在要显示的图片亮度上使用人眼反曲线调整，这样最终显示出来的亮度会被校正到线性关系上Gamma Correction的方法在jpegpng等格式的图片内部完成，因此这些格式的图片数据使用反曲线格式保存，要更亮一些。而HDR、EXR类型的文件使用的仍然是线性格式保存，因为大部分CGI、游戏渲染器都需要线性工作流程，因此使用线性格式图片进行开发。 sRGB Color SpaceThreeJs中渲染HDR图像，需要通过图像的原始颜色（sRGB）计算出像素颜色，再根据编码算法进行Gamma CorrectionsRGB指的是最纯正的RGB颜色 场景渲染环境加载 为scene添加360°HDR背景图，需要注意以下操作：使用 RGBELoader 加载图片材质的映射方式应为 EquirectangularReflectionMapping需要将渲染器加载图片的编码格式配置成 sRGBEncoding0.152.0版本的threejs默认是sRGBEncoding格式的在这之前的版本中默认值都是LinearEncoding编码格式将ToneMapping算法配置成ACESFilmicToneMapping适当调整ToneMapping曝光率属性import RGBELoader from three/examples/jsm/loaders/RGBELoaderrenderer.outputEncoding = THREE.sRGBEncodingrenderer.toneMapping = THREE.ACESFilmicToneMappingrenderer.toneMappingExposure = 1.8const backgroundUrl = new URL(../asserts/kitchen.hdr,import.meta.url)const rgbeLoader = new RGBELoader()rgbeLoader.load(backgroundUrl.href, texture = texture.mapping = THREE.EquirectangularReflectionMapping scene.background = texture) 环境加载 环境贴图可以将物体放置在指定的环境光下渲染，无需外加光源，可以使用全局环境配置的方式：scene.environment = texture也可以单独对物体进行环境光贴图：const sphere = new THREE.Mesh( new THREE.SphereGeometry(3,50,50), new THREE.MeshStandardMaterial( roughness: 0, metalness: 1, envMap:texture // 贴图属性 ))"},{"title":"如何导入从Sketchfab上下载的模型","path":"/wiki/ThreeJs/Wael_12_import_sketchfab_model.html","content":"Parcel静态文件打包使用parcel打包前端项目时，如果涉及到资源文件，需要使用import的方式一一导入，如果文件很多，导入的代码需要写上很多。可以安装另一个包：parcel-reporter-static-files-copyhttps://www.npmjs.com/package/parcel-reporter-static-files-copyhttps://www.npmjs.com/package/parcel-reporter-static-files-copy安装好之后，在根目录下创建static目录，将静态资源放在里面，再次parcel打包之后，dist文件中会出现与static对应的目录和资源文件 模型导入模型导入之后的渲染效果很暗，即使添加了光源也没有效果，一般导入模型后会添加环境贴图：import GLTFLoader from three/examples/jsm/loaders/GLTFLoaderimport RGBELoader from three/examples/jsm/loaders/RGBELoaderconst rgbeLoader = new RGBELoader()const gltfLoader = new GLTFLoader()let carrgbeLoader.load(./assets/kitchen.hdr, texture = texture.mapping = THREE.EquirectangularReflectionMapping scene.environment = texture gltfLoader.load(./assets/1975_porsche/scene.gltf, gltf = car = gltf.scene scene.add(car) ))"},{"title":"如何使用gsap控制相机运动","path":"/wiki/ThreeJs/Wael_14_camera_move.html","content":"原项目视频https://www.youtube.com/watch?v=O2ouLOL6C4c GSAPhttps://gsap.com/https://gsap.com/动画就是物体随着时间的变化运动轨迹的变化，相当于一系列点位，GSAP就是能计算出运动点位的动画库，使用GSAP对THREE的基本元素进行动画控制非常简单，只需要指定需要变化的属性、属性目标值、持续时间等等基本参数即可,gsap中的timeline类型链式添加动画更加方便const tl = gsap.timeline()const duration = 6const ease = ease tl.to(camera.position, x:0, y:0, z:19.5, duration, ease, onUpdate:function() camera.lookAt(0,0,0) ).to(camera.position, x:-15, y:24, z:0, duration, ease, onUpdate:function() camera.lookAt(0,0,0) ).to(camera.position, x:6, y:-10, z:0, duration, ease, onUpdate:function() camera.lookAt(0,0,0) ,-2) FirstPersonControls 第一人称相机控制器 gsap可以控制相机做各种视角运动（运镜），但是要想得到不错的效果，需要抓住相机拍摄的关键角度和坐标，这些关键点的参数如何获取？可以使用FirstPersonControls，第一人称相机控制器，模拟相机运动，相当于踩点，记录下几个关键的点位。import FirstPersonControls from three/examples/jsm/controls/FirstPersonControls.js;const controls = new FirstPersonControls(camera, renderer.domElement)controls.movementSpeed = 8controls.lookSpeed = 0.08window.onmouseup = e = // 参数打印 console.log(camera.position, camera.rotation)const clock = new THREE.Clock()function animate() controls.update(clock.getDelta()) renderer.render(scene, camera);然后使用gsap在这些点位之间做连贯运动：let progress = 0window.onmousedown = e= switch (progress%9) case 0: cameraMovement(x:1.64, y :0.79, z:-0.16) cameraRotation(x:0.83, y :-1.17, z:0.79) break; case 1: cameraMovement(x:1.35, y :0.83, z:-5.6) cameraRotation(x:0.43, y :0.13, z:-0.06) break; case 2: cameraMovement(x:3.04, y :-0.17, z:-6.33) cameraRotation(x:3, y :-0.9, z:3.03) break; case 4: cameraMovement(x:2.13, y :0.89, z:2.04) cameraRotation(x:2.85, y :-0.99, z:2.89) break; case 5: cameraMovement(x:-0.42, y :-0.13, z:2.11) cameraRotation(x:2.88, y :-0.09, z:3.11) break; case 6: cameraMovement(x:-1.04, y :0.36, z:0.18) cameraRotation(x:2.41, y :1.4, z:-2.42) break; case 7: cameraMovement(x:-0.84, y :0.58, z:-4.4) cameraRotation(x:0.11, y :0.83, z:-0.08) break; case 8: cameraMovement(x:-0.38, y :0.03, z:-1.57) cameraRotation(x:1.57, y :0.08, z:-1.62) break; progress++"},{"title":"如何显示资源加载进度","path":"/wiki/ThreeJs/Wael_13_loading_screen.html","content":"使用到的模型地址 THREE.LoadingManagerLoadingManager实例配置到Loader中，可以用来监控资源加载的几种状态：onStartonLoadonProgress参数:(url资源地址, loaded已加载数量, total全部需要加载的资源数量)onError 资源进度条主要依靠onProgress和onLoad两个阶段，onProgress反馈加载进度onLoad加载完毕时关闭进度条界面style * padding:0; margin:0; .progress-content position:absolute; left:0; top:0; width: 100%; height:100vh; background-color:rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; flex-direction: column; .progress-label font-size: 2rem; color:#fff; margin-bottom:3px; #progress-bar width:30%; /stylediv class=progress-content div class=progress-labelLoading.../div progress id=progress-bar value=0 max=100 //divconst loadingManager = new THREE.LoadingManager()const progressBar = document.getElementById(progress-bar)loadingManager.onProgress = (url, loaded, total) = progressBar.setAttribute(value, loaded/total*100)const progressContent = document.querySelector(.progress-content)loadingManager.onLoad = () = progressContent.style.display = noneconst gltfLoader = new GLTFLoader(loadingManager)const rgbeLoader = new RGBELoader(loadingManager)rgbeLoader.load(./assets/MR_INT-006_LoftIndustrialWindow_Griffintown.hdr, texture = texture.mapping = THREE.EquirectangularReflectionMapping scene.environment = texture gltfLoader.load(./assets/mars_one_mission/scene.gltf, gltf = scene.add(gltf.scene) ,undefined,err=console.error(err)))"},{"title":"Cloning And Animating Models Loaded From glTF Files. 克隆动画GLTF模型","path":"/wiki/ThreeJs/Wael_10_cloning_models.html","content":"要实现克隆动画模型的功能，需要注意以下几点：克隆GLTF模型需要使用SkeletonUtils库，进行特殊模型复制对于每一个模型都要创建单独的mixer控制动画在读取模型时需要将其作为模具全局存储：const gltfLoader = new GLTFLoader()const shibaInuURL = new URL(../asserts/ShibaInu.gltf, import.meta.url)let shibaInuModelgltfLoader.load(shibaInuURL.href, gltf = gltf.scene.scale.set(0.3, 0.3, 0.3) shibaInuModel = gltf,undefined,err=console.error(err))鼠标点击平面时，使用SkeletonUtils克隆，并创建相应mixer动画控制器：const mousePosition = new THREE.Vector2()const raycaster = new THREE.Raycaster()const objects = []const mixers = []const isExist = () = objects.find(obj = obj.position.x === highlight.position.x obj.position.z === highlight.position.z)function getInterSections(e) mousePosition.x = e.offsetX / window.innerWidth * 2 - 1 mousePosition.y = 1 - e.offsetY / window.innerHeight * 2 raycaster.setFromCamera(mousePosition, camera) return raycaster.intersectObject(plane)window.onmousemove = e = let interSections = getInterSections(e) if (interSections[0]) let position = interSections[0].point.floor().addScalar(0.5) highlight.position.set(position.x, 0, position.z) highlight.material.color.set(isExist() ? 0xff0000 : 0xffffff) window.onmousedown = e = if (isExist() || !getInterSections(e)[0]) return let obj = SkeletonUtils.clone(shibaInuModel.scene) scene.add(obj) obj.position.set(highlight.position.x, 0, highlight.position.z) objects.push(obj) const mixer = new THREE.AnimationMixer(obj) const action = mixer.clipAction( THREE.AnimationClip.findByName(shibaInuModel.animations, Idle_2) ) action.play() mixers.push(mixer) highlight.material.color.set(0xff0000)在动画中对每一个mixer进行更新：let clock = new THREE.Clock()function animate(time) const delta = clock.getDelta() mixers.forEach(mixer = mixer.update(delta) ) highlight.material.opacity = Math.abs(Math.sin(time/120)) renderer.render(scene, camera);"},{"title":"使用yuka控制物体运动","path":"/wiki/ThreeJs/Wael_15_yuka.html","content":"https://mugen87.github.io/yuka/https://mugen87.github.io/yuka/ Yuka游戏中存在很多可以交互的物体，沿固定路径前进的NPC、主动追踪角色的怪物、巡逻搜查区域的敌人，这些有物体一般统称Entity，具有不同程度的AI能力，yuka.js中提供了很多实现游戏ai的方法。 要实现实体沿固定路线移动，需要做如下准备：创建一个实体Mesh（肉体）创建Mesh对应的Vehicle（灵魂）绑定Mesh和Vehicle创建路径path绑定路径和Vehicle创建实体管理器，管理实体随时间更新实体首先，创建一个圆锥形的实体，注意需要关闭实体矩阵的自动更新选项。const vehicleGeo = new THREE.ConeGeometry(0.1, 0.8, 8)vehicleGeo.rotateZ(Math.PI/2)const vehicleMat = new THREE.MeshNormalMaterial()const vehicleMesh = new THREE.Mesh(vehicleGeo, vehicleMat)vehicleMesh.matrixAutoUpdate = falsescene.add(vehicleMesh)创建Vehicle，将更新后的entity与mesh进行同步const vehicle = new YUKA.Vehicle()vehicle.maxSpeed = 2vehicle.setRenderComponent(vehicleMesh, sync)function sync(entity, renderComponent) renderComponent.matrix.copy(entity.worldMatrix)创建循环路径const path = new YUKA.Path()path.loop = truepath.add(new YUKA.Vector3(0,0,6))path.add(new YUKA.Vector3(-4,0,4))path.add(new YUKA.Vector3(-6,0,0))path.add(new YUKA.Vector3(-4,0,-4))path.add(new YUKA.Vector3(0,0,1))path.add(new YUKA.Vector3(4,0,-4))path.add(new YUKA.Vector3(6,0,0))path.add(new YUKA.Vector3(4, 0, 4))vehicleMesh.position.copy(path.current)const points = path._waypoints.map(position = [position.x, position.y, position.z]).flat()const lineGeo = new THREE.BufferGeometry()lineGeo.setAttribute(position, new THREE.Float32BufferAttribute(points, 3))const lineMat = new THREE.LineBasicMaterial()const lineMesh = new THREE.LineLoop(lineGeo, lineMat)scene.add(lineMesh)const followPathBehovior = new YUKA.FollowPathBehavior(path, 0.5)vehicle.steering.add(followPathBehovior)const onePathBehavior = new YUKA.OnPathBehavior(path)onePathBehavior.radius = 0vehicle.steering.add(onePathBehavior)添加实体管理器const entityManager = new YUKA.EntityManager()entityManager.add(vehicle)const clock = new YUKA.Time()function animate() let delta = clock.update().getDelta() entityManager.update(delta) renderer.render(scene, camera); YUKA控制GLTF模型gltf模型加载后，由于将matrixAutoUpdate关闭，无法对modelMatrix进行修改，因此不能通过model.scale.set()的方式进行缩放，需要通过YUKA.Vehicle提供的scale属性进行缩放gltfLoader.load(/assets/Debris_BrokenCar.gltf, gltf = let model = gltf.scene model.matrixAutoUpdate = false scene.add(model) vehicle.scale = new THREE.Vector3(0.5,0.5,0.5) vehicle.setRenderComponent(model, sync))const vehicle = new YUKA.Vehicle()vehicle.maxSpeed = 3function sync(entity, renderComponent) renderComponent.matrix.copy(entity.worldMatrix) 物体寻路 SeekBehavior使用yuka做出A物体寻找B物体的效果，需要使用到SeekBehavior类需要指定目标物体的坐标，将SeekBehavior添加到动作主体中：创建seek主体const vehicle = new YUKA.Vehicle()vehicle.maxSpeed = 3vehicle.setRenderComponent(vehicleMesh, sync)vehicle.position.set(-6,0,2)创建target实体const target = new YUKA.GameEntity()target.setRenderComponent(targetMesh, sync)添加追踪行为const seekBehavior = new YUKA.SeekBehavior(target.position)vehicle.steering.add(seekBehavior)添加实体管理器并逐帧更新const entityManager = new YUKA.EntityManager()entityManager.add(vehicle)entityManager.add(target)const time = new YUKA.Time()function animate() let delta = time.update().getDelta() entityManager.update(delta) renderer.render(scene, camera); 物体抵达 ArriveBehaviorArriveBehavior和SeekBehavior类似，Arrive在到达目的地后停止，Seek依旧保持搜寻，创建Arrive行为需要3个参数：target 目的地deceleration 减速率tolerance 容差值const arriveBehavior = new YUKA.ArriveBehavior(target.position,1,3)vehicle.steering.add(arriveBehavior) yuka控制物体移动到鼠标处 控制角色移动到鼠标点击处的游戏有很多，使用yuka的ArriveBehavior，结合raycaster获取鼠标坐标，就能实现这个功能。基本思路就是：给追踪角色绑定Vehicle实体给被追踪物体绑定GameEntity实体绑定追踪关系，激活实体管理器创建辅助平面，监听鼠标点位点击屏幕，切换被追踪物坐标这里给追踪的坦克模型添加了一个颠簸动画，直接添加到vehicle或者target上会导致追踪物体上下翻滚的问题，这里需要给vehicle外套一层group，使用group控制上下颠簸效果，追踪物位置依然由vehicle控制const gltfLoader = new GLTFLoader()const group = new THREE.Group()gltfLoader.load(/assets/Tank.gltf,gltf= gltf.scene.getObjectByName(Cylinder010_1).material.color.set(0x5d3c1d) gltf.scene.getObjectByName(Cylinder010_2).material.color.set(0xc3b598) gltf.scene.matrixAutoUpdate = false group.add(gltf.scene) scene.add(group) vehicle.setRenderComponent(gltf.scene, sync))const time = new YUKA.Time()function animate(t) let delta = time.update().getDelta() entityManager.update(delta) group.position.y = 0.05 * Math.sin(t/100) renderer.render(scene, camera); 物体逃避 Flee BehaviorFleeBehavior FleeBehavior的用法和其他行为相似，需要2个参数：targetpanicDistance 规避范围const fleeBehavior = new YUKA.FleeBehavior(target.position,5)vehicle.steering.add(fleeBehavior) 障碍物规避 Orbstacle AvoidanceObstacleAvoidanceBehavior 执行障碍物规避，需要知道一些关键条件：规避主体的碰撞体积被规避物体列表，以及它们对应的碰撞体积计算碰撞体积需要配合Three.js中Geometry类型的computeBoundingSphere一起使用。const geo = new BoxGeometry(1,1,1)geo.computeBoundingSphere()const mat = new THREE.MeshBasicMaterial()const mesh = new THREE.Mesh(geo, mat)const vehicle = new YUKA.Vehicle()vehicle.setRenderComponent(mesh, sync)vehicle.boundingRadius = geo.boundingSphere.radius按照上面的计算方式，计算出规避物和障碍物的碰撞体积// 碰撞物const vehicleGeo = new THREE.ConeBufferGeometry(0.2,0.8,8)vehicleGeo.computeBoundingSphere()vehicleGeo.rotateX(Math.PI/2)const vehicleMat = new THREE.MeshNormalMaterial()const vehicleMesh = new THREE.Mesh(vehicleGeo, vehicleMat)vehicleMesh.matrixAutoUpdate = falsescene.add(vehicleMesh)const vehicle = new YUKA.Vehicle()vehicle.setRenderComponent(vehicleMesh, sync)vehicle.boundingRadius = vehicleGeo.boundingSphere.radius// 障碍物const obstacleGeo = new THREE.BoxGeometry(1,1,1)obstacleGeo.computeBoundingSphere()const obstacleMesh = new THREE.Mesh( obstacleGeo, new THREE.MeshStandardMaterial(color:0xffaa00))const obstacleMesh1 = obstacleMesh.clone()obstacleMesh1.position.set(-7,0,0)scene.add(obstacleMesh1)const obstacle1 = new YUKA.GameEntity()obstacle1.position.copy(obstacleMesh1.position)obstacle1.boundingRadius = obstacleGeo.boundingSphere.radius// obstacle2...// obstacle3...最终绑定ObstacleAvoidanceBehaviorconst obstacleAvoidanceBehavior = new YUKA.ObstacleAvoidanceBehavior([ obstacle1, obstacle2, obstacle3,])vehicle.steering.add(obstacleAvoidanceBehavior) 引入的gltf模型无法使用getBoundingSphere方式直接计算包围盒，GPT说可以遍历gltf的每一个node计算包围盒（听上去像个馊主意）试错试出一个boundingRadius之后，汽车绕开障碍物的轨迹非常僵硬，需要增加运行轨迹的smooth程度：const smoother = new YUKA.Smoother(30)vehicle.smoother = smoother"},{"title":"使用yuka控制实体运动（二）","path":"/wiki/ThreeJs/Wael_16_使用yuka控制实体运动2.html","content":"物体漫游 WanderBehavioryuka.WanderBehavior 能够实现物体漫游运动漫游属性如下：radius 漫游半径distance 漫游圆圈投射到实体前方的距离jitter 每帧沿球面最大位移量（没搞懂这三个量的关系）添加漫游行为const wanderBehavior = new YUKA.WanderBehavior(3,10,10)vehicle.steering.add(wanderBehavior)这里提到了Yuka.Vehicle类实例进行旋转的方式：vehicle.rotation.fromEuler(0, 2 * Math.PI * Math.random(), 0) 问题 从外界导入的gltf模型尺寸不合适，有时需要使用scale进行缩放，vehicle.scale = new YUKA.Vector3(0.01, 0.01, 0.01)缩放之后，WonderBehavior的参数似乎也发生了变化，常见的问题是：在模型缩小之后，物体的漫游半径过于庞大，导致模型朝起始方向无限漫游。这个问题目前还没解决。 AnimationGroup 对于大量需要执行相同动画的模型，比起对每个模型都创建一个控制动画的Mixer，可以直接创建一个动画组AnimationGroupconst animationGroup = new THREE.AnimationObjectGroup()const mixer = new THREE.AnimationMixer(model)const action = mixer.clipAction( TRHEE.AnimationClip.findByName(originModel.animations,animate_name))action.play()for(let i = 0;i100;i++) const model = SkeletonUtils.clone(originModel) animationGroup.add(model) 追赶行为 PursuitBehaviorPursuit追赶是SeekBehavior的另一种形式，区别在于Seek行为中，追随物体会严格跟随被追随物体的轨迹，Persuit行为中追随物体会引入轨迹预测机制，提前进行拦截追随动作的添加：const pursuitBehavior = new YUKA.PursuitBehavior(evader, 0)pursuit.steering.add(pursuitBehavior)目标物体的轨迹：const elapsed = time.getElapsed()target.x = Math.cos(elapsed) * Math.sin(elapsed * 0.2) * 6target.z = Math.sin(elapsed * 0.8) * 6PursuitBehavior的第二个参数predictionFactor用于控制预测的程度。predictionFactor=0时，就相当于SeekBehaviorpredictionFactor=5 物体跟随 OffsetPursuitBehavior物体跟随与追赶的区别在于：物体跟随者会和被跟随者保持一定的距离，或者说是相对被跟随者有一个相对坐标。const offsetPursuitBehavior = new YUKA.OffsetPursuitBehavior(leader, offset)follower.steering.add(offsetPursuitBehavior)如果跟随者的速度跟不上跟随者，就会出现相对坐标变形的情况，解决这个问题的方式就是给跟随者一个很高的速度，能够允许它时刻跟随上leader，并保持相对距离。变形情况跟随物体加速防止变形 物体干预 AlignmentCohesionSeparation之前在wanderBehavior漫游行为中，实现了50个实体自由漫游的效果，但是这50个实体相互之间没有任何作用，yuka中提供了一些可以使实体之间相互干预的类：Alignment 同化能够将实体临近圈neightborhoodRadius范围内的其他实体同化Cohesion 聚合力Separation 斥力yuka的每种behavior都存在weight属性，表示力的权重，权重越高的behavior对物体运动轨迹的影响越大。要想创建一个集群式的尸体群落，个体与个体之间需要既有聚合力又有斥力，个体漫游，整体同化，各个力的权重如下：const alignmentBehavior = new YUKA.AlignmentBehavior()alignmentBehavior.weight = 2const cohesionBehavior = new YUKA.CohesionBehavior()cohesionBehavior.weight = 0.9const separationBehavior = new YUKA.SeparationBehavior()separationBehavior.weight = 0.2const wanderBehavior = new YUKA.WanderBehavior()wanderBehavior.weight = 0.8以上的作用力的计算都需要使用到影响力圈这个概念，相互作用力的效果会随着影响力圈的变大而变大。vehicle.updateNeighborhood = truevehicle.neighborhoodRadius = 10鲨鱼过境 中点追踪 InterposeBehaviorInterposBehavior需要指定2个被追随者，追随目标会落在这两者的中点位置。const interposeBehavior = new YUKA.InterposeBehavior(evader1, evader2)vehicle.steering.add(interposeBehavior) 创建变化线段 变化线段的顶点会不断变化，因此在创建Geometry的时候，要用setFromPoints留几个空端点：const lineGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(), new THREE.Vector3()])const lineMat = new THREE.LineBasicMaterial( color: 0xffaa00 )const line = new THREE.Line(lineGeo, lineMat)scene.add(line)需要改变端点的时候，需要将线段的position缓冲区取出来，使用setXYZ函数修改顶点坐标数据，函数的第一个参数表示顶点的序号，其余参数分别表示xyz，最后需要将needsUpdate赋值为true，表示更新const linePosition = line.geometry.attributes.positionlinePosition.setXYZ(0, evader1.position.x, 0, evader1.position.z)linePosition.setXYZ(1, evader2.position.x, 0, evader2.position.z)linePosition.needsUpdate = truerenderer.render(scene, camera);"},{"title":"玻璃材质","path":"/wiki/ThreeJs/Wael_18_glass_material.html","content":"玻璃材质的关键在于2点：高反射率高透明度把metalness拉到最高的金属材质尽管有很高的反射率，但是如果在金属材质的基础上拉低透明度，会把表面反射的效果也减弱。半透明金属质地MeshPhysicalMaterial提供了实现玻璃效果的参数transmission 透光率和opacity的区别在于能够降低透明度的同时不减弱反射效果ior折射率决定折射显像清晰度值在1-2.33之间"},{"title":"Controls 控制器","path":"/wiki/ThreeJs/Wael_17_orbit_controls.html","content":"OrbitControls能够控制相机旋转、缩放、平移，其中提供了不少可以修改的参数。（本人晕3d，OrbitControls还好，FirstPersonControls开发太蓝瘦了） OrbitControls 轨道控制器控制器参数config 配置参数不少，Threejs里面不少API都是这样，想不起来就看编译器提示或者官方文档实在不行看源码也挺好。panSpeed 平移速度rotateSpeed 旋转速度maxDistance 缩放大小enablePan 是否允许平移enableDamping 是否开启阻尼-（注意开启之后loop中必须对控制器进行update更新）dampingFactor 阻尼大小autoRotate 自动旋转autoRotateSpeed 自动旋转速度target 焦点焦点和相机位置重叠会导致控制器失效之前因为不知道这一点走了不少弯路，恼啊开启阻尼之后，相机移动丝滑很多 自定义控制键控制键 配置鼠标控制器：orbit.mouseButtons.LEFT = THREE.MOUSE.ROTATEorbit.mouseButtons.RIGHT = THREE.MOUSE.PAN键盘控制器（注意最后需要将监听器添加到window上）：orbit.keys = LEFT:ArrowLeft, UP:ArrowUp, RIGHT:KeyD, BOTTOM:KeySorbit.listenToKeyEvents(window)orbit.keyPanSpeed = 20 状态保存saveState() 状态保存reset() 状态重置读取window.onkeydown = e = if (e.code === KeyS) orbit.saveState() else if (e.code === KeyL) orbit.reset() 限制水平方位角限制minAzimuthAnglemaxAzimuthAngle垂直方位角限制minPolarAnglemaxPolarAngle TrackballControls 轨迹球控制器https://threejs.org/examples/#misc_controls_trackballhttps://threejs.org/examples/#misc_controls_trackballTrackballControls 和 OrbitControls 非常类似，根据官方文档的介绍，两种控制器的不同是 TrackballControls无法恒定保持摄像机的up向量，（没看懂）但两者的适用场景有所不同：OrbitControls 静态平滑的旋转效果，适合用户通过平移旋转等操作，查看3d模型TrackballControls 使用需要快速交互和动态旋转的场景，相机的移动相对平滑也可以把两个控制器组合在一起使用，比如说：平移、缩放使用 OrbitControls旋转使用 TrackballControls首先需要创建两个控制器：const orbitControls = new OrbitControls(camera,renderer.domElement)orbitControls.enableDamping = trueorbitControls.dampingFactor = 0.12orbitControls.enableZoom = falseconst trackBallControls = new TrackballControls(camera, renderer.domElement)trackBallControls.noRotate = truetrackBallControls.noPan = truetrackBallControls.noZoom = falsetrackBallControls.zoomSpeed = 1.5在loop函数内需要更新控制器：const target = orbitControls.targetorbitControls.update()trackBallControls.target.set(target.x, target.y, target.z)trackBallControls.update() Cursor Following Camera Animation 相机跟随鼠标滑动要做出相机运镜的效果，需要对相机进行如下一系列处理：根据鼠标相对屏幕的位置计算相机位置计算每次鼠标相对屏幕移动的距离缩小移动步长，能够提高移动的平滑程度相机始终望向焦点物体 lookAt相机坐标delta值的计算：let mouseX = 0;let mouseY = 0window.onmousemove = e= const windowHalfX = window.innerWidth / 2; const windowHalfY = window.innerHeight / 2; mouseX = (e.clientX - windowHalfX) / 100; mouseY = (e.clientY - windowHalfY) / 100;移动时缩小步长，保持相机lookAt焦点物体的位置：function animate() // ... camera.position.x += (mouseX - camera.position.x) * 0.05; camera.position.y += (-mouseY - camera.position.y) * 0.05; camera.lookAt(scene.position) renderer.render(scene, camera);"},{"title":"RenderPass && EffectComposer 渲染通道和特效组合","path":"/wiki/ThreeJs/Wael_19_effect_composer.html","content":"类似Photoshop等媒体后期软件，three中特效的叠加也和图层控制的机制相类似。RenderPass 原始图像图层原始图层要放在最底层（第一个加入通道）EffectComposer 效果组合器能够将不同效果图层叠加在一起渲染效果层加入的顺序会影响最终的渲染结果要添加效果，首先就需要将原始图层作为图层加入通道。import RenderPass from three/examples/jsm/postprocessing/RenderPassimport EffectComposer from three/examples/jsm/postprocessing/EffectComposerconst renderScene = new RenderPass(scene, camera)const effectComposer = new EffectComposer(renderer)effectComposer.addPass(renderScene)还需要修改常规每帧renderer.render渲染函数，这里Wael Yasmina提醒说低版本的threejs不支持在loop函数里用effectComposer重渲染，我试了下0.133.0版本的threejs，应该是可以的。也就是说这里需要修改执行render的对象，从render改成effectComposereffectComposer.render() 虚幻效果|电影效果|毛刺效果"},{"title":"CANNON-Constraint 约束力","path":"/wiki/ThreeJs/Wael_20_lock_constraint.html","content":"Lock Constraint说实话，听完Wael Yasmina讲的之后，我也没弄明白到底什么是Lock Constraint，视频下方相关的一些文章都是全英文论文（捂脸），实际操作之后，constraint似乎像是一种锁链关系，将两个离散的物体作为一个整体计算受力情况。Cannon专门提供了一个类用于实现Constraint，就是LockConstraint，实例化时必填2个参数：参数1：当前Body参数2：当前Body具有锁定关系的上一个Body将一连串物体使用LockConstrain锁在一起后，它们将作为一个整体受力，但同时整体的各个部分相互之间也有力的作用。const world = new CANNON.World( gravity: new CANNON.Vec3(0, -9.81, 0))const size = 0.5const space = size * 0.1const N = 10const shape = new CANNON.Box(new CANNON.Vec3(size, size, size))const mass = 1const meshes = []const bodies = []const geo = new THREE.BoxGeometry(size * 2, size * 2, size * 2)const mat = new THREE.MeshBasicMaterial( color: 0xffaa00 )for (let i = 0; i N; i++) const boxBody = new CANNON.Body( shape, mass, position: new CANNON.Vec3((i - N / 2) * (size+space) * 2, 0, 0) // position: new CANNON.Vec3(-(N-i-N/2), 0, 0) ) world.addBody(boxBody) bodies.push(boxBody) const boxMesh = new THREE.Mesh(geo, mat) scene.add(boxMesh) meshes.push(boxMesh) if (i 0) const lockConstraint = new CANNON.LockConstraint(boxBody, bodies[i - 1]) world.addConstraint(lockConstraint) const leftFlatMesh = new THREE.Mesh(geo, mat)scene.add(leftFlatMesh)meshes.push(leftFlatMesh)const leftFlatBody = new CANNON.Body( shape, type: CANNON.BODY_TYPES.STATIC, position:new CANNON.Vec3(-N*(size+space),-3,0))world.addBody(leftFlatBody)bodies.push(leftFlatBody)const rightFlatMesh = new THREE.Mesh(geo, mat)scene.add(rightFlatMesh)meshes.push(rightFlatMesh)const rightFlatBody = new CANNON.Body( shape, type: CANNON.BODY_TYPES.STATIC, position:new CANNON.Vec3((N-1 - N / 2) * (size+space) * 2,-3,0))world.addBody(rightFlatBody)bodies.push(rightFlatBody)function animate() world.step(1 / 60) for (let i = 0; i meshes.length; i++) meshes[i].position.copy(bodies[i].position) meshes[i].quaternion.copy(bodies[i].quaternion) renderer.render(scene, camera)renderer.setAnimationLoop(animate) Distance Constraint Constrains two bodies to be at a constant distance from each others center of mass. DistanceConstrain的功能是将两个body保持固定距离约束在一起。实例化CANNON.DistanceConstrain需要三个参数：bodyAbodyBdistance为了制作一个由15×15个小球组成的矩形网格，首先需要创建15×15个body，接着对这些body进行关联。使用矩阵行列索引哈希表存储数据，在关联时会方便很多。const row = 15const col = 15const size = 0.2const space = 0.05const ballMeshes = []const ballBodies = []const ballGeo = new THREE.SphereGeometry(size)const ballMat = new THREE.MeshBasicMaterial( color: 0xffaa00 )const particles = for (let i = 0; i row; i++) for (let j = 0; j col; j++) const ballMesh = new THREE.Mesh(ballGeo, ballMat) ballMeshes.push(ballMesh) const x = (i - row / 2) * (size * 2 + space) + size const z = (j - col / 2) * (size * 2 + space) + size scene.add(ballMesh) const body = new CANNON.Body( shape: new CANNON.Sphere(size), position: new CANNON.Vec3(x, 5, z), mass: 1 ) world.addBody(body) ballBodies.push(body) particles[`$i $j`] = body function connect(i1, j1, i2, j2) const distanceConstrain = new CANNON.DistanceConstraint( particles[`$i1 $j1`], particles[`$i2 $j2`], space*10 ) world.addConstraint(distanceConstrain)for (let i = 0; i row; i++) for (let j = 0; j col; j++) if (i row - 1) connect(i, j, i + 1, j) if (j col - 1) connect(i, j, i, j + 1) Cloth Simulate 模拟布料和上一部分 Distance Constraint 的原理相似，一块方形的布料可以看做一块矩阵，矩阵的相邻元素之间存在Distance Constrain关系。这里组成矩阵的body使用CANNON.Particle类。第一步，创建布料实体，按照布料矩阵的行列顶点数配置segments:const clothGeo = new THREE.PlaneGeometry(1, 1, row, col)const clothMaterial = new THREE.MeshBasicMaterial( side: THREE.DoubleSide, // 为布料添加纹理 map:new THREE.TextureLoader().load(/assets/jean-philippe-delberghe-75xPHEQBmvA-unsplash.jpg))const clothMesh = new THREE.Mesh(clothGeo, clothMaterial)scene.add(clothMesh)第二步，创建body矩阵，注意：n×m分段的geometry上实际上有(n+1)*(m+1)个顶点for (let i = 0; i row + 1; i++) const vec = [] for (let j = 0; j col + 1; j++) const body = new CANNON.Body( shape, mass:j==col?0:mass, position: new CANNON.Vec3((i - row / 2) * dist, (j - col / 2) * dist, 0), velocity:new CANNON.Vec3(0,-0.1*(col-j)) ) world.addBody(body) vec.push(body) bodies.push(vec)第三步，为body矩阵的每个元素条件constraint条件：function createConstraint(i1, j1, i2, j2) const constraint = new CANNON.DistanceConstraint( bodies[i1][j1], bodies[i2][j2], dist ) world.addConstraint(constraint)for (let i = 0; i = row; i++) for (let j = 0; j = col; j++) if (i row) createConstraint(i, j, i + 1, j) if (j col) createConstraint(i, j, i, j + 1) 第四步，创建布料同步函数，在loop函数中会逐帧调用每次刷新布料geometry中attr类型变量position的对应顶点function updatePosition() for (let i = 0; i = row; i++) for (let j = 0; j = col; j++) const index = i * (row + 1) + j const position = clothGeo.attributes.position const bodyPosition = bodies[i][j].position position.setXYZ(index, bodyPosition.x, bodyPosition.y, bodyPosition.z) position.needsUpdate = true 第五步，创建球形const sphereGeo = new THREE.SphereGeometry(radius)const sphereMat = new THREE.MeshPhysicalMaterial()const sphere = new THREE.Mesh(sphereGeo, sphereMat)scene.add(sphere)const sphereBody = new CANNON.Body( shape: new CANNON.Sphere(radius*1.3), type: CANNON.BODY_TYPES.STATIC)world.addBody(sphereBody)第六步、启动动画帧const timeStep = 1 / 60function animate(time) world.step(timeStep) updatePosition() sphereBody.position.set( radius * Math.sin(time / 1000), 0, radius * Math.cos(time / 1000), ) sphere.position.copy(sphereBody.position) renderer.render(scene, camera);"},{"title":"CSS2DRenderer","path":"/wiki/ThreeJs/Wael_21_css_renderer.html","content":"CSS2DRenderer使用CSSRenderer可以渲染html标签到3D场景中，对dom元素进行平移、旋转、缩放等变换，主要是通过css中的transform属性。有两种类型的CSSRenderer：CSS2DRenderer 2维变化CSS3DRenderer3维变化提示因为CSSRenderer主要是对dom的transform属性进行变化，因此尽量在每个渲染元素外再包一层dom，防止自定义的transform属性被覆盖。const inner = document.createElement(div)const outer = document.createElement(div)outer.appendChild(innter)const obj = new CSS2DRenderer(outer)CSSRender的使用和WebGLRender一样，区别在于CSSRenderer内的Object 无法受到光照的影响 。CSSRenderer的创建：const cssRenderer = new CSS2DRenderer()cssRenderer.setSize( window.innerWidth, window.innerHeight)document.body.append(cssRenderer.domElement)Loop函数中更新：cssRenderer.render(scene,camera)"},{"title":"Instenced Mesh 实例化网格","path":"/wiki/ThreeJs/Wael_22_instanced_mesh.html","content":"渲染大量网格时需要考虑的问题Render Call 在使用threejs在场景中绘制出一个实体时，threejs实际在后台帮我们略去了很多复杂的绘图操作。这些操作中包括比较关键的步骤：CPU与GPU之间的通信。CPU发出绘图指令，GPU负责执行绘图。场景中有N个实体，这种通信就要执行N次。如果绘制的图形如果具有相同的Geometry和Material，这样的操作如果执行N次会导致渲染效率低下。就好像你要把同一条短信发给好几个人，如果一个一个发效率自然会很低下。 InstancedMeshTHREE.InstancedMesh能够一次性创建N个具有相同Geo和Mat的实体，无需再使用for循环N次。let mesh = new THREE.InstancedMesh(geo, mat, count)InstancedMesh中提供了修改内部实例的变换矩阵 和 颜色的接口：matrixInstancedMesh.setMatrixAt(index,matrix)注意setMatrixAt调用过后，需要将InstancedMesh.instanceMatrix.needsUpdate改为true，更新矩阵InstancedMesh.getMatrixAt(index,matrix)colorInstancedMesh.setColorAt(index, THREE.Color)同样的需要再之后将InstancedMesh.instanceColor.needsUpdate修改为truemesh.setMatrixAt(i, dummy.matrix)mesh.instanceMatrix.needsUpdate = truemesh.setColorAt(i,new THREE.Color(Math.random()*0xffffff))mesh.instanceColor.needsUpdate = true如果在loop函数中，需要获取mesh内实例的模型矩阵的各个分量（旋转、平移、缩放），可以用Matrix4.decompose拆解实例的模型矩阵matrix：const matrix = new THREE.Matrix4() // 空矩阵mesh.getMatrixAt(i, matrix) // 获取mesh内第i个实例的matrixmatrix.decompose(dummy.position, dummy.rotation, dummy.scale) // 拆解"},{"title":"colorWrite && renderOrder","path":"/wiki/ThreeJs/Wael_24_object_occlusion.html","content":"colorWrite renderOrdercolorWrite材质上的一个布尔值属性，用于判断是否绘制材质的颜色。当colorWrite为false时，绘制的物体材质将从背景中取色，renderOrder控制物体绘制的层级，绘制顺序为：低层级→高层级绘制顺序决定了透明物体被绘制出来时，背景绘制的情况，如果后方物体先于透明物体绘制，先绘制的物体会成为背景的一部分，如果后方物体后于透明物体绘制，则后方物体则会被完全遮挡。plane1Mesh.renderOrder = 2plane2Mesh.renderOrder = 1ringMesh.renderOrder = 0plane1Mesh.renderOrder = 0plane2Mesh.renderOrder = 2ringMesh.renderOrder = 1 控制gltf模型的renderOrder这一步和开启gltf模型阴影非常相似，用到的是traverse方法：model.traverse(m= if(m.isObject3D)m.castShadow = true if(m.isMesh)m.renderOrder = 2)通过在门的左右两侧防止遮罩物体的方式，能够实现角色穿过门后消失的效果但是这种遮罩的效果存在一个问题：无法遮盖住物体的影子（什么鬼故事）"},{"title":"DRACOLoader","path":"/wiki/ThreeJs/Wael_23_draco_loader.html","content":"DRACOLoader有时在开发过程中，需要引入一些很大的模型，如果不做任何处理性能会很低，可以在使用Blender导出模型时进行压缩：右侧菜单栏DataCompression压缩过的模型在threeJs中加载时，不能直接使用GLTFLoader进行加载，如果直接使用GLTFLoader加载Draco压缩模型，会报错：No DRACOLoader instance provided.需要引入另一个压缩模型的加载器：DRACOLoader，用到DRACOLoader时，遇到了不少坑 坑1：DRACOLoader加载模型必须经过draco压缩 如果加载未经过draco压缩的模型，会报错，我原本理解错误，以为对模型压缩的步骤是在Loader过程中实现的，实际上压缩模型需要在Blender里面完成，DRACOLoader只是针对压缩模型的一个加载器。 坑2：解析文件路径配置 网上有不少地方说配置路径可以通过复制draco git仓库的readme文档中提供的url实现：dLoader.setDecoderPath(https://www.gstatic.com/draco/versioned/decoders/1.5.7/)一开始我也是这么配置的，但是比较了一下模型的加载速度，好像没有多大变化，我以为是路径配置错误，于是就开始下面一错再错的痛苦经历：threejs中的DRACOLoader类要解析压缩模型需要几个关键解析文件：draco_decoder.js Emscripten-compiled decoderdraco_decoder.wasm WebAssembly decoderdraco_wasm_wrapper.js JavaScript wrapper好的我已经看不懂了，反正三个都是解码器。总之DRACOLoader的decoderPath解码路径只要指向这三个文件就行了，在包管理器中，这三个文件目录如下：threeexamplesjsmlibsdraco那是不是把解码器路径配置成上面这个就行了？dLoader.setDecoderPath(/examples/jsm/libs/draco/)还是报错：Uncaught SyntaxError: Unexpected token ‘’ (at f11573a6-dd88-4e61-930c-e24ebf877308:2:1)报的是语法错误，说明解析有问题，解析文件没有获取到。在网上翻到了这篇博文：https://juejin.cn/post/7072701904291102728https://juejin.cn/post/7072701904291102728把刚才的draco文件移动到public文件夹，在浏览器端运行时可以获取到，draco模型正常加载：const loader = new GLTFLoader()const dLoader = new DRACOLoader()dLoader.setDecoderPath(public/draco/)dLoader.setDecoderConfig(type:js)loader.setDRACOLoader(dLoader)loader.load(assets/lamborghini_centenario_roadster_sdc.glb,gltf= scene.add(gltf.scene) gltf.scene.traverse(model=model.castShadow = true))"},{"title":"LOD","path":"/wiki/ThreeJs/Wael_25_LOD.html","content":"LODLOD全称Level of Detail，能够根据相机与物体的距离加载不同的模型，是一种模型加载的常用优化方式。物体渲染的性能与网格的顶点数量等数值有关，因此当相机视角拉远时，可以展示细节更少的模型，反之当相机视角拉近，展示细节更多的模型。let lod = new THREE.LOD()scene.add(lod)loader.load(assets/cactus/Cactus_01.glb,gltf= // 距离0处的模型 lod.addLevel(addGLTFModel(gltf), 0))loader.load(assets/cactus/Cactus_02.glb,gltf= // 距离3处的模型 lod.addLevel(addGLTFModel(gltf), 3))loader.load(assets/cactus/Cactus_1.glb,gltf= // 距离6处的模型 lod.addLevel(addGLTFModel(gltf), 6))"},{"title":"Gimbal Lock","path":"/wiki/ThreeJs/Wael_26_Gimbal_Lock.html","content":"Gimbal Lock环架锁定 https://en.wikipedia.org/wiki/Gimbal_lockhttps://en.wikipedia.org/wiki/Gimbal_lock三维物体旋转有很多种方式，其中有一种叫做欧拉角的方式，其特点就是将一次旋转分为3次旋转，这三次旋可以是XYZ、XZY、ZYX……等等顺序，这个不重要，但是第一次旋转的那个轴总是世界坐标轴，也就是不变的，旋转角度称为静态欧拉角静态欧拉角其余的两次旋转则是相对物体自身的坐标轴，旋转角度称为动态欧拉角动态欧拉角与维度重叠区别就是：动态欧拉角坐标系旋转时，其余两个坐标系都会随物体转动而转动，而静态欧拉角转动时则不会。假设三个轴旋转的顺序是ABC，A轴作为第一个旋转轴，其使用静态欧拉角旋转，旋转时BC坐标轴不变，B轴旋转时，为了保证A轴刚才的旋转不丢失，A轴也会随物体一起旋转，但C轴不变C旋转时，为了保证AB旋转角度不丢失，AB都会随物体一起旋转，但是C轴本身是静止的，能够旋转的只有AB轴而已，万向锁问题出现在第二步：B轴带动A轴转动上，这时如果B轴转动的角度是±90°，会导致BC轴重叠，造成维度丢失的问题。 万向锁的解决方式四元组 通过四元组旋转物体，可以解决万向锁。https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%97%8B%E8%BD%AChttps://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%97%8B%E8%BD%AC// XYZ模式下 沿Y、Z轴的旋转const quaternionY = new THREE.Quaternion()quaternionY.setFromAxisAngle(new THREE.Vector3(0,1,0).normalize(),Math.PI/2)cloneMonkey.applyQuaternion(quaternionY)const quaternionZ = new THREE.Quaternion()quaternionZ.setFromAxisAngle(new THREE.Vector3(0,0,1).normalize(),Math.PI/2)cloneMonkey.applyQuaternion(quaternionZ) 四元组的其他用法 同时四元组还可以用来实现物体沿任意（而非坐标轴）轴线旋转的功能：左侧为四元组旋转，右侧为欧拉旋转如果将旋转效果应用到position而不是rotation上，能够实现围绕世界坐标系旋转的效果：const quaternionO = new THREE.Quaternion() .setFromAxisAngle(new THREE.Vector3(0,1,0).normalize(), 0.01)model.position.applyQuaternion(quaternionO)相机的旋转也是同样的道理：function rotateCamera() const quaternionO = new THREE.Quaternion() quaternionO.setFromAxisAngle(new THREE.Vector3(0,1,0).normalize(), -0.01) camera.position.applyQuaternion(quaternionO) camera.lookAt(0,0,0) rotateTowards slerpsetFromAxisAngle可以通过指定坐标轴和旋转角来配置四元组，rotateTowards需要两个参数：q Quaternion类型step Float类型可以将当前的quaternion按照step逐步移动接近最终的q数值：cube.quaternion.rotateTowards(cube2.quaternion, 0.01)使用slerp也是相同的方式：cube.quaternion.slerp(cube2.quaternion, 0.1)slerp的第二个参数控制单次旋转量，能实现更加丝滑的旋转效果左侧是slerp实现的旋转效果"},{"title":"Layer 图层","path":"/wiki/ThreeJs/Wael_27_Layer.html","content":"LayerThreeJs提供序号在0-31之间共32个图层，一个物体可以同时存在在不同的图层上，只有与相机同图层的物体才能被观察到。https://threejs.org/docs/index.html?q=Layer#api/en/core/Layershttps://threejs.org/docs/index.html?q=Layer#api/en/core/LayersLayer类提供了一些简单的操作：set 指定为某一图层enableAll 开启全部图层enable 开启某一图层图层操作切换物体可见性 图层+渲染通道控制可以使用图层来控制某个物体，或物体的某个部分是否需要叠加渲染效果。拿UnrealBloom这个渲染效果为例，未经渲染的原始效果如下：我们需要将所有物体的纹理变成深色：将需要应用效果的物体从中排除，保持原来的材质，这里用到的是层级控制：添加UnrealBloom的渲染效果，（深色纹理不受unrealBloom效果的影响）最后一步：将物体的原始纹理映射重新取出 上面的步骤是three渲染的流程，实际实现流程如下：step1step2step3step4步骤1： 绘制原始图像let model, mixerconst loader = new GLTFLoader()loader.load(assets/fantasy_sword.glb, gltf = model = gltf.scene scene.add(model) model.position.set(0, 126, -127) mixer = new THREE.AnimationMixer(model) const action = mixer.clipAction( THREE.AnimationClip.findByName(gltf.animations,Idle) ) action.play())步骤2：添加Bloom效果合成器const renderScene = new RenderPass(scene, camera)const unrealBloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 1, 0.1)const bloomComposer = new EffectComposer(renderer)bloomComposer.addPass(renderScene)bloomComposer.addPass(unrealBloomPass)function animate() // ... bloomComposer.render()window.addEventListener(resize, function() // ... bloomComposer.setSize(window.innerWidth, window.innerHeight));步骤3：添加Bloom和原始图像的混合合成器这个合成器包含3个主要的通道：原始基层图像通道 renderPass合成Bloom和基层会用到的着色器通道 shaderPass输出最终效果的通道 outputPass我们只需要用bloomRender的渲染效果进行合成，并不需要将它渲染到场景中：bloomComposer.renderToScreen = false对多个纹理进行合成，需要用到ShaderPass，ShaderPass接收ShaderMaterial作为参数，在html中准备好vertexShader和fragmentShader：VertexShaderscript type=x-vertex id=v-shader varying vec2 vUv; void main() vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptFragmentShadrescript type=x-fragment id=f-shader varying vec2 vUv; uniform sampler2D baseTexture; uniform sampler2D bloomTexture; void main() gl_FragColor = (texture2D(baseTexture, vUv) + vec4(1.0)*texture2D(bloomTexture, vUv)); /script其中gl_FragColor可以拆分成3个部分：原始渲染纹理 texture2D(baseTexture, vUv)bloom渲染效果纹理 texture2D(bloomTexture, vUv)渲染效果强度 vec4(1.0)创建ShaderPass：const mixPass = new ShaderPass( new THREE.ShaderMaterial( uniforms: baseTexture: value: null , bloomTexture: value: bloomComposer.renderTarget2.texture , vertexShader: document.getElementById(v-shader).textContent, fragmentShader: document.getElementById(f-shader).textContent, ),baseTexture)创建渲染最后效果的合成器：const outputPass = new OutputPass()finalComposer.addPass(renderScene)finalComposer.addPass(mixPass)finalComposer.addPass(outputPass)function animate() // ... finalComposer.render()window.addEventListener(resize, function() // ... finalComposer.setSize(window.innerWidth, window.innerHeight));步骤4：加入图层控制材质创建Bloom图层、暗色纹理、纹理存储对象：const BLOOM_LAYER = 1const bloomLayer = new THREE.Layers()bloomLayer.set(BLOOM_LAYER)const darkMaterial = new THREE.MeshStandardMaterial( color: 0x000000 )const materials = function storeMaterial(obj) if (obj.isMesh !bloomLayer.test(obj.layers)) materials[obj.uuid] = obj.material obj.material = darkMaterial function restoreMaterial(obj) if (materials[obj.uuid]) obj.material = materials[obj.uuid] delete materials[obj.uuid] 在loop函数内进行图层控制操作：function animate() // ... scene.traverse(storeMaterial) // 不在bloom层的变暗 bloomComposer.render() // bloom通道生成效果纹理 scene.traverse(restoreMaterial) // 恢复变暗部分的纹理 finalComposer.render() // 混合bloom与原始效果做好这些工作之后，就可以通过图层控制的方式，给不同部分添加渲染效果：function createGUI() const gui = new GUI() const configs = const names = [Object_11, Object_12, Object_13, Object_14] names.forEach(name = configs[name] = false gui.add(configs, name).onChange(val = model.getObjectByName(name).layers.toggle(BLOOM_LAYER) ) )"},{"title":"Object Follow Path 物体跟随路径","path":"/wiki/ThreeJs/Wael_29_follow_path.html","content":"CatmullRomCurve3 曲线路径说到物体跟随路径移动，就想到使用yuka库来实现，如果不用yuka实现呢？yuka里，需要创建一条yuka.Path，通过这条路径，在动画帧里刷新物体的坐标和方向，在Threejs中，CatmullRomCurve3也可以使用几个关键坐标创建出一条曲线：const points = [ new THREE.Vector3(-10, 0, 10), new THREE.Vector3(-5, 5, 5), new THREE.Vector3(0, 0, 0), new THREE.Vector3(5, -5, 5), new THREE.Vector3(10, 0, 10),]const path = new THREE.CatmullRomCurve3(points,true)const pathGeometry = new THREE.BufferGeometry().setFromPoints(path.getPoints(50))const pathMaterial = new THREE.LineBasicMaterial( color:0xff0000,)const pathObject = new THREE.Line(pathGeometry,pathMaterial)scene.add(pathObject)在 threeexamplesjsmcurvesCurveExtras 里，还提供了很多类型的曲线创建方式https://threejs.org/docs/index.html?q=Cur#api/en/extras/curves/CatmullRomCurve3https://threejs.org/docs/index.html?q=Cur#api/en/extras/curves/CatmullRomCurve3曲线创建好后，需要再帧动画中，通过连续的时间参数获取曲线上的点位切线方向通过这些属性对物体进行变换：function animate(time) const t = (time / 2000 % 6)/6 // t是一个在0-1之间连续变化的值 const point = path.getPointAt(t) // 提取点位 shipModel.position.copy(point) const tangent = path.getTangentAt(t).normalize() // 提取切线向量 shipModel.lookAt( point.clone().add(tangent) ) renderer.render(scene, camera); 赛博吸冰"},{"title":"Map 地图","path":"/wiki/ThreeJs/Wael_28_map.html","content":"mini map 场景小地图的添加制作场景小地图，意味着除了渲染scene和主视角控制的camera外，还会用到一个小地图专用的摄像机。这里的conrtols控制器使用 MapControls 会更好，MapControls 控制摄像机的方式偏向 鸟瞰视角https://threejs.org/examples/#misc_controls_maphttps://threejs.org/examples/#misc_controls_mapimport MapControls from three/examples/jsm/controls/MapControls;// ...const controls = new MapControls(camera, renderer.domElement);controls.enableDamping = truecontrols.dampingFactor = 0.05controls.enableZoom = false// 注意开启阻尼之后，需要再animate函数中update控制器function animate() controls.update()创建一个新的dom容器，用于渲染小地图： style #mini-map position:absolute; width:250px; height:250px; right:1rem; bottom:1rem; box-shadow:0px 0px 5px #000; /stylediv id=mini-map/div为小地图准备专门的 渲染器 、 摄像机 const miniMapDom = document.getElementById(mini-map)const miniMapRenderer = new THREE.WebGLRenderer(antialias:true);miniMapRenderer.setSize(miniMapDom.clientWidth, miniMapDom.clientHeight)miniMapDom.appendChild(miniMapRenderer.domElement)miniMapRenderer.setClearColor(0xffffff)const miniMapCamera = new THREE.PerspectiveCamera( 45, miniMapDom.clientWidth / miniMapDom.clientHeight, 0.1, 1000)miniMapCamera.position.set(0, 50, 0)miniMapCamera.lookAt(0,0,0)function miniMapAnimation() miniMapRenderer.render(scene, miniMapCamera)miniMapRenderer.setAnimationLoop(miniMapAnimation)视角联动通过raycaster获取鼠标在小地图上的点击位置P，将大地图的相机位置移动到P处，注意相机位置移动后，还需要修改controls.target才能修改相机的朝向const mousePosition = new THREE.Vector2()const raycaster = new THREE.Raycaster()miniMapDom.onmousedown = e = let rect = miniMapDom.getBoundingClientRect() let x = e.offsetX let y = e.offsetY mousePosition.x = (x/miniMapDom.clientWidth*2) - 1 mousePosition.y = 1 - (y/miniMapDom.clientHeight * 2) raycaster.setFromCamera(mousePosition, miniMapCamera) let intersections = raycaster.intersectObject(model) if(intersections[0]) const point = intersections[0].point camera.position.set(point.x, 8, point.z) controls.target.set(point.x, 0, point.z) texture + layer 控制实现小地图 小地图一般不需要过于精细的渲染，因此为这个功能专门渲染一个模型，会消耗很多性能，因此可以直接用一张texture纹理图片代替模型：const textureLoader = new THREE.TextureLoader()const mapTexture = textureLoader.load(assets/painting/MiniMap.png)mapTexture.colorSpace = THREE.SRGBColorSpaceconst planeGeo = new THREE.PlaneGeometry(41,41)const planeMat = new THREE.MeshBasicMaterial( map:mapTexture)const planeMesh = new THREE.Mesh(planeGeo, planeMat)planeMesh.rotation.set(-Math.PI/2, 0, 0 )scene.add(planeMesh)通过图层控制的方式，将小地图用到的texture和实际的model分开到两个图层，小地图渲染器只对texture图层进行渲染，但是仍能保留raycaster交互事件：miniMapCamera.layers.disableAll()miniMapCamera.layers.enable(1)planeMesh.layers.disable(0)planeMesh.layers.enable(1) 在小地图中标注场景物体位置在场景中动态添加建筑物，通过raycaster能够获得物体坐标，在小地图的同坐标位置创建图标（贴图平面），需要注意的是，小地图图标需要和小地图在同一个图层：// 加载tower iconconst towerTexture= textureLoader.load(assets/painting/tower.png)towerTexture.colorSpace = THREE.SRGBColorSpaceconst towerMat = new THREE.MeshBasicMaterial( map:towerTexture, transparent:true)const towerGeo = new THREE.PlaneGeometry(3.5,3.5)window.onkeydown = e = if(e.key == t tower) raycaster.setFromCamera(mousePosition, camera) const intersections = raycaster.intersectObject(model) if(intersections[0]) const point = intersections[0].point let group = new THREE.Group() scene.add(group) // ... 添加塔部分省略 // 小地图图标 const towerMesh = new THREE.Mesh(towerGeo, towerMat) group.add(towerMesh) towerMesh.position.y = 0.1 towerMesh.rotation.set(-Math.PI/2, 0, 0) towerMesh.layers.disable(0) // 修改图标所在图层 towerMesh.layers.enable(1) DLC1：塔楼添加shader雷达效果 用shader和一张灰度转场图实现，需要注意的是，叠加在同一y轴的物体会出现深度冲突的问题，因此需要给y轴一定的偏移：Math.random() * 0.01script type=x-vertex id=v-shader varying vec2 vUv; void main() vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); /scriptscript type=x-fragment id=f-shader varying vec2 vUv; uniform sampler2D u_transition; uniform float u_time; mat2 rotate(float angle) return mat2( cos(angle), -sin(angle), sin(angle), cos(angle) ); void main() vec2 vUv = vUv; vUv -= 0.5; vUv *= rotate(u_time); vUv +=0.5; vec4 texture = texture2D(u_transition, vUv); gl_FragColor = vec4( 0.4, texture.g/1.3, texture.b/1.3, texture.r ); /script// 渐变材质const uniforms = u_transition: type:t, value:textureLoader.load(assets/transition/transition6.png) , u_time:type:f, value: 0.0const radarMat = new THREE.ShaderMaterial( uniforms, transparent:true, vertexShader:document.getElementById(v-shader).textContent, fragmentShader:document.getElementById(f-shader).textContent,)const radarGeo = new THREE.CircleGeometry(5,20)window.onkeydown = e = if(e.key == t tower) raycaster.setFromCamera(mousePosition, camera) const intersections = raycaster.intersectObject(model) if(intersections[0]) const point = intersections[0].point let group = new THREE.Group() scene.add(group) // 略.... // 底部扫描效果 const radarMesh = new THREE.Mesh(radarGeo, radarMat) radarMesh.rotation.set(-Math.PI/2 , 0,0) group.add(radarMesh) radarMesh.position.y = Math.random() * 0.01 DLC2:CSS2DRender 引入CSS2DRender实现通过input:range控制扫描圈的大小const labelRenderer = new CSS2DRenderer()labelRenderer.setSize(window.innerWidth, window.innerHeight)document.body.appendChild(labelRenderer.domElement)labelRenderer.domElement.style.position = absolutelabelRenderer.domElement.style.top = 0pxlabelRenderer.domElement.style.pointerEvents = none//...window.onkeydown = e = if(e.key == t tower) raycaster.setFromCamera(mousePosition, camera) const intersections = raycaster.intersectObject(model) if(intersections[0]) const point = intersections[0].point let group = new THREE.Group() scene.add(group) // ... // 缩放滑动条 let slider = document.createElement(input) slider.type = range slider.max = 3 slider.min = 1 slider.value = 2 slider.step = 0.1 slider.style.pointerEvents = all const sliderLabel = new CSS2DObject(slider) sliderLabel.position.set(0,2,0) // group.add(sliderLabel) slider.addEventListener(input,e= radarMesh.scale.set(slider.value, slider.value, slider.value) ) 小地图显示动态物体小地图上物体图标的变化和实际物体的变化原理完全一致，下面代码实现一台低空飞行的直升飞机：// 加载直升飞机let helicoptelet mixerloader.load(assets/helicopter.glb,gltf= helicopte = gltf.scene helicopte.scale.set(0.2,0.2,0.2) helicopte.position.set(0,1,0) scene.add(helicopte) mixer = new THREE.AnimationMixer(helicopte) const action = mixer.clipAction( THREE.AnimationClip.findByName(gltf.animations, Rotation) ) action.play())这辆直升飞机有固定的航迹，使用CatmullRomCurve3创建：const points = [ new THREE.Vector3(-5,1,-5), new THREE.Vector3(-5,3,3), new THREE.Vector3(5,5,5), new THREE.Vector3(10,3,-1), new THREE.Vector3(3,2,-8),]const path = new THREE.CatmullRomCurve3(points,true)const pathGeo = new THREE.BufferGeometry().setFromPoints(path.getPoints(50))const pathMat = new THREE.LineBasicMaterial(color:0xffaa00)const pathMesh = new THREE.Line(pathGeo, pathMat)scene.add(pathMesh)此外，还需要在小地图中创建一个直升飞机对应的icon：const helicopterIconMat = new THREE.ShaderMaterial( uniforms, transparent:true, vertexShader:document.getElementById(v-shader).textContent, fragmentShader:document.getElementById(f-shader-2).textContent,)const helicopterIconGeo = new THREE.CircleGeometry(5,20)const helicopterIconMesh = new THREE.Mesh(helicopterIconGeo, helicopterIconMat)helicopterIconMesh.position.y = 1helicopterIconMesh.rotation.x = -Math.PI/2helicopterIconMesh.layers.disable(0)helicopterIconMesh.layers.enable(1)scene.add(helicopterIconMesh)icon使用shaderMaterial自定义波纹效果：script type=x-fragment id=f-shader-2 varying vec2 vUv; uniform float u_time; void main() vec2 vUv = vUv; float distance = distance(vec2(0.5), vUv); // fract 取小数部分 10.0控制波纹密度 40.0控制波纹透明度 float color = fract(distance * 10.0 - u_time) / distance / 40.0; gl_FragColor = vec4(vec3(1.0, 0.0, 0.0), color); /script在动画帧中改变直升飞机和飞机图标的position和切向量const clock = new THREE.Clock()function animate(time) if(mixer) mixer.update(clock.getDelta()) const t = (time/2000 % 10) /10 const position = path.getPointAt(t) const tangent = path.getTangentAt(t) helicopte.position.copy(position) helicopte.lookAt( position.clone().add(tangent) ) helicopterIconMesh.position.copy(position) // ..."},{"title":"Basic Components - ThreeJs的基本元素","path":"/wiki/ThreeJs/learning_03_basicComponents.html","content":"Create a SceneThree Types of Components Determine the Scene to Show camera : what is renderedlight : how the material be renderedobject : the thing be renderedObject3D 是threeJs中大部分对象的基类Scene is the Container of these different components Basic functionality of a scene Example 02 Basic Scene魔改版Example 02 Basic Scenescene-related functionsTHREE.Scene.Add 添加元素THREE.Scene.Remove 移除元素THREE.Scene.children 获取所有子元素THREE.Scene.getObjectByName 通过元素的name获取元素THREE.Scene.traverse 遍历scene的所有子元素THREE.Scene.fog 雾THREE.Scene.overrideMaterial 覆盖材质 Scene.fog 在上面两个demo中加上雾气效果：scene.fog = new THREE.Fog(0xffffff, 0.015, 100)加上fog效果魔改版Fog Scene.overrideMaterial 通过scene.overrideMaterial能够覆写页面上的所有元素的材质scene.overrideMaterial = new THREE.MeshLambertMaterial( wireframe:true)overrideMaterial覆写材质魔改版 Geometries MeshesWhat’s geometry? A geometry is basically a collection of points in a 3D spacetip: a collection of points 即 vertices Different Cameras"},{"title":"Start - 开始ThreeJs之旅","path":"/wiki/ThreeJs/learning_02_start.html","content":"Rendering and viewing a 3D object要组成一个3D画面，需要3个主要元素： 场景 Scene Store and keep track of all the objects we want to render and all the lights we want to use const scene = new THREE.Scene() 相机 Camera Defines what we’ll see when we render a scene const camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 ) 渲染器 Renderer Calculating what the scene object will look like const renderer = new THREE.WebGLRenderer()renderer.setClearColor(new THREE.Color(0x000000))renderer.setSize(window.innerWidth, window.innerHeight) Renderers ThreeJs提供多种渲染器：WebGLRendererCanvasRendererSVGRendererCssRenderer AxesHelper 坐标辅助器 a helpful debugging toolconst axes = new THREE.AxesHepler(5)scene.add(axes) Materials, lights, and shadowsLight 加入光源spotLight 聚光灯spotLightHepler 聚光灯辅助线let spotLight = new THREE.SpotLight(0xaa00aa)spotLight.position.set( 1.5, 0.7, 1.5 );spotLight.intensity = 7scene.add(spotLight)const spotLightHelper = new THREE.SpotLightHelper( spotLight );scene.add( spotLightHelper ); Material threeJs中有些材质是不受光线影响的，如MeshBasicMaterial想要创建受光照作用的材质，可以使用其他材质，如：MeshLambertMaterialMeshPhongMaterial Shadow 由于渲染shadow会耗费大量CPU资源，因此默认是disabled的，需要三步开启shadow：开启指定投射阴影物和被投射阴影物的阴影投射属性 castShadowreceiveShadow// 投射阴影物体cube.castShadow = true// 被投射阴影物体plan.receiveShadow = true开启指定光源的阴影投射属性 castShadowspotLight.castShadow = true开启渲染器Renderer的阴影贴图shadowMaprenderer.shadowMap.enabled = true添加阴影之后的效果 Stats 性能检测插件 Stats能够检测当前屏幕的fps值fps : frame per secondimport Stats from three/examples/jsm/libs/stats.moduleconst stats = new Stats()document.body.appendChild(stats.domElement)function animate() requestAnimationFrame(animate) stats.update() // 更新状态监控器 renderer.render(scene,camera) AnimationsrequestAnimationFrame requestAnimationFrame(nextFrameFun)function nextFrameFun()requestAnimationFrame相当于告诉浏览器绘制下一帧时调用的函数，threeJs中的更新函数一般在requestAnimationFrame指定的函数中调用function animation() requestAnimationFrame(animation) controls.upadte() // 更新轨道控制器 stats.update() // 更新帧监听器 renderer.render(scene,camera) // 渲染器重渲染 GUIdat.gui lil-gui提供快速编辑渲染参数的工具插件dat.gui - githubhttps://github.com/dataarts/dat.gui Resizeresize 需要在window的resize事件时做下面两步window.addEventListener(resize,resize)function resize() camera.aspect = window.innerWidth/window.innerHeight // 修改宽高比值 camera.updateProjectionMatrix() // 更新视图矩阵 renderer.setSize(window.innerWidth,window.innerHeight) // 更新渲染器宽高 render result"},{"title":"Requirements - 准备工作","path":"/wiki/ThreeJs/learning_01_requirements.html","content":"官方提供的一个超酷的Demo Eye texture raytracing demohttps://www.vill.ee/eye/这真是...泰裤辣！ Things that Three.js makes easy geometries 三维图形的创建 Aniamating and moving 三维场景内的图形动画和变换 textures and materials 纹理和材质 light sources 光源 3D-modeling 3D模型 postprocessing effects 后期渲染效果 custom shaders 自定义着色器 point clouds 点云 two types of 3D-based renderer WebGL-based renderer由Three.js提供CSS 3D-based renderer用于创建基于CSS的3D场景优势：大部分的PC和移动设备浏览器都支持支持在3D空间中直接渲染 HTML元素 Requirements to use Three.jsGetting the source code Setting up a local web server UnixLinuxMac systems一般都有Python环境，因此可以直接开启本地服务器：python -m SimpleHTTPServerNode.js有Node环境可以直接用npm安装http-serversimple-http-server包：npm install -g http-serverhttp-servernpm install -g simple-http-servernserverMongoose没有Python和Node环境的可以用Mongoose，将系统对应版本的Mongoose可执行文件放到指定目录下运行。https://code.google.com/archive/p/mongoose/downloadshttps://code.google.com/archive/p/mongoose/downloadsSecurity exceptionsChromeFirefox启动Chrome时在命令后面加上后缀：–disable-web-securityWindowschrome.exe –disable-web-securityLinuxgoogle-chrome –disable-web-securityMacopen -a Google\\ Chrome –args –disable-web-security在导航栏输入url：about:config进入配置项搜索 security.fileuri.strict-origin_policy 变量改成falseMixed content一般的网页使用的都是https协议，但是在项目之中调用的第三方接口时使用的可能是http协议，版本比较新的Chrome和FireFox浏览器会自动将http协议升级为https协议，这是为了避免安全警告，但如果第三方不支持https协议，就会报Mixed content错误。ChromeFireFox参考博客https://blog.csdn.net/weixin_42393724/article/details/109775036点击url栏左侧铁锁按钮（查看网站信息）点击网站设置将不安全内容的权限修改为允许FireFox官网对混合内容的详细介绍https://support.mozilla.org/zh-CN/kb/%E9%98%BB%E6%AD%A2%E6%B7%B7%E5%90%88%E5%86%85%E5%AE%B9?as=u&utm_source=inproduct&redirectslug=how-does-content-isnt-secure-affect-my-safety&redirectlocale=en-US点击url左侧铁锁按钮点击安全连接点击暂时解除保护按钮"},{"title":"CSS3DRenderer：元素周期表","path":"/wiki/ThreeJs/official_demo_01_periodictable.html","content":"https://threejs.org/examples/#css3d_periodictablehttps://threejs.org/examples/#css3d_periodictable CSS3D-PeriodicTable Intro 使用CSS3DObject创建周期表卡片，组合成不同的3D形状Render： CSS3DRendererControls： TrackballControlsminDistance： 500maxDistance： 6000Camera： PerspectiveCamerafov： 40near： 1far： 10000初始z： 10000先不管这个demo里奇奇怪怪的好几种图形变化，只需要关注几点：最开始时卡片的坐标位置每次变化结束时卡片的坐标位置卡片中间的变换过程TIP这个例子很像在上体育课时，学生们在操场上自由活动，这时的位置都是随机的，一旦体育老师吹哨集合， 学生们归队到原先指定的位置（事先安排好的）这样就把实现效果的步骤拆分为了以下部分：初始化卡片坐标（随机）计算出卡片在结束后应该的坐标通过Tween实现卡片移动的连续效果 步骤1：准备工作 ”图形学的大部分工作实际上都花在了数据分析上“ ————谁说的来着除了scene、camera、renderer、controls这些基础场景元素外，还有resize、animation等标配函数外，还有一个最最关键的东西需要准备：元素表数据，官方demo使用的是一个类似index索引的包含5个属性的完全被打平的数组：const table = [//简称 全称 相对原子质量 行数 列数 H, Hydrogen, 1.00794, 1, 1, He, Helium, 4.002602, 18, 1, Li, Lithium, 6.941, 1, 2, Be, Beryllium, 9.012182, 2, 2, B, Boron, 10.811, 13, 2, C, Carbon, 12.0107, 14, 2, // ....]初始化场景中的实体：function init() camera = new THREE.PerspectiveCamera( 40, window.innerWidth/ window.innerHeight, 1, 10000 ) camera.position.z = 3000 scene = new THREE.Scene() renderer = new CSS3DRenderer() renderer.setSize(window.innerWidth,window.innerHeight) document.getElementById(container).appendChild(renderer.domElement) controls = new TrackballControls(camera, renderer.domElement) controls.minDistance = 500 // 最小距离 controls.maxDistance = 6000 // 最大距离 controls.addEventListener(change, render)function render() renderer.render(scene, camera)这里使用的是TrackballControls，里面设置了2个参数：minDistance 拉镜最小值maxDistance 拉镜最大值窗口大小resize事件：function animation() window.requestAnimationFrame(animation) controls.update() TWEEN.update() // 更新TWEEN动画帧函数：function animation() window.requestAnimationFrame(animation) controls.update() TWEEN.update() 步骤2：初始点位和最终点位计算 在整个变化的过程中，都需要一个objects数组，这个数组存放所有渲染出来的CSS3DObject实例，同时还需要一个target数组，和objects数组中的物体一一对应，因为target中存放的实际是objects中元素对应的目标点位和旋转角度，因此可以使用Object3D对象存储const objects = []const targets = []初始化的点位采用随机的方式生成， for(let i = 0; itable.length;i+=5) // 1、 创建dom元素 const element = document.createElement(div) element.className = element element.style.background = `rgba(0,127,127,$Math.random()*0.5+0.25)` const number = document.createElement(div) number.className = number number.textContent = (i/5)+1 element.appendChild(number) const symbol = document.createElement(div) symbol.className = symbol symbol.textContent = table[i] element.appendChild(symbol) const details = document.createElement(div) details.className = details details.innerHTML = table[i+1]+br+table[i+2] element.appendChild(details) const objectCSS = new CSS3DObject(element) // 初始化坐标 在[-2000, 2000]的范围之内 objectCSS.position.x = Math.random() * 4000 - 2000 objectCSS.position.y = Math.random() * 4000 - 2000 objectCSS.position.z = Math.random() * 4000 - 2000 scene.add(objectCSS) objects.push(objectCSS) // 最终坐标 const object = new THREE.Object3D() object.position.x = ( table[ i + 3 ] * 140 ) - 1330; object.position.y = - ( table[ i + 4 ] * 180 ) + 990; targets.table.push(object)其中计算特定卡片在场景中的位置，实际上用到的是：// col = 总列数 colIndex = 当前列数 cw = 单张卡片宽度// row = 总行数 rowIndex = 当前行数 ch = 单张卡片高度x = ( colIndex - (col+1)/2 ) * cwy = ( (row+1)/2 - rowIndex ) * ch球形、螺旋形、栅格形的变换原理也是完全一致的，不同的是计算的方式:球形坐标计算 球形坐标系一个球形坐标系需要3个参数： r(radius-半径) θ(polar angle - 极角) 范围在 0-π 之间 φ(azimuthal angle - 方位角) 范围在 0-2π 之间 这里对球形坐标的计算只使用到每个元素的index索引值: 极角的计算首先将index映射到-1到1的范围之内，再通过反余弦转换为极角值： 计算极角值时，需要注意，arccos函数的参数范围在-1到1之间，因此需要现将i索引值相对l映射到-1到1之间（超出这个范围，Math.acos返回NaN） 方向角的范围需要在0-2π之间，因此在phi之前需要加一个乘数因子，用于扩大坐标之间的间隔。 // i=元素索引 l=元素总数const phi = Math.acos(i*2/l - 0.5) // 极角值const theta = Math.sqrt(l * Math.PI) * phi // 方向角 使用Vector3.setFromSphericalCoords获取到坐标， object.position.setFromSphericalCoords(800, phi, theta) 这样得到了坐标点，接下来需要让卡片转向，实际上就是将卡片坐标P与原点O相连的矢量OP垂直于卡片表面，可以使用Vector3.multiplyScalar创建一个在OP延长线上的坐标点，然后让卡片转向它(lookAt)： vector.copy(object.position).multiplyScalar(2)object.lookAt(vector) 最终实现球形映射： const vector = new THREE.Vector3()for(let i = 0, l = objects.length;iobjects.length;i++) const phi = Math.acos( -1 +(2*i)/l ) // -1 - 1 const theta = Math.sqrt(l * Math.PI) * phi const object = new THREE.Object3D() object.position.setFromSphericalCoords(800, phi, theta) vector.copy(object.position).multiplyScalar(2) object.lookAt(vector) targets.sphere.push(object) 螺旋坐标的计算 圆柱坐标系圆柱坐标系的三个参数： 镜像距离 方位角 高度 通过索引计算方向角, const theta = i * 0.175 乘以一个较小的参数用于均匀分布， 接下来计算高度： const y = (-i*8)+450 通过Vector3.setFromCylindricalCoords将坐标转换到柱状坐标系上，并以和Sphere同样的方式对物体进行旋转： object.position.setFromCylindricalCoords(900,theta,y)vector.x = object.position.x * 2;vector.y = object.position.y;vector.z = object.position.z * 2;object.lookAt(vector) 最终实现螺旋分布： for(let i =0;iobjects.length;i++) const theta = i * 0.175 + Math.PI const y = -(i*8)+450 const object = new THREE.Object3D() object.position.setFromCylindricalCoords(900, theta, y) vector.x = object.position.x * 2; vector.y = object.position.y; vector.z = object.position.z * 2; object.lookAt(vector) targets.helix.push(object) 实际上，使用球形坐标也能实现螺旋的效果，但是是球形螺旋体： const phi = Math.acos( -1 +(2*i)/l ) // -1 - 1const theta = 10 * phi 栅格坐标计算 for(let i = 0;iobjects.length;i++) const object = new THREE.Object3D() object.position.x = ((i%5) * 400) - 800 object.position.y = (-(Math.floor(i/5)%5)*400) +800; object.position.z = (Math.floor(i/25))* 1000 - 2000; targets.grid.push(object) 步骤3：过渡函数 https://tweenjs.github.io/tween.js/docs/user_guide.htmlhttps://tweenjs.github.io/tween.js/docs/user_guide.html通过TWEEN实现坐标的转换。每次切换图形时，都会触发过渡函数，TWEEN的使用方法非常简单，类似于Gsap或animate keyframe,需要将物体的position和rotation移动到对应的位置： for(let i =0;iobjects.length;i++) const object = objects[i] const target = targets[i] new TWEEN.Tween(object.position) .to( x:target.position.x, y:target.position.y, z:target.position.z, , (Math.random()+1)*duration) .easing(TWEEN.Easing.Exponential.InOut) .start() new TWEEN.Tween(object.rotation) .to( x:target.rotation.x, y:target.rotation.y, z:target.rotation.z, ,(Math.random()+1)*duration) .easing(TWEEN.Easing.Exponential.InOut) .start()变换结束后，需要调用render函数进行重绘：new TWEEN.Tween(this) .to(,duration*2) .onUpdate(render) .start()另外，还需要在最新发起的变换之前，结束当前正在进行的变换：TWEEN.removeAll()否则，在频繁的变换之后，会出现变换错乱的现象：最后，需要在帧动画中对TWEEN进行更新：TWEEN.update() 其他版本"},{"title":"CSS3DRenderer：Sprite","path":"/wiki/ThreeJs/official_demo_02_sprite.html","content":"https://threejs.org/examples/#css3d_spriteshttps://threejs.org/examples/#css3d_sprites Sprite用于创建总是面对相机的实体，CSS3DSprite则是用于创建总是面对相机的三维定位的dom元素。创建CSS3DSprite的方法和CSS3DObject一样：const object = new CSS3DSprite(domElement)金属表层球体实际上是一张图片：const image = document.createElement(img) // 创建图片元素image.addEventListener(load, function() // 初始化坐标 for(let i = 0; i particlesTotal; i++) const object = new CSS3DSprite(image.cloneNode()) // 创建CSS3DSprite object.position.x = Math.random() * 4000 - 2000 object.position.y = Math.random() * 4000 - 2000 object.position.z = Math.random() * 4000 - 2000 scene.add(object) objects.push(object) transition())image.src = ./assets/img/sprite.png这个例子的变换原理和 元素周期表 完全一样，需要额外介绍的是几种不同图形的坐标的计算方式。波浪面这里的波浪面以xz平面为水平面，y方向波形起伏。 由于波浪面形状是由无数点位组成的，首先需要计算出这些点位的坐标： amountX：沿x轴方向，一行的点数 amountZ：沿z轴方向，一行的点数 separationPlane：点与点之间的间距 知道这些之后就可以得到一张平面，但是还需要给平面一个位移，使其从xz平面第一象限的位置移动到正中间: // 实际上就是计算出平面宽高的一半const offsetX = (amountX-1)*separationPlane/2;const offsetZ = (amountZ-1)*separationPlane/2; x轴和z轴的计算都比较简单： // 点位序号 = iconst x = (i%amountX)*separationPlane - offsetX;const z = Math.floor((i/amountX)%amountZ)*separationPlane - offsetZ; y轴计算是xz轴坐标的结合，其中涉及到一些调幅和三角函数的原理，我不懂就不多bb了 const y = (Math.sin(0.5*x) + Math.sin(0.5*z)) * 200 球形球形之前用的是Vector3.setFromSphericalCoords，这个接口获取到球坐标系下的坐标需要用到3个参数：半径、方位角、极角，当然也可以手动把直角坐标转化为球坐标： // 极角 = theta// 方位角 = phi// 半径 = radiusconst x = radius * Math.cos(theta) * sin(phi) const y = radius * Math.sin(theta) * sin(phi) const z = radius * Math.cos(phi) 除了坐标计算的方式不同之外，这个例子中还有一个不同之处，就是坐标点的存储方式：由于涉及到延时自动切换形状，这里将所有坐标都放在同一个数组中，类似于二维数组打平成一维数组取值：// offset = 当前变换形状的首坐标// current = 当前变换形状的序号// particlesTotal = 数组总数const offset = current * particlesTotal * 3最后在AnimationFrame函数中，添加了一个物体跟随x轴位置，随时间进行动态收缩的动画，其中用到了performance.now()用于获取一个高精度的时间帧:const time = performance.now()for(let i = 0, l = objects.length; i l; i++) const object = objects[i] const scale = Math.sin(Math.floor(object.position.x) + time) * 0.002 * 0.3 + 1 object.scale.set(scale, scale, scale) 衍生样式"},{"title":"Camera","path":"/wiki/ThreeJs/official_doc_01_camera.html","content":"camera array 相机阵列ArrayCamera 多机位案例ArrayCamera文档支持添加多个subCamera子相机，通过设置子相机的viewport来摆设机位：// 机位数量const AMOUNT = 6const ASPEC_RATIO = window.innerWidth / window.innerHeightconst WIDTH = (window.innerWidth / AMOUNT) * window.devicePixelRatioconst HEIGHT = (window.innerHeight / AMOUNT) * window.devicePixelRatiofor(let y = 0; yAMOUNT; y++) for(let x = 0; x AMOUNT; x++) // 创建子相机 const subcamera = new THREE.PerspectiveCamera( 40, ASPEC_RATIO, 0.1, 10 ) // 设置视口的坐标和宽高 subcamera.viewport = new THREE.Vector4( Math.floor(x * WIDTH), Math.floor(y * HEIGHT), Math.ceil(WIDTH), Math.ceil(HEIGHT) ) // 设置机位 subcamera.position.set( x/AMOUNT - 0.5, 0.5 - y/AMOUNT, 1.5 ) // 调整焦距 subcamera.position.multiplyScalar(2) subcamera.lookAt(0, 0, 0) subcamera.updateMatrixWorld() cameras.push(subcamera) // 创建相机阵列camera = new THREE.ArrayCamera(cameras)camera.position.z = 3关键点对相机viewport的布局，需要在window.resize中进行重新排版，通过camera.cameras获取到所有子相机的列表，更新相机的比例和尺寸时，不仅仅要更新子相机的，还要更新ArrayCamera类型的父相机：camera.aspect = ASPEC_RATIOcamera.updateProjectionMatrix()for(let y = 0; y AMOUNT; y++) for(let x = 0;xAMOUNT;x++) const subcamera = camera.cameras[AMOUNT * y + x]; subcamera.viewport.set( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) ); subcamera.aspect = ASPEC_RATIO subcamera.updateProjectionMatrix() 使用到和比例相关的数据，都用到了window.devicePixelRatio，这个值一般用于根据屏幕的分辨率调整css的px大小，因为多机位涉及到视口的定位，所以需要对渲染画布的分辨率也进行调整：renderer.setPixelRatio(window.devicePixelRatio)使用ArrayCamera，能够实现多机位拍摄的效果：多机位拍摄使用多机位拍摄的动态背景蒙版 StereoCamera VR相机StereoCamera官方文档StereoEffectSteareoEffect能够进行双屏渲染，通过VR头显设备，能够产生立体效果画面。双屏显示原理根据视差原理，左右眼单独接收到的信息各不相同，将各自的信息在大脑合成后，就能组合成对立体空间的感觉，所以在用户佩戴VR头显时，左眼和右眼接收到的显示屏的图像略有差异，相当于对现实世界中左右眼接收到信息的差异，即模拟视察，模拟出来的视差在大脑中合成了立体的视觉场景。也就是SteareoEffect的效果为双屏渲染的基本原理。"},{"title":"RenderPass && EffectComposer","path":"/wiki/ThreeJs/official_doc_02_RenderPass.html","content":"渲染通道特效组合原理 官方案例官方案例 1：点化 + RGB色调分离案例地址 代码实现解析 1.添加随机物体"},{"title":"material 材质","path":"/wiki/ThreeJs/official_doc_03_material.html","content":"材质通用属性flatShading 平面着色flat shading原理使用FlatShading渲染材质，实现平面反光的效果实现效果： 更硬朗、几何感更强的外观（类似于硬阴影的效果）波光粼粼的闪光感"},{"title":"multiple 多场景","path":"/wiki/ThreeJs/official_doc_04_multiple.html","content":"Multiple加载多个场景Scene官方案例"},{"title":"loader 加载器","path":"/wiki/ThreeJs/official_doc_05_loader.html","content":"PCDLoaderPCDLoader 官方文档文章：PCD格式介绍Point Cloud Data 点云格式文件分为文件头和数据部分，需要根据文件头来解析数据部分"},{"title":"NEXT TO 2037","path":"/wiki/ThreeJs/rec_01_NEXT_TO_2037.html","content":"展示地址 技术栈介绍 网站框架：next-react动画元素：lottiedom动画：gsap背景：threejs 3D物体旋转背景使用threejs创建的场景，用到的是 官网案例用滤镜处理多个几何体旋转的场景画面：关键点1：场景搭建关键点2：几何材质和位置关键点3：滤镜scene、camera、renderer基配场景加上fog更有空间景深感加上环境光和直射光scene = new THREE.Scene()camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 1000)camera.position.z = 400camera.lookAt(0,0,0)scene.add(camera)renderer = new THREE.WebGLRenderer(antialias:true)renderer.setPixelRatio(window.devicePixelRatio)renderer.setSize(window.innerWidth, window.innerHeight)renderer.setClearColor(0x000000, 1)renderer.setAnimationLoop(animation)canvasRef?.current?.appendChild(renderer.domElement)const fog = new THREE.Fog(0x000000, 1, 1000)scene.fog = fogconst ambientLight = new THREE.AmbientLight(0xcccccc)scene.add(ambientLight)const directionLight = new THREE.DirectionalLight(0xffffff,3)directionLight.position.set(1,1,1)scene.add(directionLight)材质开启 flatShading 逐片元渲染，增强多边体硬朗的印象创建物体，并进行随机映射：将物体坐标映射到[-1,1]之间的随机位置将物体坐标缩放到[0, 400]之间随机的大小将物体随机缩放[1,50]之间的大小将物体沿x、y、z轴进行随机旋转const geometry = new THREE.SphereGeometry(1,4,4)const material = new THREE.MeshPhongMaterial( color:0xffffff, flatShading:true)object = new THREE.Object3D()for(let i = 0;i 100 ; i++) const element = new THREE.Mesh(geometry,material) // normalize 规范化 element.position.set( Math.random()-0.5, Math.random()-0.5, Math.random()-0.5, ).normalize() // 随机映射 element.position.multiplyScalar(Math.random() * 400) const scale = Math.random() * 50 element.scale.set(scale,scale ,scale) element.rotation.set( Math.random()*2, Math.random()*2, Math.random()*2, ) object.add(element)scene.add(object)RenderPass EffectComposer添加2层滤镜：DotScreenShader 点化滤镜RGBShiftShader rgp分离滤镜composer = new EffectComposer(renderer)composer.addPass(new RenderPass(scene, camera))const effect1 = new ShaderPass(DotScreenShader)effect1.uniforms[scale].value = 4composer.addPass(effect1)const effect2 = new ShaderPass(RGBShiftShader)effect2.uniforms[amount].value = 0.003composer.addPass(effect2)const effect3 = new OutputPass()composer.addPass(effect3) lottie动画lottie-react 官网文档为了在react中更方便的使用Lottie，可以直接安装lottie-react库：npm i lottie-reactlottie组件展示动画需要用到的json动画文件，可以在 LottieFiles 中获取，网站中有很多艺术家分享的开源动画。将动画json文件直接引入，注入Lottie组件的animationData属性中，就能实现lottie动画：import AppleAnimation from ./Apple_Animation.jsonimport Lottie from lottie-reactexport default function Page() return ( Lottie animationData=AppleAnimation / ) GSAP动画效果官网介绍安装gsap库npm i @gsap/react, gsap注册gsap插件：import gsap from gsap;gsap.registerPlugin(useGSAP);"},{"title":"Custom Mouse 自定义Cursor","path":"/wiki/ThreeJs/rec_02_Custom_Mouse.html","content":"项目介绍项目地址 资源链接 three webgl loader pcdCodePen参考链接Custom Dot Cursor 自定义光标CodePen Home star background mouse hover ver.2 背景移动Lottie动画来源：Free 3D Shape Animation AnimationFree App Loading Animation 03 AnimationFree Background looping animation AnimationFree click Animation字体资源：Orbitron 自定义Cursor参考CodePen htmlcssjs在光标移动的父容器Page中，创建自定义光标容器：body class=body-content!-- 光标外环 -- div class=cursor-dot-outline/div!-- 光标焦点 -- div class=cursor-dot/div/body加上随意样式，最好是轮廓线条流畅的形状：:root --primary:#00ff2a;body width:50vw; height:50vh; overflow:hidden; position:relative; cursor:none.cursor-dot-outline,.cursor-dot position:absolute; pointer-events: none; top:0; left:0; border-radius:50%; transform:translate(-50%, -50%); opacity: 0; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;.cursor-dot-outline width:50px; height: 50px; background:rgb(from var(--primary) r g b / 0.2);.cursor-dot width:8px; height:8px; background:var(--primary);设计控制光标的类，需要注意一些交互事件的触发时机：鼠标点击事件效果：点击轮廓变大，焦点变小，松开恢复原样绑定事件：mousedownmouseup鼠标进入和交互元素事件效果：移入轮廓变大，焦点变小，移出恢复原样绑定事件：交互元素的mouseovermouseleave鼠标进入离开屏幕事件效果：进入屏幕透明度为1，离开屏幕透明度为0绑定事件：mouseentermouseleave鼠标移动事件效果：移动鼠标，焦点定位，轮廓跟随绑定事件：mousemoveclass Cursor /** * contentDom 容器dom * dotDom 焦点dom * outlineDom 轮廓dom */ constructor(contentDom, dotDom, outlineDom) /** * _x 轮廓圆的x坐标 */ this. _x = 0 /** * _y 轮廓圆的y坐标 */ this._y = 0 /** * endX 鼠标焦点的x坐标 */ this.endX = window.innerWidth / 2 /** * endY 鼠标焦点的y坐标 */ this.endY = window.innerHeight / 2 /** * delay 延迟的步数 */ this.delay = 8 /** * cursorVisible 自定义光标可见度 */ this.cursorVisible = true /** * cursorEnlarged 自定义光标是否放大 */ this.cursorEnlarged = false; /** * $content 鼠标容器dom */ this.$content = contentDom /** * $dot 焦点dom */ this.$dot = dotDom /** * $outline 外轮廓dom */ this.$outline = outlineDom /** * dotSize 焦点宽度 */ this.dotSize = dotDom.offsetWidth /** * outlineSize 外轮廓宽度 */ this.outlineSize = outlineDom.offsetWidth this.setupEventListeners() this.updateOutlineDot() /** * 绑定注册事件 */ setupEventListeners() this.$content.querySelectorAll(a).forEach(el= el.addEventListener(mouseover, ()= this.cursorEnlarged = true this.toggleCursorSize() ) el.addEventListener(mouseout,()= this.cursorEnlarged = false this.toggleCursorSize() ) ) this.$content.addEventListener(mousedown,()= this.cursorEnlarged = true this.toggleCursorSize() ) this.$content.addEventListener(mouseup,()= this.cursorEnlarged = false this.toggleCursorSize() ) this.$content.addEventListener(mouseenter,()= this.cursorVisible = true this.toggleCursorVisibility() ) this.$content.addEventListener(mouseleave,()= this.cursorVisible = false this.toggleCursorVisibility() ) this.$content.addEventListener(mousemove,e= const rect = e.target.getBoundingClientRect() this.endX = rect.left + e.offsetX this.endY = rect.top + e.offsetY // console.log(`RectLeft=$rect.left RectTop=$rect.top OffsetX=$e.offsetX OffsetY=$e.offsetY`) this.$dot.style.top = `$this.endYpx` this.$dot.style.left = `$this.endXpx` ) /** * 更新OutlineDot的位置 */ updateOutlineDot() this._x += (this.endX - this._x) / this.delay this._y += (this.endY - this._y) / this.delay this.$outline.style.top = `$this._ypx` this.$outline.style.left = `$this._xpx` requestAnimationFrame(this.updateOutlineDot.bind(this)) /** * 切换cursor的尺寸 */ toggleCursorSize() if(this.cursorEnlarged) this.$dot.style.transform = `translate(-50%, -50%) scale(0.7)` this.$outline.style.transform = `translate(-50%, -50%) scale(1.5)` else this.$dot.style.transform = `translate(-50%, -50%) scale(1)` this.$outline.style.transform = `translate(-50%, -50%) scale(1)` /** * 切换cursor的显隐 */ toggleCursorVisibility() if(this.cursorVisible) this.$dot.style.opacity = 1 this.$outline.style.opacity = 1 else this.$dot.style.opacity = 0 this.$outline.style.opacity = 0 背景跟随鼠标晃动参考CodePen 背景图片dom：body div class=background-image/div/body添加样式，注意背景图片需要比父容器稍微大一些，这样即便在上下左右晃动时图片也不会被晃出父容器：* margin:0; padding:0; background-repeat: no-repeat; background-size:cover;body width:100vw; height:100vh; overflow:hidden;.background-image width:120%; height:120%; background-image: url(./mountains.jpg);添加鼠标跟随晃动js脚本，核心方法就是将鼠标相对屏幕的坐标，转换为背景图片的偏移量。const bg = document.querySelector(body)let mouse_endX = 0, mouse_endY = 0let mouse_x = 0, mouse_y = 0let delay = 10bg.addEventListener(mousemove, e= // 将鼠标移动的绝对距离由 [0, 1] 映射到 [0, 10] 上 mouse_endX = e.clientX / window.innerWidth * 10 mouse_endY = e.clientY / window.innerHeight * 10)// 跟随效果function updateBackPosition() mouse_x += (mouse_endX - mouse_x) / delay mouse_y += (mouse_endY - mouse_y) / delay bg.style.transform = `translate3d($-mouse_x%, $-mouse_y%, 0)` requestAnimationFrame(updateBackPosition)updateBackPosition() 其它3D模型部分的实现使用的是官方文档中，PCDLoader部分的Demo官方DemoPCDLoader 鼠标点击效果添加鼠标点击出出现的波纹动画为是用Lottie实现的，思路就是在获取鼠标点击处的坐标，在点击数组中添加新的点位，页面根据点击数组响应式渲染新Lottie组件，监听Lottie组件的onComplete事件，确保在动画播放结束之后删除点击数据：import Lottie from lottie-react;import Animation_Clicking from @/assets/Animation/Animation_Clicking.json;interface ConfettiVO /** * 礼花唯一标识 */ id:number, /** * x坐标 */ x:number, /** * y坐标 */ y:number// 点击尺寸const confetti_w = 100, confetti_h = 100;let idCounter = 0;export default function CustomDotCursorComp() /** * 鼠标点击，新增效果 */ const [confettiList, setConfettiList] = useStateConfettiVO[]([]) function addConfetti(event: any): any const newConfetti: ConfettiVO = id: idCounter++, x: event.pageX, y: event.pageY, setConfettiList([...confettiList, newConfetti]) /** * 动画播放结束，将点位清除 * @param confetti */ function animationComplete(confetti: ConfettiVO) setConfettiList(confettiList.filter(point = point.id !== confetti.id)) return ( div onMouseDown=addConfetti confettiList.map((point) = return Lottie key=point.id animationData=Animation_Clicking className=styles[mouse-confetti] style= top: `$point.ypx`, left: `$point.xpx`, width: `$confetti_wpx`, height: `$confetti_hpx` loop=false onComplete=() = animationComplete(point) / ) div/ )click事件bug这部分效果的实现存在一个bug，就是自定义光标监听了焦点的mousedown和mouseup事件，鼠标点下和抬起构成一个完整的触发效果，但是同时在鼠标点下时创建了一个波纹效果，波纹效果dom遮盖住了鼠标的mouseup事件的触发，所以导致鼠标点下的缩放效果无法正常实现。解决方法：将波纹效果dom的css属性point-event设置为none"},{"title":"WebGL概述","path":"/wiki/WebGL/chapter_01_01.html","content":"本书源码访问地址 https://sites.google.com/site/webglbook/home/downloadshttps://sites.google.com/site/webglbook/home/downloads WebGL的起源PC常用三维图形渲染技术 Direct3D 微软DirectX技术的一部分一套由微软控制的编程接口用于Windows平台OpenGL免费开源，可以在Macintoch、Linux、Windows系统上使用最初由SGI（Silicon Graphics Inc）开发1992年发布为开源标准OpenGL ESOpenGL的一个特殊版本专门用于嵌入式设备2003~2004首次提出2007 ES升级2.02012 ES升级3.0WebGL基于OpenGL ES 2.0 着色器 OpenGL 2.0支持了一项非常重要的特性：可编程着色器方法（programmable shader functions） 着色器语言（shading language）OpenGL ES 2.0 基于 OpenGL着色器语言（GLSL）。GLSL 也称 OpenGL ES着色器语言（GLSL ES）。WebGL也使用GLSL ES编写着色器。 更新与标准化 OpenGL规范的更新与标准化由 Khronos组织 负责。由2011年发布了WebGL规范的第1个版本。 WebGL程序的结构WebGL页面包含三种语言： HTML5 JavaScript GLSL ES 对比传统网页与WebGL网页的结构 通常GLSL ES是以字符串的形式在JS中编写的，因此WebGL网页与传统网页结构相同，只用到HTML文件 和 JavaScript文件。"},{"title":"Custom_Cursor_Switch 自定义光标切换","path":"/wiki/ThreeJs/rec_03_Custom_cursor_switch.html","content":"项目地址 资源链接 CodePen参照链接：Kyle Brumm | Custom Dot CursorFuzionix | Curzr | Free cursor library字体资源： 页面介绍大部分参考的Fuzionix | Curzr | Free cursor library外圈跟踪内点效果参考的是Kyle Brumm | Custom Dot Cursor后续待优化部分：手机端touch事件适配封装成npm组件库添加新鼠标效果"},{"title":"WebGL入门","path":"/wiki/WebGL/chapter_02_01.html","content":"Canvas是什么？canvas标签定义了网页上的绘画区域 canvas标签的引用就像这样： canvas id=example width=500 height=500对于不支持canvas标签的老式浏览器，会显示这条错误信息/canvas 使用canvas绘制矩形 DrawRectangle绘制结果HTML!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody onload=main()canvas id=example width=400 height=400 Please use a browser that supports canvas/canvasscript src=DrawRectangle.js/script/body/htmlJavaScript// DrawRecrangle.jsfunction main() var canvas = document.getElementById(example); if(!canvas) console.log(Failed to retrieve the canvas element) return false; // get the rendering context for 2DCG var ctx = canvas.getContext(2d); ctx.fillStyle = rgba(0,0,255,1.0); //set color ctx.fillRect(120,10,150,150); //fill a rectangele步骤分解步骤1 获取canvas元素var canvas = document.getElementById(example);if(!canvas) console.log(Failed to retrieve the canvas element); return false;步骤2 向该元素请求二维三维图形的“绘图上下文”var ctx = canvas.getContext(2d);上下文 contextgetContext() 的参数用于指定上下文类型，有两种类型： 二维三维步骤3 在绘图上下文调用相应绘图函数ctx.fillStyle = rgba(0,0,255,1.0);ctx.fillRect(120,10,150,150);canvas的坐标系统x轴 坐标系横轴，正方向朝→y轴 坐标系纵轴，正方向朝↓原点 落在左上方 fillRect的参数param1 矩形左上顶点x坐标param2 矩形左上顶点y坐标param3 矩形宽度param4 矩形高度 最短的WebGL程序：清空绘图区HelloCanvas code 清空绘图区效果HelloCanvas.htmlHelloCanvas.jsbody onload=main() canvas id=webgl width=400 height=400 Come on! Why you still use your grammys browser? /canvas script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/cuon-utils.js/script script src=./HelloCanvas.js/script/bodyfunction main() // 获取canvas元素 var canvas = document.getElementById(webgl); // 获取WebGL绘图上下文 var gl = getWebGLContext(canvas); if (!gl) console.log(Congratulate! You meet a bug!) return; // 指定清空canvas颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清空canvas gl.clear(gl.COLOR_BUFFER_BIT);步骤分解获取canvas元素let canvas = document.getElementById(webgl);获取WebGL绘图上下文getContext 和 getWebGLContext getContext接收的参数（’2d’‘3d’’）在不同的浏览器中不同。let gl = canvas.getContext(2d); getWebGLContext在引入的cuon-utils.js中，用于隐藏不同浏览器之间的差异。let gl = getWebGLContext(canvas); 上下文命名技巧之所以有人习惯将绘图上下文命名为gl，是因为 WebGL 是基于 OpenGL ES 的，这样可以将两者的函数名对应起来，比如：gl.clearColor() 与 glClearColor()设置背景色gl.clearColor(0.0, 0.0, 0.0, 1.0);颜色分量取值继承自OpenGL，因此范围在0.0-1.0，RGB颜色越高就越亮。清空canvasgl.clear(gl.COLOR_BUFFER_BIT);BUFFER由于clear继承自OpenGL，基于多基本缓冲区模型，比二维绘图上下文要复杂。清空绘图区域，实际上是清空颜色缓冲区（color buffer）。 也可以通过下面方法清空对应缓冲区："},{"title":"绘制一个点","path":"/wiki/WebGL/chapter_02_02.html","content":"HelloPoint1着色器（shader） 如果要在绘图区域中心绘制一个红点,理论上只需要两步：指定点的颜色指定点的位置和大小gl.drawColor(1.0, 0.0, 0.0, 1.0);gl.drawPoint(0, 0, 0, 10);不幸的是，WebGL依赖一种称为**着色器（shader）**的绘图机制，shader强大且复杂，仅用一条简单绘图命令无法操作。 HelloPoint1 Code 点绘效果HelloPoint1.htmlHelloPoint1.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=./HelloPoint1.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/cuon-utils.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/html// 顶点着色器程序var VSHADER_SOURCE = ` void main() gl_Position = vec4(0.0,0.0,0.0,1.0); //设置坐标 gl_PointSize = 10.0; //设置尺寸 `;//片源着色器程序var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(1.0, 0.0 ,0.0 ,1.0); //设置颜色 `;function main() // 获取canvas元素 var canvas = document.getElementById(webgl); // 获取WebGL绘图上下文 var gl = getWebGLContext(canvas); if (!gl) console.log(绘图上下文获取失败); return; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 设置画板背景色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清空画板 gl.clear(gl.COLOR_BUFFER_BIT); // 绘制点 gl.drawArrays(gl.POINTS, 0, 1); 什么是着色器？What is shader? 顶点着色器片元着色器Vertex shader描述范围： 顶点特性（如位置、颜色等）顶点（vertex）： 二维或三维空间中的一个点（如端点、交点等）Fragment shader描述范围： 进行逐片元处理过程（如光照等）片元（fragment）： 类似于像素（图像的单元） shader程序以String的形式嵌入在JavaScript文件中。 Browser执行JavaScript的绘制流程 简化版流程 使用shader的WebGL程序的结构 顶点着色器片元着色器主程序Vertex shader programvar VSHADER_SOURCE = ` void main() gl_Position = vec4(0.0,0.0,0.0,1.0); gl_PointSize = 10.0; `;Fragment shader programvar FSHADER_SOURCE = ` void main() gl_FragColor = vec4(1.0,0.0,0.0,1.0); `;Main programfunction main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, 1); 步骤分解 1.获取canvas元素let canvas = document.getElementById(webgl);2.获取WebGL绘图上下文let gl = getWebGLContext(canvas);3.初始化着色器initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE);initShaders该函数被定义在 cuon.util.js 中。initShaders()的行为上图有几点需要重点注意的：着色器运行在WebGL系统中，而不是JavaScript系统中。片元着色器接收到的是经过光栅化处理后的片元值。WebGL程序包括运行于Browser的JS和运行于WebGL的shader两个部分4.设置canvas背景色gl.clearColor(0.0,0.0,0.0,1.0);5.清除canvasgl.clear(gl.COLOR_BUFFER_BIT);6.绘图gl.drawArrays(gl.POINTS,0,1) 初始化shader后如何绘图？ 要画一个点，你需要3个关键信息：位置尺寸颜色顶点着色器shader程序本身必须包含一个 main 函数。注意：gl_Position必须赋值，gl_PointSize可选，默认值为1.0顶点着色器的内置变量顶点着色器内置变量对应的GLES数据类型float表示浮点数，因此必须使用浮点形式的数字进行赋值。这样写就会出错：gl_PointSize = 10;vec4矢量（vector），表示由4个浮点数组成的矢量，shader提供了内置函数 vec4() 创建vec4类型的变量。齐次坐标有4个分量组成的矢量被称为齐次坐标。片元着色器片元就是显示在屏幕上的一个像素。gl_FragColor 是片元着色器唯一的内置变量。绘制操作drawArrays() 可以用来绘制各种图形。 gl.drawArrays(gl.POINTS,0,1);第一个参数（gl.POINTS）：表示绘制单点第二个参数（0）：从第1个顶点开始绘制第三个参数（1）：表示仅绘制1个点一旦Vertex_shader执行完毕，Fragment_shader就开始执行 WebGL坐标系统WebGL使用的是三维坐标系统（笛卡尔坐标系）。WebGL坐标系右手坐标系WebGL默认使用右手坐标系，但实际上，WebGL本身不是左手也不是右手坐标系，要复杂得多。右手坐标系坐标映射需要将WebGL的坐标系映射到canvas绘图区中。坐标对应关系如下：WebGL坐标canvas坐标( 0.0, 0.0, 0.0)中心点(-1.0, 0.0, 0.0)左边缘( 1.0, 0.0, 0.0)右边缘( 0.0, -1.0, 0.0)下边缘( 0.0, 1.0, 0.0)上边缘WebGL和canvas坐标映射关系 HelloPoint2对比版本1和版本2 版本1： 点位硬编码在Vertex Shader中版本2： 点位坐标从JS传到Shader程序中 attribute与uniform 要实现从JavaScript程序向Vertex_Shader传输位置信息，有两种方式可以实现（使用哪一个取决于需传输的数据本身）： attribute变量传输的是那些与顶点相关的数据。 uniform变量传输的是那些与顶点无关的数据。 使用attribute变量 attribute变量实际上是一种 GLSL ES 变量，功能就是被用来 从外部向Vertex_Shader内部传输数据 。使用attribute需要经过以下步骤：声明： 在Vertex_Shader中声明attribute变量。赋值： 将attribute变量赋值给gl_Position变量。传输： 向attribute变量传输数据。 HelloPoint2 Code HelloPoint2运行结果HelloPoint2.htmlHelloPoint2.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/cuon-utils.js/script script src=./HelloPoint2.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;// 片源着色器var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,1.0); `;function main() // 获取canvas元素 var canvas = document.getElementById(webgl); // 获取WebGL上下文 var gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(初始化着色器失败); return; // 获取attribute变量的存储位置 var a_Position = gl.getAttribLocation(gl.program, a_Position); if (a_Position 0) console.log(Failed to get the storage location of a_Position); return; // 将顶点位置传输给attribute变量 gl.vertexAttrib3f(a_Position, 0.0, 0.0, 0.0); // 设置canvas背景色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清除canvas gl.clear(gl.COLOR_BUFFER_BIT); // 绘制点位 gl.drawArrays(gl.POINTS, 0, 1); attribute使用步骤详解 步骤一：声明attribute又称 存储限定符 （storage qualifier）。attribute变量必须声明成全局变量，attribute变量声明格式如下： 存储限定符 类型 变量名 attribute变量声明格式 步骤二：获取每个变量都具有一个存储地址，以便通过存储地址向变量传输数据。 getAttribLocation() 用于获取attribute变量的地址。其接收2个参数： 参数1：程序对象（program object）只要引用gl.program即可，包括了Vertex_Shader和Frag_Shader，由 initShader() 函数创建，因此必须在initShader函数调用之后访问。参数2：attribute变量的存储地址步骤三：赋值 如果对于vec4类型的变量通过vertexAttrib3f传参，自然会省略掉1个参数，则默认为1.0。 gl.vertexAttrib3f()同族函数 gl.vertextAttrib[1-4]f有一系列函数，专门负责从JavaScript向Vertex_Shader中的attribute变量传参。 gl.vertextAttrib[1-4]f也提供矢量版本gl.vertextAttrib[1-4]fv：名字以v结尾接受类型化数组参数var position = new Float32Array([1.0, 2.0, 3.0, 1.0]);gl.vertexAttrib4fv(a_Position, position); WebGL函数命名规范 与OpenGL ES 2.0一致。由三个部分组成：基础函数名参数个数参数类型"},{"title":"鼠标绘点","path":"/wiki/WebGL/chapter_02_03.html","content":"ClickedPointsClickedPoints Code ClickedPoints运行结果ClickedPoints.htmlClickedPoints.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/cuon-utils.js/script script src=./ClickedPoints.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;// 片元着色器var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,1.0); `;function main() // 获取canvas元素 let canvas = document.getElementById(webgl); // 获取WebGL上下文 let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 获取attribute变量存储位置 let a_Position = gl.getAttribLocation(gl.program, a_Position); if (a_Position 0) console.log(变量内存获取失败); return; // 注册鼠标点击事件响应函数 canvas.onmousedown = function (ev) click(ev, gl, canvas, a_Position); ; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);var g_points = []; //鼠标点击位置数组function click(ev, gl, canvas, a_Position) var x = ev.clientX; //鼠标点击处x坐标 var y = ev.clientY; //鼠标点击处y坐标 var rect = ev.target.getBoundingClientRect(); x = ((x - rect.left) - canvas.width / 2) / (canvas.width / 2); y = (canvas.height / 2 - (y - rect.top)) / (canvas.height / 2); // 将坐标存储到g_points数组中 g_points.push(x); g_points.push(y); // 清除canvas gl.clear(gl.COLOR_BUFFER_BIT); var len = g_points.length; for (var i = 0; i len; i += 2) // 将点的位置传递到变量中a_Position gl.vertexAttrib3f(a_Position, g_points[i], g_points[i + 1], 0.0); // 绘制点 gl.drawArrays(gl.POINTS, 0, 1); 响应鼠标点击事件下面是onmousedown触发的后续操作 第一步获取鼠标点击的位置，存储于一个数组中。var x = ev.clientX;var y = ev.clientY;var rect = ev.target.getBoundingClientRect();x = ((x-rect.left-canvas.width/2))/(canvas.width/2);y = ((rect.top+canvas.height/2-y))/(canvas.height/2);gl_points.push(x);gl_points.push(y);第二步清空canvasgl.clear(gl.COLOR_BUFFER_BIT);第三步在相应的位置绘制点var len = gl_points.length;for(var i=0;ilen;i+=2) gl.vertexAttrib3f(a_Position,gl_points[i],gl_points[i+1],1.0); gl.drawArrays(gl.POINTS,0,1); 设置坐标的2个注意点 ev.client[X|Y] 是相对 浏览器客户区（client area） 的坐标。canvas坐标系和WebGL坐标系的 原点 和 Y轴正方向 都不同。 坐标映射步骤分解 第一步将鼠标点击位置的坐标从 客户区坐标系 转换到 canvas坐标系 上：( x, y) → ( x - rect.left, y - rect.top)第二步计算 WebGL中心点 相对 canvas坐标系 的坐标位置：( canvas.width2, canvas.height2)第三步计算 鼠标点 相对 *WebGL中心点 的坐标位置：( x - rect.left - canvas.width2 , canvas.height2 - y + rect.top)第四步将坐标进行 归一化处理：( ( x - rect.left - canvas.width )( canvas.width2 ), ( canvas.height2 - y + rect.top )(canvas.height2) ) 颜色缓冲区的重置 为什么要把每一次点击的点位都记录下来？因为WebGL使用的是颜色缓冲区。绘制操作实际上是在颜色缓冲区中进行绘制的，一旦绘制结束，颜色缓冲区就会被 重置，内容就会丢失。因此如果你希望保留已经绘制的内容，就需要保留涉及到绘制的变量所占用的内存地址。"},{"title":"改变点的颜色","path":"/wiki/WebGL/chapter_02_04.html","content":"ColoredPoints本程序主要是介绍： 如何使用 uniform变量 将值传给shader的。 第一步：声明在 Fragment_Shader 中声明好 uniform变量 。第二步：赋值用 uniform变量 向 gl_FragColor 赋值。第三步：传输将颜色数据传输给 uniform变量 。 ColoredPoints Code ColoredPoints运行结果ColoredPoints.htmlColoredPoints.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./ColoredPoints.js/script/headbody onload=main() canvas id=webgl width=400 height=300/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;// 片源着色器var FSHADER_SOURCE = ` precision mediump float; uniform vec4 u_FragColor; void main() gl_FragColor = u_FragColor; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 获取a_Position变量的存储位置 let a_Position = gl.getAttribLocation(gl.program, a_Position); // 获取u_FragColor变量的存储位置 let u_FragColor = gl.getUniformLocation(gl.program, u_FragColor); if (a_Position 0 || u_FragColor ) console.log(获取变量存储位置失败); return; // 注册鼠标点击事件 canvas.onmousedown = function (ev) click(ev, gl, canvas, a_Position, u_FragColor); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);let gl_points = [];let gl_colors = [];function click(ev,gl,canvas,a_Position,u_FragColor) let x = ev.clientX; let y = ev.clientY; let rect = ev.target.getBoundingClientRect(); x = (x - rect.left - canvas.width / 2) / (canvas.width / 2); y = (rect.top + canvas.height / 2 - y) / (canvas.height / 2); gl_points.push([x, y]); gl_colors.push([ Math.random().toFixed(1), Math.random().toFixed(1), Math.random().toFixed(1), 1.0, ]); gl.clear(gl.COLOR_BUFFER_BIT); gl_points.forEach((point, index) = // 将坐标存储到gl_points数组中 gl.vertexAttrib2f(a_Position, point[0], point[1]); // gl.uniform4f( u_FragColor, gl_colors[index][0], gl_colors[index][1], gl_colors[index][2], gl_colors[index][3] ) gl.drawArrays(gl.POINTS, 0, 1); ) uniform 变量向片源着色器传输数据的两种方式uniform的声明uniform用于传输 一致不变的数据 ，其声明格式与 attribute 相同： 存储限定符 类型 变量名 精度限定词（precision qualifier） 用于指定变量的范围和精度。precision mediump float; //表示中等精度 获取uniform变量的存储地址 getUniformLocation与getAttribLocation返回值的区别 getAttribLocation：如果attribute变量不存在，返回 -1 。 getUniformLocation：如果uniform变量不存在，返回 null 。 向uniform变量赋值uniform[1-4]f 的功能与参数与 vertexAttrib[1-4]f 很相近。 uniform4f的功能与参数 uniform4f的同族函数"},{"title":"绘制多个点","path":"/wiki/WebGL/chapter_03_01.html","content":"三维模型的基本单位是什么？ 答： 三角形 △不管三维模型的形状多么复杂，基本组成单位都是三角形。只不过复杂的模型由更多的三角形构成而已。 MultiPoint缓冲区对象（buffer object） 如果你要绘制一个图形，你需要一次性的将图形的顶点全部传入Vertex_Shader。缓冲区对象 支持一次性地向shader传入多个顶点的数据。它是WebGL系统中的一块内存区域。 MultiPoints Code MultiPoints绘制效果MultiPoints.htmlMultiPoints.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./MultiPoints.js/script/headbody onload=main() canvas id=webgl width=500 height=300/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;// 片元着色器var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,1.0); `function main() var canvas = document.getElementById(webgl); var gl = getWebGLContext(canvas); initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE); // 设置顶点位置 var n = initVertexBuffers(gl); if (n 0) console.log(设置顶点位置失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n);function initVertexBuffers(gl) var vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); var n = 3; //点数 // 创建缓冲区对象 var vertexBuffer = gl.createBuffer(); if (!vertexBuffer) console.log(创建缓冲区对象失败); return -1; // 将缓冲区对象绑定到目标 gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); // 向缓冲区对象中写入数据 gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); var a_Position = gl.getAttribLocation(gl.program, a_Position); // 将缓冲区对象分配给a_Position变量 gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); // 连接a_Position变量与分配给它的缓冲区对象 gl.enableVertexAttribArray(a_Position); return n; 使用缓冲区对象流程 缓冲区对象是WebGL系统中的一块存储区。1. 创建缓冲区对象gl.createBuffer()var vertexBuffer = gl.createBuffer();if(!vertexBuffer) console.log(Failed to create the buffer object); return -1;2. 绑定缓冲区对象gl.bindBuffer()gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);3. 将数据写入缓冲区对象gl.bufferData()gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);4. 将缓冲区对象分配给一个attribute变量gl.vertexAttribPointer()var a_Position = gl.getAttribLocation(gl.program,a_Position);gl.vertexAttribPointer(a_Position,2,gl.FLOAT,false,0,0);5. 开启attribute变量gl.enableVertexAttribArray()gl.enableVertexAttribArray(a_Position); 步骤分解 创建缓冲区对象gl.createBuffer()缓冲区对象可以被创建 和 删除 。createBufferdeleteBuffer绑定缓冲区对象gl.bindBuffer()将 缓冲区对象 绑定到WebGL系统中已经存在的 target 上，这个 target 表示 缓冲区对象的用途。 bindBuffer写入缓冲区对象gl.bufferData()不能直接向缓冲区写入数据，只能向与缓冲区绑定的目标写入数据。bufferData分配attribute变量给缓冲区对象gl.vertexAttribPointer()vertexAttribPointer可以将整个缓冲区对象的引用分配给attribute变量vertexAttribPointer开启attribute对象gl.enableVertexAttribArray()通过enableVertexAttribArray，缓冲区对象和attribute变量之间的连接就真正建立起来了。 enableVertexAttribArray函数名会让很多人误解它是用于处理顶点的，这是由于继承自OpenGL。缓冲区对象与attribute变量之间的连接可以通过 enableVertexAttribArray 建立，同时也可以通过 disableVertexAttribArray 关闭。enableVertexArraydisableVertexArray开始绘制gl.drawArrays()shader的执行次数与drawArrays的count参数相一致。因此在MultiPoints中，Shader实际上被执行了3次。顶点着色器执行过程中缓冲区数据的传输过程下面是2个对于gl.drawArrays函数的小实验：drawArrays(gl.POINTS,0,1)drawArrays(gl.POINTS,1,2) 类型化数组WebGL中的很多操作都要用到类型化数组。 提示: 类型化数组不支持 push 和 pop 。创建类型化数组的唯一方法就是使用 new运算符 。 WebGL使用的各种类型化数组 类型化数组的方法、属性和常量"},{"title":"移动、旋转","path":"/wiki/WebGL/chapter_03_03.html","content":"仿射变换 对图形进行平移、旋转和缩放，这样的操作称为 变换（transformations），或 仿射变换（affine transformations） 平移问题描述将点 p(x,y,z) 平移到 p’(x’,y’,z’),在X轴、Y轴、Z轴三个方向平移的距离分别为：Tx，Ty， Tz ，其中 Tz0 。等式x’ x + Txy’ y + Tyz’ z + Tz图解着色器平移是一个 逐顶点操作（per-vertex operation），因此修改应当发生在 顶点着色器 。 Translated TriangleTranslatedTriangle Code TranslatedTriangle运行效果TranslatedTriangle.htmlTranslatedTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./TranslatedTriangle.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; uniform vec4 u_Translation; void main() gl_Position = a_Position + u_Translation; `;// 片元着色器var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.4); `;// 在x、y、z方向上平移的距离var Tx = 0.5, Ty = 0.5, Tz = 0.0;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 设置点位 var n = initVertexBuffer(gl); if (n 0) console.log(缓冲区初始化失败); return; // 将平移距离传输给顶点着色器 var u_Translation = gl.getUniformLocation(gl.program, u_Translation); if (!u_Translation) console.log(变量获取失败); return; gl.uniform4f(u_Translation, Tx, Ty, Tz, 0.0); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); let n = vertices.length / 2; let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return n; 齐次坐标 gl.uniform4f() 需要接收 齐次坐标，齐次坐标共有 4个分量，最后一个分量如果是 1.0， 表示前三个分量是 一个点的三维坐标。 旋转为了描述一次旋转，必须指明以下3个条件： 旋转轴旋转方向旋转角度 右手法则旋转（right-hand-rule rotation） 也称 正旋转，判断标准就是：右手握拳，拇指朝上指向z轴正方向，其余四指指向的方向就是旋转的正方向。 数学表达 问题描述点 p(x,y,z) 旋转 β 角度之后变为了点 p’(x’,y’,z’),旋转是绕Z轴逆时针进行的。旋转等式设 o 为原点设 r op设 α 为 op 与 x轴夹角x’ rcos( α + β ) r(cosαcosβ - sinαsinβ) xcosβ - ysinβy’ rsin( α + β ) r(sinαcosβ + sinβcosα) ycosβ + xsinβz’ z图解着色器依旧是由顶点着色器处理。 Rotated TriangleRotatedTriangle Code RotatedTriangle运行效果RotatedTriangle.htmlRotatedTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./RotatedTriangle.js/script/headbody onload=main() canvas id=webg width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` // x = xcosb - ysinb // y = xsinb + ycosb // z = z attribute vec4 a_Position; uniform float u_CosB, u_SinB; void main() gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB; gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB; gl_Position.z = a_Position.z; gl_Position.w = 1.0; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.4); `;let ANGLE = 90.0;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); if (n 0) console.log(缓冲区初始化失败); return; // 弧度制 let radian = Math.PI * ANGLE / 180; let cosB = Math.cos(radian); let sinB = Math.sin(radian); let u_CosB = gl.getUniformLocation(gl.program, u_CosB); let u_SinB = gl.getUniformLocation(gl.program, u_SinB); if (!u_CosB || !u_SinB) console.log(获取变量失败); return; gl.uniform1f(u_CosB, cosB); gl.uniform1f(u_SinB, sinB); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); if (a_Position 0) console.log(获取变量失败); return -1; gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return vertices.length / 2; 一些小问题 关于uniform变量值的计算位置问题一般将uniform变量放在JS中算好再传递到shader中，这样只需要计算一次，效率更高。 点操作符访问分量问题在shader程序中，无论是对 传入的变量 还是 gl变量，都使用 点操作符 来访问分量。 弧度制参数问题JS内置函数 Math.sin() 和 Math.cos()都只接受 弧度制参数。因此需要将 角度值参数 转换为 弧度制参数: let radian Math.PI * ANGLE 180.0 ; 使用数组传入三角函数值Vertex_Shader let VSHADER_SOURCE = ` attribute vec4 a_Position; uniform vec2 u_CosBSinB; void main() gl_Position.x = a_Position.x*u_CosBSinB.x - a_Position.y*u_CosBSinB.y; gl_Position.y = a_Position.y*u_CosBSinB.x + a_Position.x*u_CosBSinB.y; gl_Position.z = a_Position.z; gl_Position.w = a_Position.w; `; 传入uniform变量 let u_CosBSinB = gl.getUniformLocation(gl.program, u_CosBSinB);gl.uniform2f(u_CosBSinB, cosB, sinB); Rotated Triangle 升级版 蹦蹦床程序中对u_sinB和u_cosB的赋值：gl.uniform1f(u_sinB, Math.sin(currentAngle*Math.PI/180.0));gl.uniform1f(u_cosB, Math.cos(currentAngle));"},{"title":"变换矩阵","path":"/wiki/WebGL/chapter_03_04.html","content":"变换矩阵：旋转变换矩阵（Transformation matrix） 为什么需要变换矩阵？如果我们要实现一个 旋转后平移的操作，需要以下的等式： let VSHADER_SOURCE = ` attribute vec4 a_Position; uniform vec4 u_Transition; uniform vec2 u_SinCos; void main() gl_Position.x = a_Position.x*u_SinCos.x - a_Position.y*u_SinCos.y + u_Transition.x; gl_Position.y = a_Position.y*u_SinCos.x + a_Position.x*u_SinCos.y + u_Transition.y; gl_Position.z = a_Position.z + u_Transition.z; gl_Position.w = a_Position.w; `; 可以看到变换式变得越来越繁琐，但是如果用变量矩阵来实现就能简单很多，变换矩阵（Transformation matrix） 相当适合操作计算机图形。 一些矩阵乘法基本条件 矩阵乘法不满足交换律 矩阵列数必须等于矢量行数 矩阵乘法等式 旋转矩阵（rotation matrix） 变换矩阵：平移需要一个4×4的变换矩阵 因为在平移的等式中存在 常量项 ，因此需要给三维矢量添加 第4个分量 ，同时需要对变换矩阵进行扩充。 4×4的旋转矩阵旋转矩阵的维度扩充 RotatedTriangle_MatrixRotatedTriangle_Matrix Code RotatedTriangle_Matrix运行效果RotatedTriangle_Matrix.htmlRotatedTriangle_Matrix.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./RotatedTriangle_Matrix.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmlvar VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_xformMatrix; void main() gl_Position = u_xformMatrix * a_Position; `;var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.4); `;// 旋转角度let ANGLE = 90.0;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 设置顶点位置 let n = initVertexBuffers(gl); if (n 0) console.log(缓冲区初始化失败); return; // 创建旋转矩阵 let radian = Math.PI * ANGLE / 180.0; let cosB = Math.cos(radian), sinB = Math.sin(radian); // WebGL中矩阵是列主序的 let xformMatrix = new Float32Array([ cosB, sinB, 0, 0, -sinB, cosB, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]); let u_xformMatrix = gl.getUniformLocation(gl.program, u_xformMatrix); if (!u_xformMatrix) console.log(获取变量失败); return; gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffers(gl) let vertices = new Float32Array([ 0.0, 0.3, -0.3, -0.3, 0.3, -0.3 ]); let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return vertices.length / 2; 一些小问题 传入着色器内的矩阵变量的处理使用一行就能够实现矢量与矩阵的加法： gl_Position = u_xformMatrix * a_Position ; 因为shader内置了常用的矢量和矩阵运算功能。 mat4类型指的是4×4的矩阵类型 两种在数组中存储矩阵元素的方式WebGL和OpenGL的矩阵元素都是按列主序存储在数组中的。 按行主序（row major order） 按列主序（column major order） gl.uniformMatrix4fx()函数名最后一个字母是v，表示可以向shader传输多个数据值。 第二个参数Transpose之所以必须是false 是由于该参数表示 是否转置矩阵，因为WebGL没有提供矩阵转置的方法，所以该参数必须是false。平移：相同的策略运行结果 平移使用的变换矩阵let xformMatrix = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, Tx, Ty, 0.0, 1.0]);变换矩阵：缩放图解等式变换矩阵矩阵数组let xformMatrix = new Float32Array([ Sx, 0, 0, 0, 0, Sy, 0, 0, 0, 0, Sz, 0, 0, 0, 0, 1.0])运行结果"},{"title":"绘制多边形","path":"/wiki/WebGL/chapter_03_02.html","content":"Hello TriangleHelloTriangle Code HelloTriangle运行效果图HelloTriangle.htmlHelloTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./HelloTriangle.js/script/headbody onload=main() canvas id=webgl width=500 height=400/canvas/body/html// 顶点着色器var VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;// 片元着色器var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.4); `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; // 设置顶点位置 let n = initVertexBuffer(gl); if (n 0) console.log(缓存区初始化失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n); function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0,0.5,-0.5,-0.5,0.5,-0.5 ]); let n = vertices.length / 2; // 创建缓冲区 let vertexBuffer = gl.createBuffer(); // 绑定缓冲区 gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); // 写入缓冲区 gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // 分配变量给缓冲区 let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); // 连通变量与缓冲区 gl.enableVertexAttribArray(a_Position); return n;; 基本图形gl.drawArrays()第一个参数mode 通过给第一个参数mode指定不同的值，可以以7种不同的方式来绘制图形：gl.POINTSgl.LINESgl.LINE_STRIPgl.LINE_LOOPgl.TRIANGLESgl.TRIANGLE_STRIPgl.TRIANGLE_FAN Hello RectangleHelloQuad Code HelloQuad运行结果HelloQuad.htmlHelloQuad.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./HelloQuad.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmlvar VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; `;var FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.6); `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); if (n 0) console.log(缓冲区初始化失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);function initVertexBuffer(gl) let vertices = new Float32Array([ -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5, ]); let n = vertices.length / 2; let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return n;"},{"title":"复合变换","path":"/wiki/WebGL/chapter_04_01.html","content":"平移，然后旋转大多数WebGL开发者都使用矩阵操作函数库来隐藏矩阵计算的细节。 矩阵变换库：cuon-matrix.js OpenGL提供了一系列创建变换矩阵的函数，但WebGL都没有。matrix4在 cuon-matrix.js中提供了一种 Matrix4 类，其中封装了许多创建变换矩阵的方法。Matrix4 表示 4×4的矩阵，其实例内部一贯使用 Float32Array类型 来存储矩阵元素。 RotatedTriangle_Matrix4RotatedTriangle_Matrix4 Code RotatedTriganle_Matrix运行结果RotatedTriangle_Matrix4.htmlRotatedTriangle_Matrix4.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/cuon-matrix.js/script script src=./RotatedTriangle_Matrix4.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_xformMatrix; void main() gl_Position = u_xformMatrix * a_Position; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.7); `;let ANGLE = 90.0;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(创建上下文失败); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); if (n 0) console.log(顶点缓冲区初始化失败); return; let xformMatrix = new Matrix4(); xformMatrix.setRotate(ANGLE, 0, 0, 1); let u_xformMatrix = gl.getUniformLocation(gl.program, u_xformMatrix); if (!u_xformMatrix) console.log(获取变量失败); return; gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix.elements); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.3, -0.3, -0.3, 0.3, -0.3 ]); let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return vertices.length / 2; Matrix4.setRotate(ANGLE, x, y ,z) ANGLE： 表示旋转角，是角度制不是弧度制（x，y，z）： 表示旋转轴旋转角度是正值 表示逆时针方向旋转绕x轴逆时针旋转 (1,0,0)绕y轴逆时针旋转 (0,1,0)绕z轴逆时针旋转 (0,0,1) Matrix4类型setIdentity() 将Matrix4实例初始化为 单位阵。let mat4 = new Matrix4();console.log(mat4.setIdentity().elements);/** * [ * 1,0,0,0, * 0,1,0,0, * 0,0,1,0, * 0,0,0,1 * ] */setTranslate(x,y,z) 将Matrix实例设置为 平移变换矩阵，(x,y,z)表示在xyz轴上平移距离。let mat4 = new Matrix4();console.log(mat4.setTranslate(0.3, 0.3, 0.0).elements);/** * [1, 0, 0, 0, * 0, 1, 0, 0, * 0, 0, 1, 0, * 0.30000001192092896, 0.30000001192092896, 0, 1] */setRotate(angle,x,y,z) 将Matrix4实例设置为 旋转变换矩阵。angle 表示旋转角度(x,y,z) 表示旋转轴，无需进行归一化let mat4 = new Matrix4();console.log(mat4.setRotate(90.0, 0, 0,1).elements);/** * [ * 6.123234262925839e-17, 1, 0, 0, * -1, 6.123234262925839e-17, 0, 0, * 0, 0, 1, 0, * 0, 0, 0, 1 * ] */ setScale(x,y,z) 将Matrix4实例设置为 缩放变换矩阵 ，(x,y,z)表示三个轴上的缩放因子。let mat4 = new Matrix4();console.log(mat4.setScale(3.0, 2.0, 1.0).elements);/** * [ * 3, 0, 0, 0, * 0, 2, 0, 0, * 0, 0, 1, 0, * 0, 0, 0, 1 * ] */translate(x,y,z) 将Matrix4实例 乘以一个平移变换矩阵let mat4 = new Matrix4();mat4.setScale(1, 2, 3);console.log(mat4.translate(0.1, 0.5, 0.0).elements);/** * [ * 1, 0, 0, 0, * 0, 2, 0, 0, * 0, 0, 3, 0, * 0.10000000149011612, 1, 0, 1, * ] */rotate(angle,x,y,z) 将Matrix4实例 乘以一个旋转变换矩阵let mat4 = new Matrix4();mat4.setScale(1, 2, 3);console.log(mat4.rotate(90, 0, 1, 0).elements);/** * [ * 6.123234262925839e-17, 0, -3, 0, * 0, 2, 0, 0, * 1, 0, 1.8369702788777518e-16, 0, * 0, 0, 0, 1 * ] */scale(x,y,z) 将Matrix4实例 乘以一个缩放变换矩阵let mat4 = new Matrix4();mat4.setScale(1, 2, 3);console.log(mat4.scale(1, 0.5, 0.3).elements);/** * [ * 1, 0, 0, 0, * 0, 1, 0, 0, * 0, 0, 0.8999999761581421, 0, * 0, 0, 0, 1 * ] */set(m) 将Matrix4实例 设置为m，m必须是一个Matrix4实例。let m = new Matrix4();m.setScale(1, 2, 3);let mat4 = new Matrix4();mat4.set(m);// trueconsole.log(m.elements.toString() === mat4.elements.toString());elements 类型化数组 Floated2Array，包含了Matrix4实例的矩阵元素。 有无set前缀的区别 有set前缀的方法会根据参数计算出变换矩阵，然后将变换矩阵写入到自身中。 没有set前缀的方法会先根据参数计算出变换矩阵，然后将自身与刚刚计算得到的变换矩阵相乘，最终把结果写入到Matrix4对象中。 复合变换3×3矩阵乘法 问题描述需要将图形先平移，再旋转。图解变换等式( 旋转矩阵 × 平移矩阵 ) × 原始坐标 Rotated Translated TriangleRotatedTranslatedTriangle Code RotatedTranslatedTriangle运行结果RotatedTranslatedTriangle.htmlRotatedTranslatedTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./RotatedTranslatedTriangle.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet ANGEL = 60.0;let Tx = 0.5, Ty = 0.0, Tz = 0.0;let VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_ModelMatrix; void main() gl_Position = a_Position * u_ModelMatrix ; gl_Position = u_ModelMatrix *a_Position ; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.8); `;function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.2, -0.25, -0.25, 0.25, -0.25 ]); let vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return vertices.length / 2;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); let modelMatrix = new Matrix4(); let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); modelMatrix.setRotate(ANGEL, 0, 0, 1); modelMatrix.translate(Tx, Ty, Tz); gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);小案例：先旋转再平移对比区别需要调用的方法和顺序都要变换modelMatrix.setTranslate(Tx, Ty, Tz);modelMatrix.rotate(ANGEL, 0, 0, 1);运行结果"},{"title":"动画","path":"/wiki/WebGL/chapter_04_02.html","content":"实现动画的关键就是：不断擦除并重绘动画图形，并且在每次重绘时轻微的改变动画属性。 Rotating TriangleRotatingTriangle Code RotatingTriangle运行效果RotatingTriangle.htmlRotatingTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./RotatingTriangle.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_ModelMatrix; void main() gl_Position = u_ModelMatrix * a_Position; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.5); `;let ANGLE_STEP = 45.0;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); gl.clearColor(0.0, 0.0, 0.0, 1.0); // 三角形当前旋转角度 let currentAngle = 0.0; // 模型矩阵 Matrix4对象 let modelMatrix = new Matrix4(); // 开始绘制三角形 var tick = function () // 更新旋转角 currentAngle = animate(currentAngle); draw(gl, n, currentAngle, modelMatrix, u_ModelMatrix); // 请求浏览器调用tick requestAnimationFrame(tick); ; tick(); function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.25, -0.25, -0.25, 0.25, -0.25 ]); let vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return vertices.length / 2;function draw(gl, n, currentAngle, modelMatrix, u_ModelMatrix) // 设置旋转矩阵 modelMatrix.setRotate(currentAngle, 0, 0, 1); // 将旋转矩阵传输给顶点着色器 gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); // 清除canvas gl.clear(gl.COLOR_BUFFER_BIT); // 绘制三角形 gl.drawArrays(gl.TRIANGLES, 0, n);// 记录上一次调用函数的时刻let g_last = Date.now();function animate(angle) // 计算距离上次调用经过多长时间 var now = Date.now(); var elapsed = now - g_last; // 毫秒 g_last = now; // 根据距离上次调用的时间，更新当前旋转角度 let newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0; return newAngle %= 360; 步骤分解 反复调用绘制函数 tick()tick中实现了关键的2个步骤： 更新角度 重绘 下图的基本步骤可以用来实现各种动画，是3D图形编程的关键技术。 按照指定旋转角度绘制三角形 draw()draw一共有四步操作： step1设置旋转矩阵。modelMatrix.setRotate(currentAngle,0,0,1);step2将旋转矩阵传入Vertex_Shader。gl.uniformMatrix4fv(u_ModelMatrix,false,modelMatrix.elements);step3清除canvas。gl.clear(gl.COLOR_BUFFER_BIT);step4开始绘制。gl.drawArrays(gl.TRIANGLES,0,n);请求再次被调用 requestAnimationFrame()为什么不用setInterval？ 如果要实现 重复执行某个特定的任务，setInterval 是比较常用的方法，但是它存在一个弊端：不管其被调用的标签页是否被激活，其中的setInterval()函数都会反复调用。这会增加浏览器的负荷，requestAnimation只有在标签页激活时才生效。 也可以通过 cancelAnimationFrame 取消请求： 更新旋转角 aniamte()要注意的是：调用requestAnimationFrame(),只是请求浏览器在适当的时机调用参数函数，因此不能保证每次调用间隔的时间相同，需要计算时间间隔，并由时间间隔计算这一帧中三角形的旋转角度。 g_last 上一帧开始的时间elapsed 两帧之间时间间隔 这一帧开始的时间 - g_lastANGLE_STEP1000.0 每毫秒旋转度数旋转变化度数 ANGLE_STEP 1000.0 * elapsed let newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0; Rotating Translated Triangle结合本章内容的小动画"},{"title":"逐片元操作","path":"/wiki/WebGL/chapter_05_02.html","content":"几何形状的装配和光栅化ColoredTriangle 修改MultiAttributeColor里drawArrays函数的第一个参数为 TRIANGLES。gl.drawArrays(gl.TRIANGLES, 0, n);ColoredTriangle运行结果 图元装配与光栅化过程 考虑几个小问题Fragment_Shader如何进行逐片元操作的？答： 传入顶点坐标、图形装配、光栅化、执行片元着色器。 谁来确定哪些像素需要被着色？答： gl.drawArray()函数的第一个参数就决定几何图形的类型，即图元装配过程的最终结果决定需要被着色的像素位置。 谁来负责调用片元着色器？答： 一旦光栅化过程结束后，程序就开始逐片元调用片源着色器。 片元着色器是怎样处理每个片元的？答： 片元着色器计算出该片元的颜色，并写入颜色缓冲区。 逐片元操作步骤获取顶点坐标图元装配：将离散顶点坐标装配成几何图形。光栅化：将装配好的几何图形转化为片元。执行片元着色器图元（primitives）几何图形装配（geometric shape assembly），又称图元装配过程（primitive assembly process），图元（primitives）： 指被装配出的基本图形（点线面）光栅化（rasterization）显示在屏幕上的图形是由 像素 组成的，因此需要将图形转化为 片元，这个过程即称为 光栅化。片元数目 就是图形最终在屏幕上所覆盖的像素数。逐片元操作步骤分解以绘制单色三角形为例step1执行顶点着色器，将缓冲区对象第一个顶点坐标传递给gl_Position，使其存储进入图形装配区域。step2同样方法传入并存储第二个顶点坐标。step3同样方法传入并存储第三个顶点坐标。step4使用传入坐标，根据gl.drawArrays()第一个参数，开始装配图形。step5将图形转化为片元，即光栅化。step6-15逐片元调用片元着色器，计算每个片元的颜色，写入颜色缓冲区。 Colored Triangle本案例可以证明片元着色器对每个片元的操作确实存在。 gl_FragCoord 片元着色器使用 内置变量 gl_FragCoord 来访问片元的坐标。 注意gl_FragCoord采用的是canvas坐标系统。 ColoredTriangle Code ColoredTriangle运行结果ColoredTriangle.htmlColoredTriangle.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./ColoredTriangle.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; `;let FSHADER_SOURCE = ` precision mediump float; uniform float u_Width; uniform float u_Height; void main() gl_FragColor = vec4( 0.0, gl_FragCoord.x/u_Width, gl_FragCoord.y/u_Height, 1.0 ); `;function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); let n = 3; let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return n;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(获取上下文失败); return; if (!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); if (n 0) console.log(创建缓冲区失败); return; let u_Width = gl.getUniformLocation(gl.program, u_Width), u_Height = gl.getUniformLocation(gl.program, u_Height); gl.uniform1f(u_Width, canvas.width); gl.uniform1f(u_Height, canvas.height); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n); varying变量的作用和内插过程内插过程 v_shader中的varying变量在传入f_shader之前经过了内插过程。为什么要将这种在着色器之间传递数值的类型称为varying？答： 因为片元着色器中声明的同名同类型变量和顶点着色器声明的变量实际上并不是一回事。 要绘制一条两端颜色不同的线段，只要向 顶点着色器的varying变量 附上两种颜色，WebGL就会 自动计算出线段上的所有片元（点）的颜色,然后赋值给 片元着色器的varying变量 。 这个过程被称为 内插过程（interpolation process）。光栅化负责将矢量几何图形转变为栅格化的片元（像素）。"},{"title":"颜色与纹理","path":"/wiki/WebGL/chapter_05_01.html","content":"MutiAttributeSize本案例主要介绍如何将多个顶点数据通过缓冲区对象传入顶点着色器 MutiAttributeSize Code MutiAttributeSize运行结果MutiAttributeSize.htmlMutiAttributeSize.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./MutiAttributeSize.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute float a_PointSize; void main() gl_Position = a_Position; gl_PointSize = a_PointSize; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.5); `;function initVertexBuffer(gl) let vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); let sizes = new Float32Array([ 10.0, 20.0, 30.0 ]); let vertexBuffer = gl.createBuffer(); let sizeBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer); gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW); let a_PointSize = gl.getAttribLocation(gl.program, a_PointSize); gl.vertexAttribPointer(a_PointSize, 1, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_PointSize); return sizes.lengthfunction main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(初始化着色器失败); return; let n = initVertexBuffer(gl); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n); 2种支持传递多种顶点数据信息的方式 方法1：创建多个缓冲区对象最简单粗暴的一种方式。要向Vertex_Shader传递多份逐顶点数据信息？只需要为顶点的每种数据建立一个缓冲区就OK了。 **OS：**这种方法就像学校的教科书，每章习题不加在这一章后面，非要配套来一套习题集，做题时两本书加草稿纸摊开桌子乱的笔都找不到。（脑补一下桌子对应的就是运行环境） 方法2：利用vertexAttribPointer的步进和偏移参数创建多个缓冲区比较适合 数据量不大的情况。 更常用的是利用某些机制分别访问统一缓冲区对象中的不同种类数据。这里介绍的是 交错组织（interleaving）即将不同种类数据交叉存储在一个缓冲区中，利用vertexAttribPointer的 步进（stride） 和 偏移(offset) 来获取特定数据。 let verticesSizes = new Float32Array([ 0.0, 0.5, 10.0, // 第一个点 -0.5, -0.5, 20.0, // 第二个点 0.5, -0.5, 30.0, // 第三个点]) MultiAttributeSize_Interleaved本案例主要介绍利用vertexAttribPointer的步进和偏移来获取特定数据。 MutiAttributeSize_Interleaved MutiAttributeSize_Interleaved运行结果MutiAttributeSize_Interleaved.htmlMutiAttributeSize_Interleaved.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./MultiAttributeSize_Interleaved.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute float a_PointSize; void main() gl_Position = a_Position; gl_PointSize = a_PointSize; `;let FSHADER_SOURCE = ` void main() gl_FragColor = vec4(0.0,1.0,0.0,0.4); `;function initVertexBUffer(gl) let verticesSize = new Float32Array([ 0.0, 0.5, 10.0, // 第一个点 -0.5, -0.5, 20.0, // 第二个点 0.5, -0.5, 30.0, // 第三个点 ]) let n = 3; let vertexSizeBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexSizeBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesSize, gl.STATIC_DRAW); let FSIZE = verticesSize.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 3, 0); gl.enableVertexAttribArray(a_Position); let a_PointSize = gl.getAttribLocation(gl.program, a_PointSize); gl.vertexAttribPointer(a_PointSize, 1, gl.FLOAT, false,FSIZE * 3, FSIZE * 2); gl.enableVertexAttribArray(a_PointSize); return n;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBUffer(gl); gl.clearColor(0.0,0.0,0.0,1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n); vertexAttribPointer的作用机制 BYTES_PRE_ELEMENT类型化数组的默认属性，可以表示数组中 每个元素所占的字节数 。 MultiAttributeColor（varying变量）本程序主要介绍如何使Vertex_Shader的数据进入Fragment_Shader。（提前剧透：使用varying变量） MultiAttributeColor MultiAttributeColor运行效果MultiAttributeColor.htmlMultiAttributeColor.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./MultiAttributeColor.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; // varying变量声明 void main() gl_Position = a_Position; gl_PointSize = 10.0; v_Color = a_Color; // 将数据传递给Fragment_Shader `;let FSHADER_SOURCE = ` precision mediump float; varying vec4 v_Color; void main() gl_FragColor = v_Color; // 从顶点着色器接受数据 `;function initVertexBuffer(gl) let verticesColors = new Float32Array([ 0.0, 0.5, 1.0, 0.0, 0.0, -0.5, -0.5, 0.0, 1.0, 0.0, 0.5, -0.5, 0.0, 0.0, 1.0 ]); let n = 3; let FSIZE = verticesColors.BYTES_PER_ELEMENT; let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 5, 0); gl.enableVertexAttribArray(a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 5, FSIZE * 2); gl.enableVertexAttribArray(a_Color); return n;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n); varying变量 varying变量可选类型： float vec[2-4] mat[2-4] 我们在Vertex_Shader中声明了一个varying变量，那Fragment_Shader要怎么接收呢？答：在Fragment_Shader中声明一个同名且同类型的varying变量就可以了。"},{"title":"纹理","path":"/wiki/WebGL/chapter_05_03.html","content":"在矩阵表面贴上图像几个名词 纹理映射（texture mapping）： 根据纹理图像，为光栅化后的每个片元填充适当的颜色纹理（texture）纹理图像（texture image）纹素（texels，texture elements）： 组成纹理图像的像素纹理坐标（texture coordinates）： 决定纹理图像哪个部分用于覆盖 纹理坐标 表示图像上的坐标，同样进行了归一化处理，为了和xy坐标区分，WebGL使用 st坐标系统 。 纹理映射步骤 将纹理坐标映射到顶点上step1-提供纹理准备好映射到几何图形上的纹理图像。step2-配置映射为几何图形配置纹理映射方式。step3-加载纹理加载纹理图像并对其进行一些配置。step4-抽取纹素在片元着色器中将相应纹素从纹理中抽取出来，赋值给片元。 TexturedQuadTexturedQuad TexturedQuad运行效果TexturedQuad.htmlTexturedQuad.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./TexturedQuad.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/html// 第1部分：设置顶点着色器let VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec2 a_TexCoord; varying vec2 v_TexCoord; void main() gl_Position = a_Position; v_TexCoord = a_TexCoord; `;// 第2部分：设置片元着色器let FSHADER_SOURCE = ` precision mediump float; uniform sampler2D u_Sampler; varying vec2 v_TexCoord; void main() gl_FragColor = texture2D(u_Sampler,v_TexCoord); `;// 第3部分：创建坐标缓冲区function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffers(gl); if (n 0) console.log(变量获取失败); return; if (!initTextures(gl, n)) console.log(纹理映射失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0);function initVertexBuffers(gl) let verticesTexCoords = new Float32Array([ -0.5, 0.5, 0.0, 1.0, -0.5, -0.5, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5, -0.5, 1.0, 0.0 ]); let n = 4; let FSIZE = verticesTexCoords.BYTES_PER_ELEMENT; let vertexTexCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, a_Position); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0); gl.enableVertexAttribArray(a_Position); let a_TexCoord = gl.getAttribLocation(gl.program, a_TexCoord); gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2); gl.enableVertexAttribArray(a_TexCoord); return n;// 第4部分：准备纹理function initTextures(gl, n) // 创建纹理对象 let texture = gl.createTexture(); // 获取u_Sampler let u_Sampler = gl.getUniformLocation(gl.program, u_Sampler); // 创建image let image = new Image(); // 注册图像加载事件的响应函数 image.onload = function () loadTexture(gl, n, texture, u_Sampler, image); ; // 浏览器加载图像 image.src = ../img/tobydog.jpg; return true// 第5部分：使用纹理function loadTexture(gl, n, texture, u_Sampler, image) // 对纹理图像进行y轴反转 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 开启0号纹理单元 gl.activeTexture(gl.TEXTURE0); // 向target绑定纹理对象 gl.bindTexture(gl.TEXTURE_2D, texture); // 配置纹理参数 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 配置纹理图像 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image); // 将0号纹理传递给着色器 gl.uniform1i(u_Sampler, 0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLE_STRIP, 0, n); 步骤解析 设置纹理坐标：initVertexBuffers()将顶点坐标分配给a_Position并开启：let a_Position = gl.getAttribLocation(gl.program, a_Position);gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0);gl.enableVertexAttribArray(a_Position);将纹理坐标分配给a_TexCoord并开启：let a_TexCoord = gl.getAttribLocation(gl.program, a_TexCoord);gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2);gl.enableVertexAttribArray(a_TexCoord);配置和加载纹理：initTexture()gl.createTexture()用于创建纹理对象。纹理图像管理单元一共有8个管理纹理图像的纹理单元：gl.TEXTURE[0-7] ，每一个都与 gl.TEXTURE_2D 相关，gl.TEXTURE_2D是 绑定纹理时的纹理目标。 使用 gl.deleteTexture() 删除纹理对象：异步加载纹理图像处于安全考虑，WebGL不运行跨域请求纹理图像。 OpenGL程序 与 WebGL网页 读取纹理图片的区别： OpenGL直接从存储纹理图像的磁盘上读取纹理图像。 WebGL一般情况下需要向浏览器请求图像资源。 为WebGL配置纹理：loadTexture()function loadTexture(gl, n, texture, u_Sampler, image) // 对纹理图像进行y轴反转 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 开启0号纹理单元 gl.activeTexture(gl.TEXTURE0); // 向target绑定纹理对象 gl.bindTexture(gl.TEXTURE_2D, texture); // 配置纹理参数 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 配置纹理图像 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image); // 将0号纹理传递给着色器 gl.uniform1i(u_Sampler, 0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLE_STRIP, 0, n); 纹理配置详细步骤 STEP1：图像Y轴反转gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,1); 为什么要进行Y轴反转？ 答： WebGL与一般格式图片的y轴方向 相反，需要将图片y轴反转才能进行正确映射，或者手动反转映射坐标。 WebGL Y（t）轴方向： ↑图片系统 Y轴方向： ↓ STEP2：激活纹理单元gl.activeTexture(gl.TEXTURE0); 纹理单元（texture unit）是用来干嘛的？ 答： 是WebGL用于 同时使用多个纹理 的一种机制。每个纹理单元有一个 单元编号 来管理一张纹理图像，系统支持的纹理单元的个数取决于： 硬件浏览器的WebGL实现 （通常是8个） STEP3：绑定纹理对象gl.bindTexture(gl.TEXTURE_2D,texture); WebGL的两种纹理类型 可以看到，纹理对象的绑定实际上有2步： 纹理对象的开启 纹理单元 与 纹理对象 的绑定 无法直接操作纹理对象必须将纹理对象绑定到纹理单元上，通过操作纹理单元来操作纹理对象。 STEP4：配置纹理对象的参数gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); 配置涉及的内容都包括哪些？ 纹素获取方式 纹理填充方式 纹理参数可以指定4个值： 纹理获取方式 纹理填充方式 方法名 纹理参数 描述 默认值 图解 参数值 参数描述 放大方法 gl.TEXTURE_MAG_FILTER 小纹理绘制大范围，填充空隙 gl.LINEAR gl.NEAREST 以中心像素为锚点， 按照点位与中心点的曼哈顿距离大小映射 gl.LINEAR 距像素中心最近的四个像素颜色值加权平分求出的，质量更好，开销更大 缩小方法 gl.TEXTURE_MIN_FILTER 大纹理绘制小范围，剔除像素 gl.NEAREST_MIPMAP_LINEAR gl.NEAREST - gl.LINEAR - 水平填充 gl.TEXTURE_WRAP_S 左右侧区域的填充 gl.REPEAT gl.REPEAT 平铺式的重复纹理 gl.MIRRORED_REPEAT 镜像对称式的重复纹理 gl.CLAMP_TO_EDGE 使用纹理图像边缘值 垂直填充 gl.TEXTURE_WRAP_T 上下区域的填充 gl.REPEAT - gl.MIRRORED_REPEAT - gl.CLAMP_TO_EDGE - MIPMAP（金字塔）纹理类型实际上是原始纹理图像的一系列不同分辨率的版本。 曼哈顿距离即直角距离，棋盘距离，（x1，y1）与（x2，y2）的曼哈顿距离为|x1-x2|+|y1-y2|。 STEP5：将纹理图像分配给纹理对象gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,gl.RGB,gl.UNSIGNED_BYTE,image); 纹理数据格式（internalformat） 纹理数据格式的选择要根据 纹理图像的格式：PNG 通常使用 gl.RGBAJPG、BMP 通常使用 gl.RGB灰度图 通常使用 gl.LUMINANCEgl.LUMINANCE_ALPHA流明（luminance）表示物体表面亮度，通常使用物体表面红绿蓝分量值加权平均计算流明。WebGL中，internalformat必须和format一样。 纹理数据类型（type） 除了UNSIGNED_BYTE数据类型，其他格式基本都遵循16比特规则：将RGB三分量压缩入16比特中。设置不同格式目的是为了 压缩数据，减少加载时间 。 STEP6：将纹理单元传递给片元着色器sampler2D uniform sampler2D u_Sampler;uniform 表示纹理图像不会随片元变化sampler2D 是一种专用于纹理对象的数据类型 uniform1i gl.uniform1i(u_Sampler,0); // 0 表示 gl.TEXTURE0对于sampler类型，必须将其指定的 纹理单元编号（texture unit number） 传给着色器。 STEP7：从顶点着色器向片元着色器传输纹理坐标let VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec2 a_TexCoord; varying vec2 v_TexCoord; void main() gl_Position = a_Position; v_TexCoord = a_TexCoord; ` 传递Vertex_Shader获取到纹理坐标a_TexCoord后，通过v_TexCoord传递到Fragment_Shader。内插虽然只明确传入了绘制范围的顶点纹理坐标，但是片元的纹理坐标会在光栅化的过程中内插出来。抽取后填色根据计算出的片元纹理坐标，从纹理图像上抽取出纹素的颜色，然后涂抹到片元上。STEP8：在片元着色器中获取纹理像素颜色gl_FragColor = texture2D( u_Sampler, v_TexCoord); texture2D是GLSL ES的内置函数，它只需要知道两个参数： 纹理单元编号 和 纹理坐标，就能够取得纹理上的像素颜色。 **OS：**基本原理就和查字典一样，知道大体的模块，再知道具体坐标，就能提取到一切你需要查询的信息。 texture2D的返回值 就必须要提到之前对WebGL纹理进行配置的 texParameteri 和 texImage2D。texParameteri 的 纹理参数（pname） 直接决定WebGL求取片元纹理坐标内插值的方式。texImage2D 的 纹理数据格式（internalformat） 直接决定 texture2D返回值类型。 小实验 TexturedQuad_Repeatlet verticesTexCoords = new Float32Array([ -0.5, 0.5, -0.3, 1.7, -0.5, -0.5, -0.3, -0.2, 0.5, 0.5, 1.7, 1.7, 0.5, -0.5, 1.7, -0.2]); TexturedQuad_Repeat运行结果 之所以会重复，是因为 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 都设置为了 gl.REPEAT。纹理坐标示意图 TexturedQuad_Mirrorgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT); TexturedQuad_Mirror运行结果 MultiTexture本案例主要介绍如何同时处理多幅纹理。 MultiTexture Code MultiTexture运行结果MultiTexture.htmlMultiTextture.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./MultiTexture.js/script/headbody onload=main() canvas id=webgl width=300 height=300/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec2 a_TexCoord; varying vec2 v_TexCoord; void main() gl_Position = a_Position; v_TexCoord = a_TexCoord; `;let FSHADER_SOURCE = ` precision mediump float; uniform sampler2D u_Sampler0; uniform sampler2D u_Sampler1; varying vec2 v_TexCoord; void main() vec4 color0 = texture2D(u_Sampler0,v_TexCoord); vec4 color1 = texture2D(u_Sampler1,v_TexCoord); gl_FragColor = color0 * color1; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); if (!initTexture(gl, n)) console.log(纹理映射失败); return; gl.clearColor(0.0, 0.0, 0.0, 1.0);function initVertexBuffer(gl) let verticesTexCoords = new Float32Array([ -0.5, 0.5, 0.0, 1.0, -0.5, -0.5, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5, -0.5, 1.0, 0.0 ]); let n = 4; let FSIZE = verticesTexCoords.BYTES_PER_ELEMENT; let vertexTexCoordBuffer = gl.createBuffer(); let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_TexCoord = gl.getAttribLocation(gl.program, a_TexCoord); gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2); gl.enableVertexAttribArray(a_TexCoord); return n;function initTexture(gl, n) let texture0 = gl.createTexture(); let texture1 = gl.createTexture(); let u_Sampler0 = gl.getUniformLocation(gl.program, u_Sampler0); let u_Sampler1 = gl.getUniformLocation(gl.program, u_Sampler1); let image0 = new Image(); let image1 = new Image(); image0.onload = function () loadTexture(gl, n, texture0, u_Sampler0, image0, 0); image1.onload = function () loadTexture(gl, n, texture1, u_Sampler1, image1, 1); image0.src = ../img/tobydog.jpg; image1.src = ../img/blueflower.jpg; return true;let g_texUnit0 = false;let g_texUnit1 = false;function loadTexture(gl, n, texture, u_Sampler, image, texUnit) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); if (texUnit === 0) gl.activeTexture(gl.TEXTURE0); g_texUnit0 = true; else gl.activeTexture(gl.TEXTURE1); g_texUnit1 = true; gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); gl.uniform1i(u_Sampler, texUnit); gl.clear(gl.COLOR_BUFFER_BIT); if (g_texUnit0 g_texUnit1) gl.drawArrays(gl.TRIANGLE_STRIP, 0, n); GLSL ES中的vec4矢量的分量乘法"},{"title":"程序流程控制","path":"/wiki/WebGL/chapter_06_02.html","content":"分支与循环if和if-else语句 float distance = 0.7;if(distance0.5) gl_FragColor = vec4(1.0,0.0,0.0,1.0);else gl_FragColor = vec4(0.0,1.0,0.0,1.0);TIP1：判断式中不可以使用布尔值类型矢量。TIP2：GLSL ES中没有 switch语句。 for语句 int sum = 0;for(int i = 0;i3;i++) sum += i; continue、break、discard语句 continuefor(int i = 0; i10; i++) if(i==8) continue; // 跳过循环体，开启下一段循环 break for(int i = 0;i10;i++) if(i == 8) break; discard只能在Fragment shader中使用，表示放弃当前片元直接处理下一个片元。 函数函数声明 返回类型函数名 (type0 arg0, type1 arg1, ..., typen argn) 执行语句 return 返回值; 如果没有return语句，一定要声明函数是void类型。注意：GLSL ES不允许递归调用，这是为了便于编译器对函数进行内联展开。小例子：将RGBA颜色值转化为亮度值的函数float luma(vec4 color) //函数声明 return 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b;attribute vec4 a_Color;void main() float brightness = luma(a_Color); //函数调用规范声明如果在函数声明之前就进行调用，必须在调用之前进行 规范声明。 规范声明的目的在于：告诉WebGL系统函数的参数、参数类型、返回值等等。float luma(vec4); //规范声明void main() vec4 a_Color = vec4(0.5,0.0,0.0,1.0); float brightness = luma(a_Color);float luma(vec4 color) return 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b; 参数限定词 参数限定词可以用来控制参数的行为，大体上包括：传入函数的要被赋值并传出函数的要被传入、赋值、传出函数的in是默认的参数限定字。使用参数限定词重写luma函数void luma(in vec3 color, out float brightness) brightness = 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b;void main() vec3 v3 = vec3(0.0,1.0,1.0); float brightness; luma(v3, brightness); 内置函数"},{"title":"特殊声明","path":"/wiki/WebGL/chapter_06_03.html","content":"全局变量与局部变量 全局变量 声明在函数外面局部变量 声明在函数内部attribute、varying、uniform变量都必须是全局变量。 存储限定字const变量 const变量声明时 必须进行初始化。const int lightspeed = 299792458;void main() const vec4 red = vec4(1.0,0.0,0.0,1.0); const mat4 identity = mat4(1.0);试图向const变量赋值 会导致编译报错。const int lightspeed = w299792458;lightspeed = 300000000; //error attribute变量 声明限制只能出现在 顶点着色器 中只能是 全局变量只能是 浮点、矢量、矩阵 类型attribute vec4 a_Color; attribute float a_PointSize; uniform变量 声明限制只能是 全局变量只能是 除数组或结构体之外 的任意类型类型特征uniform变量是 只读的VertexShader和FragmentShader声明的同名uniform变量，会被两个着色器共享uniform变量主要包含适用于 每个顶点片元 的数据 varying变量 声明限制只能是 全局变量需要在两个着色器中 声明同名、同类型 的varying变量只能是 浮点数、矢量、矩阵 类型为什么要对varying变量类型进行限制？答： 顶点着色器的varying值在传给片元着色器的同名同类型varying值时，经历了 光栅化过程。根据绘制的图形，顶点与顶点之间的片元属性值需要通过内插计算，因此varying变量的数据类型都必须能够进行内插计算。 数量限制 attribute、uniform、varying的数量限制 都与设备有关。 精度限定字所谓精度限定字就是用来表示每种数据具有的精度。 为什么要引入精度限定字？ 答： 因为需要帮助着色器程序 提高运行效率，削减内存开支。通过使用精度限定字，可以精细地控制程序在效果和性能间的平衡。 WebGL程序的精度级别 highp 高精度mediump 中精度lowp 低精度WebGL在低精度下运行结果会比较粗糙或不准确。数值范围和精度的检查可以在WebGL环境下使用 gl.getShaderPrecisionFormat() 来检查系统环境的数值范围和精度。//WebGLShaderPrecisionFormatrangeMin: 127, rangeMax: 127, precision: 23gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT) 精度声明 声明单个变量的精度mediump float size; //中精度浮点数highp vec4 position; //高精度4维矢量lowp vec4 color; //低精度4维矢量声明默认精度默认精度是指 着色器的默认精度，即 指定类型 的变量其默认精度由 精度限定字 指定，也即 不以精度限定字修饰该类型变量，其精度就是 默认精度。声明格式precision 精度限定字 类型名称;着色器默认精度只有 片元着色器的float类型 没有默认精度。其它数据类型默认精度如下： 预处理指令预处理指令是用来在真正编译之前对代码进行预处理的。 小例子：检查是否已经定义了GL_ES宏#ifdef GL_ESprecision mediump float;#endif GLSL ES中可能用到的三种预处理指令 #if 条件表达式条件为真时执行#endif#ifdef 某宏定义了某宏时执行#endif#ifndef 某宏没有定义某宏时执行#endif分支预处理#define NUM 100#if NUM== 100 NUM==100时执行#else NUM!=100时执行#endif 宏定义 宏定义格式#define 宏名 宏内容 // 宏定义#undef 宏名 //解除宏定义内置宏使用内置宏进行精度限制#ifdef GL_ES#ifdef GL_FRAGMENT_PRECISION_HIGHprecision highp float; //支持高精度#elseprecision mediump float; //不支持高精度#endif#endif#version是用于指定着色器使用的 GLSL ES版本的。 #version指令必须放在着色器的最顶部。使用格式#version number可以接受的版本有： 100 GLSL ES 1.00101 GLSL ES 1.01指定GLSL ES版本为1.01#version 101"},{"title":"GLSL ES语法","path":"/wiki/WebGL/chapter_06_01.html","content":"GLSL ES和GLSL是什么关系？ GLSL ES是在GLSL基础上 删除和简化一部分功能后形成的。尽管是基于OpenGL着色器语言专为 电子产品嵌入式设备 打造的，但现在 GLSL ES 也开始被用来完成一些通用任务，如 GPGPU（图像处理和数据运算）。 基础语法GLSL ES基本注意点 大小写敏感语句以分号结尾 执行次序：以唯一的main函数为入口。 注释 单行注释 多行注释 ** 数据值类型 数值类型整型数浮点数布尔值类型 GLSL变量命名不能以gl_、webgl_、_webgl_开头。 GLSL ES关键字 GLSL ES基本类型 GLSL ES类型转换函数 GLSL ES运算符 矢量和矩阵类型声明 void main() vec3 position; //3维浮点矢量 ivec2 offset; //2维整型矢量 bvec4 bb; //4维布尔矢量 mat4 mvpMatrix; //4维浮点矩阵 赋值和构造 每种类型都对应一种 构造函数（constructor functions） 以供创建对应类型变量。构造函数的名称和其创建变量的类型名称总是一致的。vec3 position = vec3(1.0,0.0,0.5);ivec2 offset = ivec2(1,2);bvec4 bb = bvec4(false,false,true,false);mat2 mvpMatrix = mat2(1.0,2.0,3.0,4.0); 矢量构造函数 GLSL ES构建矢量的方式相当灵活。标准构建vec3 v3 = vec3(1.0,0.3,0.5);需要剔除多余元素的构建vec3 v3 = vec3(1.0,0.3,0.5);vec2 v2 = vec2(v3); //(1.0,0.3)使用同一值填充全矢量元素的构建vec4 v4 = vec4(1.0); //(1.0,1.0,1.0,1.0)使用多个其他变量结构构建vec3 v3 = vec3(1.0,0.3,0.5);vec2 v2 = vec2(v3); //(1.0,0.3)vec4 v4 = vec4(1.0); //(1.0,1.0,1.0,1.0)vec4 v4b = vec4(v2,v4); //(1.0,0.3,1.0,1.0)参数数量1且小于应付的值数，报错vec3 v33 = vec3(1.0,0.5); //Error 矩阵构造函数 GLSL中矩阵元素的存储是列主序的。传入矩阵的每一个元素/* 1.0 5.0 9.0 13.0 2.0 6.0 10.0 14.0 3.0 7.0 11.0 15.0 4.0 8.0 12.0 16.0*/mat4 m4 = mat4( 1.0,2.0,3.0,4.0, 5.0,6.0,7.0,8.0, 9.0,10.0,11.0,12.0, 13.0,14.0,15.0,16.0);传入一个或多个矢量// 使用2个vec2构建mat2对象vec2 v2_1 = vec2(1.0,3.0);vec2 v2_2 = vec2(2.0,4.0);// 1.0 2.0// 3.0 4.0mat2 m2_1 = mat2(v2_1,v2_2);// 使用1个vec4构建mat2对象vec4 v4 = vec4(1.0,3.0,2.0,4.0);// 1.0 2.0// 3.0 4.0mat2 m2_2 = mat2(v4);同时传入矢量和数值// 使用两个浮点数和一个vec2对象创建mat2对象vec2 v2 = vec2(2.0,4.0);// 1.0 2.0// 3.0 4.0mat2 m2 = mat2(1.0,3.0,v2);只传一个数值，生成一个对角线全为该数值的矩阵 // 1.0 0.0// 0.0 1.0mat2 m2 = mat2(1.0);传入数值数量大于1，又没有达到矩阵元素的数量，导致错误mat4 m4 = mat4(1.0,2.0,3.0); //Error 访问元素 点运算符点运算符可以访问的分量**TIP1：**这些可以通过名称访问的分量事实上还是通过参数顺序获取的。**TIP2：**这些分量只是索引的访问的语法糖，因此可以随意交叠使用。**TIP3：**访问超过矢量长度的分量会出错。vec3 v3 = vec3(1.0,2.0,3.0);float f;f = v3.x; //1.0f = v3.g; //2.0f = v3.p; //3.0f = v3.w; //Error:访问了超出矢量长度的分量混合（swizzling）混合是指将多个分量名共同置于点运算符后，可以同时从矢量中抽取出多个分量。 vec3 v3 = vec3(1.0,2.0,3.0);vec2 v2;v2 = v3.xy; // (1.0,2,0)v2 = v3.tp; // (2.0,3.0)v2 - v3.gg; // (2.0,2.0)聚合分量名可作为赋值表达式的左值vec3 v3 = vec3(1.0,2.0,3.0);vec2 v2;v2.xy = v3.gb;v2.s = v3.x;混合的分量名必须属于同一个分量集合vec3 v3 = vec3(1.0,2.0,3.0);vec2 v2;v2.xy = v3.ry; //Error[]运算符矩阵元素读取仍然按照列主序。mat4 m4 = mat4( 1.0,2.0,3.0,4.0, 5.0,6.0,7.0,8.0, 9.0,10.0,11.0,12.0, 13.0,14.0,15.0,16.0);vec4 v4 = m4[0]; //[1.0,2.0,3.0,4.0]使用两个[]访问具体元素mat4 m4 = mat4( 1.0,2.0,3.0,4.0, 5.0,6.0,7.0,8.0, 9.0,10.0,11.0,12.0, 13.0,14.0,15.0,16.0);float m24 = m4[1][3]; //8.0使用[]和分量名访问具体元素float m12 = m4[0].g; // 2.0[]中索引值只能是常量索引值常量索引值包括：整型字面量const声明的值循环索引常量表达式 运算符 矢量和矩阵的比较运算符只限于和!，不等大小的比较需要通过内置函数。矢量和浮点数的运算 相加运算v3b = v3a + f; 运算结果v3b.x = v3a.x + f;v3b.y = v3a.y + f;v3b.z = v3a.z + f; 矢量运算 矢量的每个分量都参与运算v3c = v3a + v3b; 运算结果v3c.x = v3a.x + v3b.x;v3c.y = v3a.y + v3b.y;v3c.z = v3a.z + v3b.z; 矩阵和浮点数运算 矩阵的每个分量都参与浮点数运算m3b = m3a * f; 运算结果m3b[0].x = m3a[0].x * f;m3b[0].y = m3a[0].y * f;m3b[0].z = m3a[0].z * f;/////////////////////////m3b[1].x = m3a[1].x * f;m3b[1].y = m3a[1].y * f;m3b[1].z = m3a[1].z * f;/////////////////////////m3b[2].x = m3a[2].x * f;m3b[2].y = m3a[2].y * f;m3b[2].z = m3a[2].z * f; 矩阵右乘矢量 结果为矢量v3b = m3a * v3a; 运算结果v3b.x = m3a[0].x * v3a.x + m3a[1].x * v3a.y + m3a[2].x + v3a.z;v3b.y = m3a[0].y * v3a.y + m3a[1].y * v3a.y + m3a[2].y + v3a.z;v3b.z = m3a[0].z * v3a.x + m3a[1].z * v3a.y + m3a[2].z + v3a.z; 矩阵左乘矢量 左乘结果与右乘不同v3b = v3a * m3a; 运算结果v3b.x = v3a.x * m3a[0].x + v3a.y * m3a[0].y + v3a.z * m3a[0].z; v3b.y = v3a.x * m3a[1].x + v3a.y * m3a[1].y + v3a.z * m3a[1].z; v3b.z = v3a.x * m3a[2].x + v3a.y * m3a[2].y + v3a.z * m3a[2].z; 矩阵相乘 m3c = m3a * m3b; 运算结果m3c[0].x = m3a[0].x * m3b[0].x + m3a[1].x * m3b[0].y + m3a[2].x * m3b[0].z;m3c[0].y = m3a[0].y * m3b[0].x + m3a[1].y * m3b[0].y + m3a[2].y * m3b[0].z;m3c[0].z = m3a[0].z * m3b[0].x + m3a[1].z * m3b[0].y + m3a[2].z * m3b[0].z;////////////////m3c[1].x = m3a[0].x * m3b[1].x + m3a[1].x * m3b[1].y + m3a[2].x * m3b[1].z;m3c[1].y = m3a[0].y * m3b[1].x + m3a[1].y * m3b[1].y + m3a[2].y * m3b[1].z;m3c[1].z = m3a[0].z * m3b[1].x + m3a[1].z * m3b[1].y + m3a[2].z * m3b[1].z;////////////////m3c[2].x = m3a[0].x * m3b[2].x + m3a[1].x * m3b[2].y + m3a[2].x * m3b[2].z;m3c[2].y = m3a[0].y * m3b[2].x + m3a[1].y * m3b[2].y + m3a[2].y * m3b[2].z;m3c[2].z = m3a[0].z * m3b[2].x + m3a[1].z * m3b[2].y + m3a[2].z * m3b[2].z; 结构体结构体（struct） 注意：结构体成员不能包含数组。 // 定义结构体类型struct light vec4 color; vec3 position;;light light1,light2;可以在定义结构体的同时声明该类型的变量。struct light vec4 color; vec3 position; light1; 结构体构造 结构体构造函数的名称与结构体名称 一致。参数顺序必须与结构体中定义的成员顺序 一致。 // 定义结构体类型struct light vec4 color; vec3 position;;light l1 = light( vec4(0.0,1.0,0.0,1.0), //color vec3(8.0,3.0,0.0) //position); 结构体成员的访问 结构体对象.成员名称struct light vec4 color; vec3 position;;light l1 = light( vec4(0.0,1.0,0.0,1.0), //color vec3(8.0,3.0,0.0) //position);vec4 color = l1.color; //(0.0,1.0,0.0,1.0)vec3 position = l1.position; //(8.0,3.0,0.0) 结构体运算符 结构体相等的条件是所有成员都相等。 数组GLSL ES中数组的注意点 只支持 一维数组数组的长度必须是 大于0的整型常量表达式（integral constant expression）索引值 从0开始索引值只能是 整型常量表达式 或 uniform变量数组不能在声明时 被一次性的初始化，必须显式 对每个元素进行初始化数组元素可以参与其自身类型支持的任意运算 数组的声明float floatArray[4];vec3 vec3Array[2];数组长度必须是大于0的整型常量表达式int size = 4;vec4 vec4Array[size]; //error使用索引访问数组元素int intArray[4];intArray[0] = 1;intArray[1] = 2;intArray[2] = 3;intArray[3] = 4;int num = intArray[1]; //2必须显式对数组每个元素进行初始化vec4 vec4Array[4];vec4Array[2] = vec4(0.0,0.0,0.0,1.0);vec4Array[1] = vec4(1.0,0.0,0.0,1.0);数组的运算float floatArray[4];floatArray[1] = 1.0;float f = floatArray[1] * 3.14; //3.14vec2 vec2Array[3];vec2Array[0] = vec2(0.5,0.9);vec2 v2 = floatArray[1] * vec2Array[0]; //(0.5,0.9) 取样器（sampler）取样器类型 sampler2DsamplerCube 取样器变量 只能是 uniform 变量。uniform sampler2D u_Sampler;sampler唯一能够接收的变量就是 纹理单元编号，必须使用 gl.uniform1i() 将纹理单元编号从WebGL传入 shader 中。 gl.uniform1i(u_Sampler,0);sampler变量只能进行赋值（）、相等（）、不等（!）操作。sampler类型内置最小数量 运算符优先级"},{"title":"进入三维世界","path":"/wiki/WebGL/chapter_07_01.html","content":"三维世界的观察者立方体是由三角形构成的 12个三角形组成的立方体在绘制三维物体时，需要考虑物体的 深度信息（depth information）三维世界的观察者如何定义三维世界的观察者？需要几个关键信息：他在哪他朝哪看他视野有多宽他能看多远 视点和视线 为了定义一个观察者，需要考虑2点：观察方向可视距离如何描述观察者的属性？视点（eye point） 观察者的位置视线（viewing direction） 观察者沿观察方向的射线 3项信息可以确定观察者状态： 三项信息确定观察者状态视点（eye point）即观察者在 三维空间中的位置，也即 视线的起点 。一般使用 ( eyeX, eyeY, eyeZ)表示观察目标点（look-at point）即 被观察目标所在的点，可以用来确定视线，一般使用 ( atX, atY, atZ)表示同时知道观察目标点和视点就能计算出视线方向。上方向（up direction）最终绘制在屏幕上的 影像中的向上的方向。一般使用 3维矢量( upX, upY, upZ)表示为什么一定要指定上方向？答： 区分出观察者以视线为轴旋转的状态（想想你歪头看东西的时候） 视图矩阵（view matrix） 视图矩阵是做什么的？答： 用来表示观察者的状态，包括视点、观察目标点、上方向等信息。 视图矩阵的使用位置？答： 在顶点着色器中使用。 为什么要叫视图矩阵？答： 因为它最终影响的是显示在屏幕上的视图。 Matrix4.setLookAt()矩阵工具库 cuon-matrix.js 引入的 Matrix4 类型提供了创建视图矩阵的方法： WebGL中观察者的默认状态 视点： (0,0,0)观察点： (0,0,-1)视线： Z轴负方向上方向： Y轴负方向，即(0,1,0)创建一个表示默认状态的矩阵var initialViewMatrix = new Matrix4();initialViewMatrix.setLookAt( 0,0,0, //视点 0,0,-1, //目标观察点 0,1,0 //上方向) LookAtTrianglesLookAtTriangles Code LookAtTriangles运行结果LookAtTriangles.htmlLookAtTriangles.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./LookArTriangles.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_ViewMatrix; varying vec4 v_Color; void main() gl_Position = u_ViewMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(着色器初始化失败); return; let n = initVertexBuffer(gl); // 获取u_ViewMatrix let u_ViewMatrix = gl.getUniformLocation(gl.program, u_ViewMatrix); // 设置视点、视线、上方向 let viewMatrix = new Matrix4(); viewMatrix.setLookAt(0.20, 0.25, 0.25, 0, 0, 0, 0, 1, 0); // 将视图矩阵传入顶点着色器 gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffer(gl) let verticesColors = new Float32Array([ // 绿色三角形 0.0, 0.5, -0.4, 0.4, 1.0, 0.4, -0.5, -0.5, -0.4, 0.4, 1.0, 0.4, 0.5, -0.5, -0.4, 1.0, 0.4, 0.4, // 黄色三角形 0.5, 0.4, -0.2, 1.0, 0.4, 0.4, -0.5, 0.4, -0.2, 1.0, 1.0, 0.4, 0.0, -0.6, -0.2, 1.0, 1.0, 0.4, // 蓝色三角形 0.0, 0.5, 0.0, 0.4, 0.4, 1.0, -0.5, -0.5, 0.0, 0.4, 0.4, 1.0, 0.5, -0.5, 0.0, 1.0, 0.4, 0.4 ]); let n = 9; let FSIZE = verticesColors.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3); gl.enableVertexAttribArray(a_Color); return n; 比较变换矩阵与视图矩阵 变换矩阵（以旋转矩阵为例）着色器程序attribute vec4 a_Position;attribute vec4 a_Color;varying vec4 v_Color;uniform mat4 u_rotMatrix;void main() gl_Position = u_rotMatrix * a_Position; v_Color = a_Color;变换矩阵的计算与传入let u_rotMatrix = gl.getUniformLocation(gl.program, u_rotMatrix);let rotMatrix = new Matrix4();rotMatrix.setRotate(90, 0, 0, 1); //绕z轴旋转90°gl.uniformMatrix4fv(u_rotMatrix, false, rotMatrix.elements); 视图矩阵着色器程序attribute vec4 a_Position;attribute vec4 a_Color;uniform mat4 u_ViewMatrix;varying vec4 v_Color;void main() gl_Position = u_ViewMatrix * a_Position; v_Color = a_Color;视图矩阵的计算与传入let u_ViewMatrix = gl.getUniformLocation(gl.program, u_ViewMatrix);let viewMatrix = new Matrix4();viewMatrix.setLookAt( 0.2, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements); 改变观察者的状态 与 对整个世界进行平移和旋转变换，这二者本质上是 一样 的。 LookAtRotatedTriangles从指定视角观察旋转后的三角形 这个案例的关键问题在于：怎么确定旋转矩阵与视图矩阵的使用顺序。答： 先旋转图形，再移动视角。下式展示的是 观察变换图形的矩阵计算式 ：resultMatrix = 视图矩阵 * 模型矩阵 * 原始顶点坐标 LookAtRotatedTriangles Code LookAtRotatedTriangles运行结果LookAtRotatedTriangles.htmlLookAtRotatedTriangles.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./LookAtRotatedTriangles.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; uniform mat4 u_ModelMatrix; uniform mat4 u_ViewMatrix; void main() gl_Position = u_ViewMatrix * u_ModelMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(failed to get context); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); if (n 0) console.log(failed to init vertex buffer); return; let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); let u_ViewMatrix = gl.getUniformLocation(gl.program, u_ViewMatrix); if (!(u_ModelMatrix u_ViewMatrix)) console.log(failed to get uniform variable); return; let modelMatrix = new Matrix4(); let viewMatrix = new Matrix4(); modelMatrix.setRotate(-10, 0, 0, 1); viewMatrix.setLookAt( 0.2, 0.25,0.25, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements); gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffers(gl) let verticesColors = new Float32Array([ // 红色三角形 最下层 0.0, 0.5, -0.4, 1.0, 0.4, 0.4, -0.5, -0.5, -0.4, 1.0, 0.3, 0.5, 0.5, -0.5, -0.4, 1.0, 1.0, 0.3, // 绿色三角形 中间层 0.0, -0.6, -0.2, 0.4, 1.0, 0.4, -0.5, 0.5, -0.2, 0.3, 1.0, 0.5, 0.5, 0.5, -0.2, 1.0, 1.0, 0.3, // 蓝色三角形 最上层 0.0, 0.5, 0.0, 0.4, 0.4, 1.0, -0.5, -0.5, 0.0, 0.3, 0.5, 1.0, 0.5, -0.5, 0.0, 0.5, 1.0, 1.0 ]); let n = 9; let FSIZE = verticesColors.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3); gl.enableVertexAttribArray(a_Color); return n; 模型视图矩阵模型视图矩阵（model view matrix） LookAtRotatedTriangle为什么需要改进？gl_Position = u_ViewMatrix * u_ModelMatrix * a_Position; 对于每一个顶点，Vertex_Shader都需要重复做一遍矩阵相乘计算。这显然会造成不必要的开销，最好把这一步提到Js中。 模型视图矩阵 视图矩阵 * 模型矩阵gl_Position 模型视图矩阵 * 顶点坐标 LookAtRotatedTriangle_mvMatrix Code Tip1：multiply方法进行矩阵相乘的顺序 mA.multiply(mB) mB * mA Tip2：js部分还可以更加简化let u_mvMatrix = gl.getUniformLocation(gl.program, u_ModelViewMatrix);let mvMatrix = new Matrix4();mvMatrix.setLookAt(0.20, 0.25, 0.25, 0, 0, 0, 0, 1, 0).rotate(-10,0,0,1);gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix.elements);Vertex_ShaderLookAtRotatedTriangle_mvMatrix.jsattribute vec4 a_Position;attribute vec4 a_Color;varying vec4 v_Color;uniform mat4 u_ModelViewMatrix;void main() gl_Position = u_ModelViewMatrix * a_Position; v_Color = a_Color;let u_mvMatrix = gl.getUniformLocation(gl.program, u_ModelViewMatrix);let modelMatrix = new Matrix4();let viewMatrix = new Matrix4();modelMatrix.setRotate(-10, 0, 0, 1);viewMatrix.setLookAt( 0.2, 0.25,0.25, 0, 0, 0, 0, 1, 0);let mvMatrix = viewMatrix.multiply(modelMatrix);gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix.elements); 利用键盘改变视点LookAtTrianglesWithKeys Code LookAtTrianglesWithKeys运行结果LookAtTrianglesWithKeys.htmlLookAtTrianglesWithKeys.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./LookAtTrianglesWithKeys.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_mvMatrix; varying vec4 v_Color; void main() gl_Position = u_mvMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!gl) console.log(failed to get context); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); if (n 0) console.log(failed to init vertex buffers); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); let u_mvMatrix = gl.getUniformLocation(gl.program, u_mvMatrix); let mvMatrix = new Matrix4(); document.onkeydown = function (ev) keydown(ev,gl,n,u_mvMatrix,mvMatrix); draw(gl, n, u_mvMatrix, mvMatrix);let g_eye = [0.2, 0.25, 0.25];function keydown(ev, gl, n, u_mvMatrix, mvMatrix) switch (ev.keyCode) case 39: g_eye[0] += 0.01; break; //右键 case 38: g_eye[2] += 0.01; break; //上键 case 37: g_eye[0] -= 0.01; break; //左键 case 40: g_eye[2] -= 0.01; break; //下键 default: break; draw(gl, n, u_mvMatrix, mvMatrix);function draw(gl, n, u_mvMatrix, mvMatrix) mvMatrix.setLookAt( ...g_eye, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_mvMatrix, false, mvMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffers(gl) let verticesColor = new Float32Array([ 0.0, 0.5, -0.4, 1.0, 0.4, 0.4, -0.5, -0.5, -0.4, 1.0, 0.4, 0.4, 0.5, -0.5, -0.4, 0.0, 0.4, 0.4, -0.4, 0.4, -0.2, 0.4, 1.0, 0.4, 0.4, 0.4, -0.2, 0.4, 1.0, 0.4, 0.0, -0.6, -0.2, 0.4, 0.0, 0.4, 0.0, 0.5, 0.0, 0.4, 0.4, 1.0, -0.5, -0.5, -0.0, 0.4, 0.4, 1.0, 0.5, -0.5, -0.0, 0.4, 0.4, 0.0 ]); let n = 9; let FSIZE = verticesColor.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColor, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6 * FSIZE, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6 * FSIZE, 3*FSIZE); gl.enableVertexAttribArray(a_Color); return n;"},{"title":"可视范围","path":"/wiki/WebGL/chapter_07_02.html","content":"可视范围（visible range） 在 LookAtTrianglesWithKeys 程序中，三角形的一角被残忍地咬掉了。三角形界的灵异照片这是因为没有设置 可视范围，WebGL只显示可视范围内的区域。 可视范围（正射类型）不绘制可视范围外的对象，是基本的降低程序开销的手段。 为什么要设置可视范围？ 因为大型网游earth Online最初就是这么设计的（大雾）！earth Online设计者考虑到这一点，给了你视线范围，要不让你随便朝天上扫一眼，就能看到月球上跳舞的小人吗？ 心外无物，心外无事，心外无理 虽然earth Online中的哲学分支可谓复杂纷纭，但是要理解WebGL世界中的可视距离机制，主观唯心主义观点可能会对你有所启发：存在即被感知 ——【英】贝克莱 人类本身也只能看到眼前的东西，水平视角大约200度左右。 可视空间（view volume） 有两类常用的可视空间： 正射投影orthographic projection 长方形可视（盒状）空间物体看上去大小与其所在位置没有关系可以方便地比较场景中物体大小常用于平面绘图等技术 透视投影perspective projection四棱锥（金字塔）可视空间使三维场景看上去更有深度感，更自然真实世界也是透视投影 盒状可视空间 近裁剪面 与 远裁剪面 之间的空间就是 盒状可视空间。只有在此空间内的物体会被显示出来。 如果裁剪面和canvas画布的宽高比不同会怎么样？答： 会按照canvas的宽高对画面进行压缩，物体会被扭曲。 定义盒状可视空间 Matrix4.setOrtho() 设置投影的矩阵被称为 正射投影矩阵（orthographic projection matrix）。 OrthoView该案例支持键盘控制可视空间深度大小。 OrthoView Code 偏转视点观察OrthoView运行效果观察三角形消失顺序与盒空间厚度的关系OrthoView.htmlOrthoView.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./OrthoView.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas p id=nearFar/p/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_ProjMatrix; varying vec4 v_Color; void main() gl_Position = u_ProjMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let nf = document.getElementById(nearFar); let gl = getWebGLContext(canvas); if (!gl) console.log(failed to get context); return; if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); if (n 0) console.log(failed to init vertex buffers); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); let u_ProjMatrix = gl.getUniformLocation(gl.program, u_ProjMatrix); let projMatrix = new Matrix4(); document.onkeydown = function (ev) keydown(ev, gl, n, u_ProjMatrix, projMatrix, nf); draw(gl, n, u_ProjMatrix, projMatrix, nf);let g_nf = [0.0, 0.5];function keydown(ev,gl,n,u_ProjMatrix,projMatrix,nf) switch (ev.keyCode) case 39: g_nf[0] += 0.01; break;//右键 case 37: g_nf[0] -= 0.01; break;//左键 case 38: g_nf[1] += 0.01; break;//上键 case 40: g_nf[1] -= 0.01; break;//下键 default: break; draw(gl, n, u_ProjMatrix, projMatrix, nf);function draw(gl,n,u_ProjMatrix,projMatrix,nf) projMatrix.setOrtho(-1, 1, -1, 1, g_nf[0], g_nf[1]); gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT); // nf.innerHTML = near: + Math.round(g_nf[0] * 100) / 100 + // ,far: + Math.round(g_nf[1] * 100) / 100; nf.innerHTML = near: + g_nf[0].toFixed(2) + ,far: + g_nf[1].toFixed(2); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffers(gl) let verticesColor = new Float32Array([ // 红色三角形 0.0, 0.5, -0.4, 1.0, 0.4, 0.4, -0.5, -0.5, -0.4, 1.0, 0.4, 0.4, 0.5, -0.5, -0.4, 0.0, 0.4, 0.4, // 绿色三角形 -0.4, 0.4, -0.2, 0.4, 1.0, 0.4, 0.4, 0.4, -0.2, 0.4, 1.0, 0.4, 0.0, -0.6, -0.2, 0.4, 0.0, 0.4, // 蓝色三角形 0.0, 0.5, 0.0, 0.4, 0.4, 1.0, -0.5, -0.5, -0.0, 0.4, 0.4, 1.0, 0.5, -0.5, -0.0, 0.4, 0.4, 0.0 ]); let n = 9; let FSIZE = verticesColor.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColor, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6 * FSIZE, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6 * FSIZE, 3*FSIZE); gl.enableVertexAttribArray(a_Color); return n; near、far与三角形消失的关系 Js中对固定位小数特殊的处理方式// 方法1:Math.roundlet digit = Math.pow( 100, 2);let result = Math.round(num * digit)/digit; // 方法2 toFixlet digit = 2;let result = num.toFixed(digit);ShapeZ VauleShow Conditionimg class”lazy” src”imageswikiWebGLOrtho_1.png” data-src”imageswikiWebGLOrtho_1.png”onerror”this.srcdata:imagesvg+xml,%3Csvg xmlns’http://www.w3.org/2000/svg‘ width’2rem’ height’2rem’ viewBox’0 0 24 24’%3E%3C!– Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ –%3E%3Cpath fill’%23F44336’ d’M22 12.698c-.002 1.47-.013 2.718-.096 3.743c-.097 1.19-.296 2.184-.74 3.009a4.2 4.2 0 0 1-.73.983c-.833.833-1.893 1.21-3.237 1.39C15.884 22 14.2 22 12.053 22h-.106c-2.148 0-3.83 0-5.144-.177c-1.343-.18-2.404-.557-3.236-1.39c-.738-.738-1.12-1.656-1.322-2.795c-.2-1.12-.236-2.512-.243-4.241Q1.999 12.737 2 12v-.054c0-2.148 0-3.83.177-5.144c.18-1.343.557-2.404 1.39-3.236s1.893-1.21 3.236-1.39c1.168-.157 2.67-.175 4.499-.177a.697.697 0 1 1 0 1.396c-1.855.002-3.234.018-4.313.163c-1.189.16-1.906.464-2.436.994S3.72 5.8 3.56 6.99C3.397 8.2 3.395 9.788 3.395 12v.784l.932-.814a2.14 2.14 0 0 1 2.922.097l3.99 3.99a1.86 1.86 0 0 0 2.385.207l.278-.195a2.79 2.79 0 0 1 3.471.209l2.633 2.37c.265-.557.423-1.288.507-2.32c.079-.972.09-2.152.091-3.63a.698.698 0 0 1 1.396 0’ opacity’.5’%3E%3Cpath fill’%23F44336’ fill-rule’evenodd’ d’M17.5 11c-2.121 0-3.182 0-3.841-.659S13 8.621 13 6.5s0-3.182.659-3.841S15.379 2 17.5 2s3.182 0 3.841.659S22 4.379 22 6.5s0 3.182-.659 3.841S19.621 11 17.5 11m-1.47-7.03a.75.75 0 1 0-1.06 1.06l1.47 1.47l-1.47 1.47a.75.75 0 0 0 1.06 1.06l1.47-1.47l1.47 1.47a.75.75 0 1 0 1.06-1.06L18.56 6.5l1.47-1.47a.75.75 0 0 0-1.06-1.06L17.5 5.44z’ clip-rule’evenodd’%3E%3Csvg%3E”0.0near0.00 far0.00img class”lazy” src”imageswikiWebGLOrtho_2.png” data-src”imageswikiWebGLOrtho_2.png”onerror”this.srcdata:imagesvg+xml,%3Csvg xmlns’http://www.w3.org/2000/svg‘ width’2rem’ height’2rem’ viewBox’0 0 24 24’%3E%3C!– Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ –%3E%3Cpath fill’%23F44336’ d’M22 12.698c-.002 1.47-.013 2.718-.096 3.743c-.097 1.19-.296 2.184-.74 3.009a4.2 4.2 0 0 1-.73.983c-.833.833-1.893 1.21-3.237 1.39C15.884 22 14.2 22 12.053 22h-.106c-2.148 0-3.83 0-5.144-.177c-1.343-.18-2.404-.557-3.236-1.39c-.738-.738-1.12-1.656-1.322-2.795c-.2-1.12-.236-2.512-.243-4.241Q1.999 12.737 2 12v-.054c0-2.148 0-3.83.177-5.144c.18-1.343.557-2.404 1.39-3.236s1.893-1.21 3.236-1.39c1.168-.157 2.67-.175 4.499-.177a.697.697 0 1 1 0 1.396c-1.855.002-3.234.018-4.313.163c-1.189.16-1.906.464-2.436.994S3.72 5.8 3.56 6.99C3.397 8.2 3.395 9.788 3.395 12v.784l.932-.814a2.14 2.14 0 0 1 2.922.097l3.99 3.99a1.86 1.86 0 0 0 2.385.207l.278-.195a2.79 2.79 0 0 1 3.471.209l2.633 2.37c.265-.557.423-1.288.507-2.32c.079-.972.09-2.152.091-3.63a.698.698 0 0 1 1.396 0’ opacity’.5’%3E%3Cpath fill’%23F44336’ fill-rule’evenodd’ d’M17.5 11c-2.121 0-3.182 0-3.841-.659S13 8.621 13 6.5s0-3.182.659-3.841S15.379 2 17.5 2s3.182 0 3.841.659S22 4.379 22 6.5s0 3.182-.659 3.841S19.621 11 17.5 11m-1.47-7.03a.75.75 0 1 0-1.06 1.06l1.47 1.47l-1.47 1.47a.75.75 0 0 0 1.06 1.06l1.47-1.47l1.47 1.47a.75.75 0 1 0 1.06-1.06L18.56 6.5l1.47-1.47a.75.75 0 0 0-1.06-1.06L17.5 5.44z’ clip-rule’evenodd’%3E%3Csvg%3E”-0.2near0.20 far0.20img class”lazy” src”imageswikiWebGLOrtho_3.png” data-src”imageswikiWebGLOrtho_3.png”onerror”this.srcdata:imagesvg+xml,%3Csvg xmlns’http://www.w3.org/2000/svg‘ width’2rem’ height’2rem’ viewBox’0 0 24 24’%3E%3C!– Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ –%3E%3Cpath fill’%23F44336’ d’M22 12.698c-.002 1.47-.013 2.718-.096 3.743c-.097 1.19-.296 2.184-.74 3.009a4.2 4.2 0 0 1-.73.983c-.833.833-1.893 1.21-3.237 1.39C15.884 22 14.2 22 12.053 22h-.106c-2.148 0-3.83 0-5.144-.177c-1.343-.18-2.404-.557-3.236-1.39c-.738-.738-1.12-1.656-1.322-2.795c-.2-1.12-.236-2.512-.243-4.241Q1.999 12.737 2 12v-.054c0-2.148 0-3.83.177-5.144c.18-1.343.557-2.404 1.39-3.236s1.893-1.21 3.236-1.39c1.168-.157 2.67-.175 4.499-.177a.697.697 0 1 1 0 1.396c-1.855.002-3.234.018-4.313.163c-1.189.16-1.906.464-2.436.994S3.72 5.8 3.56 6.99C3.397 8.2 3.395 9.788 3.395 12v.784l.932-.814a2.14 2.14 0 0 1 2.922.097l3.99 3.99a1.86 1.86 0 0 0 2.385.207l.278-.195a2.79 2.79 0 0 1 3.471.209l2.633 2.37c.265-.557.423-1.288.507-2.32c.079-.972.09-2.152.091-3.63a.698.698 0 0 1 1.396 0’ opacity’.5’%3E%3Cpath fill’%23F44336’ fill-rule’evenodd’ d’M17.5 11c-2.121 0-3.182 0-3.841-.659S13 8.621 13 6.5s0-3.182.659-3.841S15.379 2 17.5 2s3.182 0 3.841.659S22 4.379 22 6.5s0 3.182-.659 3.841S19.621 11 17.5 11m-1.47-7.03a.75.75 0 1 0-1.06 1.06l1.47 1.47l-1.47 1.47a.75.75 0 0 0 1.06 1.06l1.47-1.47l1.47 1.47a.75.75 0 1 0 1.06-1.06L18.56 6.5l1.47-1.47a.75.75 0 0 0-1.06-1.06L17.5 5.44z’ clip-rule’evenodd’%3E%3Csvg%3E”-0.4near0.40 far0.40 补上三角形缺掉的角简述：即推远远裁剪面，本例主要介绍视图矩阵与正射投影矩阵的混合使用 正射矩阵和视图投影矩阵的使用顺序 gl_Position = ProjMatrix * ViewMatrix * a_Position;得到顶点在视图坐标系下的坐标使用正射投影矩阵计算可视范围 LookAtTrianglesWithKeys_ViewVolume 三角形整形前 三角形整型后 可视空间与canvas的比例冲突比例冲突会导致压缩变形 画布大小不变，可视空间横截面缩减一半运行效果： 图形变为原来大小的两倍，超出可视空间部分被裁剪。projMatrix.setOrtho(-0.5,0.5,-0.5,0.5,0.0,1.0)画布大小不变，可视空间比例改变运行效果： 图形在宽度上被拉伸导致变形，超出可视空间部分被裁剪。projMatrix.setOrtho(-0.3,0.3,-1.0,1.0,0.0,1.0)"},{"title":"可视空间（透视投影）","path":"/wiki/WebGL/chapter_07_03.html","content":"定义透视投影可视空间如何表达透视投影可视空间？ 答： 视点、视线、近裁剪面、远裁剪面，宽高比。透视投影矩阵（perspective projection matrix）setPerspective(30.0,1.0,1.0,100) fov 30.0 aspect 1.0 near 1.0 far 100.0 PerspectiveView Code PerspectiveView运行效果PerspectiveView.htmlPerspectiveView.js!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script src=../examples/lib/cuon-matrix.js/script script src=../examples/lib/cuon-utils.js/script script src=../examples/lib/webgl-debug.js/script script src=../examples/lib/webgl-utils.js/script script src=./PerspectiveView.js/script/headbody onload=main() canvas id=webgl width=400 height=400/canvas p id=nearFar/p/body/htmllet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_ViewMatrix; uniform mat4 u_ProjMatrix; varying vec4 v_Color; void main() gl_Position = u_ProjMatrix * u_ViewMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let nf = document.getElementById(nearFar); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); let n = initVertexBuffers(gl); let u_ViewMatrix = gl.getUniformLocation(gl.program, u_ViewMatrix); let viewMatrix = new Matrix4(); viewMatrix.setLookAt( 0, 0, 5, 0, 0, -100, 0, 1, 0 ); gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements); let u_ProjMatrix = gl.getUniformLocation(gl.program, u_ProjMatrix); let projMatrix = new Matrix4(); document.onkeydown = function (ev) keydown(canvas,gl,ev,n,u_ProjMatrix,projMatrix,nf); draw(canvas,gl,n,u_ProjMatrix,projMatrix,nf);let g_fov = 30.0;let g_far = 100.0;function keydown(canvas,gl,ev,n,u_ProjMatrix,projMatrix,nf) switch (ev.keyCode) case 37: g_far -= 1.0; break; case 38: g_fov += 1.0; break; case 39: g_far += 1.0; break; case 40: g_fov -= 1.0; break; default: break; draw(canvas,gl, n, u_ProjMatrix, projMatrix, nf);function draw(canvas,gl,n,u_ProjMatrix,projMatrix,nf) projMatrix.setPerspective(g_fov, canvas.width / canvas.height, 1.0, g_far); gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements); nf.innerHTML = fov: + Math.round(g_fov * 10) / 10 + far: + Math.round(g_far * 10) / 10; gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);function initVertexBuffers(gl) let verticesColors = new Float32Array([ //* 右侧3个三角形 // 绿色-最后 0.75, 1.0, -4.0, 0.4, 1.0, 0.4, 0.25, -1.0, -4.0, 0.4, 1.0, 0.4, 1.25, -1.0, -4.0, 1.0, 0.4, 0.4, // 黄色-中间 0.75, 1.0, -2.0, 1.0, 1.0, 0.4, 0.25, -1.0, -2.0, 1.0, 1.0, 0.4, 1.25, -1.0, -2.0, 1.0, 0.4, 0.4, // 蓝色-最前 0.75, 1.0, 0.0, 0.4, 0.4, 1.0, 0.25, -1.0, 0.0, 0.4, 0.4, 1.0, 1.25, -1.0, 0.0, 1.0, 0.4, 0.4, //* 左侧3个三角形 // 绿色-最后 -0.75, 1.0, -4.0, 0.4, 1.0, 0.4, -1.25, -1.0, -4.0, 0.4, 1.0, 0.4, -0.25, -1.0, -4.0, 1.0, 0.4, 0.4, // 黄色-中间 -0.75, 1.0, -2.0, 1.0, 1.0, 0.4, -1.25, -1.0, -2.0, 1.0, 1.0, 0.4, -0.25, -1.0, -2.0, 1.0, 0.4, 0.4, // 蓝色-最前 -0.75, 1.0, 0.0, 0.4, 0.4, 1.0, -1.25, -1.0, 0.0, 0.4, 0.4, 1.0, -0.25, -1.0, 0.0, 1.0, 0.4, 0.4, ]); let n = 18; let FSIZE = verticesColors.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6 * FSIZE, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6 * FSIZE, 3 * FSIZE); gl.enableVertexAttribArray(a_Color); return n; 透视矩阵的作用 透视矩阵实际上对三角形进行了 两次变换：缩小变换： 根据三角形与视点距离按比例对三角形进行缩小变换。平移变换： 使三角形贴近视线。因此我们可以手动对盒式空间中的图形进行几何变换，使其达到具有深度的视觉效果。盒状可视空间（Canonical View Volume） 与金字塔状可视空间的关系 共冶一炉PerspectiveView有什么问题是需要优化的？ 答： 左右两列三角形对称，完全可以由一列三角形平移获得。 准备虚线三角形顶点数据 沿X轴正方向平移0.75单位，绘制出结果 沿X轴负方向平移0.75单位，绘制出结果 mvp矩阵 模型矩阵（Model Matrix）视图矩阵（View Matrix）投影矩阵（Project Matrix）gl_Position = 投影矩阵 * 视图矩阵 * 模型矩阵 * a_Position; PerspectiveView_mvp Code 和PerspectiveView运行结果一样VSHADER_SOURCEmain()initVertexBuffer()let VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_ViewMatrix; uniform mat4 u_ProjMatrix; uniform mat4 u_ModelMatrix; varying vec4 v_Color; void main() gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; v_Color = a_Color; `;let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix);let modelMatrix = new Matrix4();modelMatrix.setTranslate(-0.75, 0, 0);gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);gl.drawArrays(gl.TRIANGLES, 0, n);modelMatrix.setTranslate(0.75, 0, 0);gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);gl.drawArrays(gl.TRIANGLES, 0, n);let verticesColors = new Float32Array([ //* 右侧3个三角形 // 绿色-最后 0.0, 1.0, -4.0, 0.4, 1.0, 0.4, -0.5, -1.0, -4.0, 0.4, 1.0, 0.4, 0.5, -1.0, -4.0, 1.0, 0.4, 0.4, // 黄色-中间 0.0, 1.0, -2.0, 1.0, 1.0, 0.4, -0.5, -1.0, -2.0, 1.0, 1.0, 0.4, 0.5, -1.0, -2.0, 1.0, 0.4, 0.4, // 蓝色-最前 0.0, 1.0, 0.0, 0.4, 0.4, 1.0, -0.5, -1.0, 0.0, 0.4, 0.4, 1.0, 0.5, -1.0, 0.0, 1.0, 0.4, 0.4,]); PerspectiveView_mvp需要注意的部分 性能真的提高了吗？答： 虽然减少了顶点的个数，但是增加了drawArrays的次数，因此实际使用时性能不一定提高。 可不可以把矩阵的计算拉出着色器？答： 被拉出的矩阵被称为 模型视图投影矩阵。 关键代码行 mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);"},{"title":"立方体","path":"/wiki/WebGL/chapter_07_05.html","content":"使用drawArrays绘制立方体 一个立方体一共8个顶点，6个面，12个三角形。ModeVertex NumberDraw TimeTRIANGLES361TRIANGLE_FAN246TRIANGLE_STRIP141 通过顶点索引绘制物体drawElements 立方体绘制所需建立的数据结构drawArrays和drawElements区别最重要的区别就在于drawElements需要指定顶点的索引值，因此使用的是 gl.ELEMENT_ARRAY_BUFFER 而不是gl.ARRAY_BUFFER。 drawArrays就像班级里老师直接叫名字给同学安排座位drawElements更像学校里通过学号安排考场关于第三个参数type的注意点需要注意的是type参数和gl.ELEMENT_ARRAY_BUFFER的数据类型不一致，也不会报错，但是可能会绘制出一些不可名状之物。 HelloCubes Code HelloCubes运行效果ShadermaininitVertexBufferslet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_MvpMatrix; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let mvpMatrix = new Matrix4(); mvpMatrix.setPerspective(30, 1, 1, 100); mvpMatrix.lookAt( 3, 3, 7, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function initVertexBuffers(gl) let verticesColors = new Float32Array([ // Vertex coordinates and color 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v0 White -1.0, 1.0, 1.0, 1.0, 0.0, 1.0, // v1 Magenta -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, // v2 Red 1.0, -1.0, 1.0, 1.0, 1.0, 0.0, // v3 Yellow 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, // v4 Green 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, // v5 Cyan -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, // v6 Blue ]); let FSIZE = verticesColors.BYTES_PER_ELEMENT; let indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, //前 0, 3, 4, 0, 4, 5, //右 0, 5, 6, 0, 6, 1, //上 1, 6, 7, 1, 7, 2, //左 7, 4, 3, 7, 3, 2, //下 4, 7, 6, 4, 6, 5, //后 ]); let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6 * FSIZE, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6 * FSIZE, 3 * FSIZE); gl.enableVertexAttribArray(a_Color); // write index buffer let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length; 顶点索引的写入 顶点索引数组的类型是怎么确定的？let indices = new Int8Array([ 0, 1, 2, 0, 2, 3, 0, 1, 6, 0, 5, 6, 0, 3, 4, 0, 4, 5, 1, 2, 7, 1, 6, 7, 5, 6, 7, 5, 4, 7, 2, 3, 7, 4, 3, 7]); 答： 需要顶点个数来确定，Int8Array类型可以用来绘制256个顶点。 gl.ELEMENT_ARRAY_BUFFER和gl.ARRAY_BUFFER的内容是如何产生联系的？顶点索引和顶点关系数据结构图 通过索引获取顶点数据示意图gl.drawElements的n参数表示的是什么的个数？gl.drawElements(gl.TRIANGLES,n,gl.UNSIGNED_BYTE,0); 答： n表示顶点索引数组的长度。 通过索引来访问顶点数据的优缺点是什么？ 优点能够循环利用顶点信息，控制内存的开销。 缺点需要通过索引来间接地访问，某种程度上使程序复杂化了。 为立方体的每个表面指定颜色需要创建多个坐标相同，颜色不同的顶点 立方体的一个顶点同时在三个平面的交点处，因此需要设置3个坐标相同，颜色不同的顶点。这样一共就需要创建3*824个顶点。 ColoredCube ColoredCube运行效果ShadermaininitVertexBuffersinitArrayBufferlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_MvpMatrix; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let mvpMatrix = new Matrix4(); mvpMatrix.setPerspective( 30, 1, 1, 100 ).lookAt( 3, 3, 7, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.FEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function initVertexBuffers(gl) // v6------ v5 // /| /| // v1--------v0| // | | | | // | |v7-----|-|v4 // |/ |/ // v2-------v3 let vertices = new Float32Array([ // font-back-left-right-up-down 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, //front v0-v1-v2-v3 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,//back v5-v6-v7-v4 -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, //left v1-v2-v7-v6 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,//right v0-v3-v4-v5 1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1,//up v0-v1-v6-v5 1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1//down v3-v2-v7-v4 ]); let colors = new Float32Array([ 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, //front 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, //back 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, //left 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, //right 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, //up 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, //down ]); let indices = new Int8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // back 8, 9,10, 8,10,11, // left 12,13,14, 12,14,15, // right 16,17,18, 16,18,19, // up 20,21,22, 20,22,23 // down ]); let indexBuffer = gl.createBuffer(); initArrayBuffer(gl, vertices, 3, gl.FLOAT, a_Position); initArrayBuffer(gl, colors, 3, gl.FLOAT, a_Color); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer(gl, data, num, type, attribute) let buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); let a_attribute = gl.getAttribLocation(gl.program, attribute); gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0,); gl.enableVertexAttribArray(a_attribute); 纯白盒子 let colors = new Float32Array([ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]);ColoredCube_singleColor运行效果"},{"title":"深度","path":"/wiki/WebGL/chapter_07_04.html","content":"正确处理对象的前后关系WebGL能自动分析出三维对象的远近吗？ 答： 不能。WebGL不能正确处理遮挡关系，后绘制的图形总是覆盖先绘制的图形。WebGL为了加速绘图操作，优先按照顶点在缓冲区的顺序进行处理（处理遮挡关系的话需要对顶点数据进行打乱重排吗？）。 打乱PerspectiveView的缓冲区顶点顺序绘制效果如何？ let verticesColors = new Float32Array([ // 蓝色 0.0, 1.0, 0.0, 0.4, 0.4, 1.0, -0.5, -1.0, 0.0, 0.4, 0.4, 1.0, 0.5, -1.0, 0.0, 1.0, 0.4, 0.4, // 黄色 0.0, 1.0, -2.0, 1.0, 1.0, 0.4, -0.5, -1.0, -2.0, 1.0, 1.0, 0.4, 0.5, -1.0, -2.0, 1.0, 0.4, 0.4, // 绿色 0.0, 1.0, -4.0, 0.4, 1.0, 0.4, -0.5, -1.0, -4.0, 0.4, 1.0, 0.4, 0.5, -1.0, -4.0, 1.0, 0.4, 0.4,]);后绘制的图形覆盖了先绘制的图形 隐藏面消除隐藏面消除（hidden surface removal） 具体功能： 消除被遮挡的表面，已经被内嵌在WebGL中。开启方式难道就不能给个Boolean属性直接表示开启或关闭吗？恼啊！隐藏面消除前提必须要先设置可视空间，无论是正射还是透视类型。1.开启隐藏面消除功能gl.enable(gl.DEPTH_TEST);2.绘制前清除深度缓冲区gl.clear(gl.DEAPTH_BUFFER_BIT);enable和disableenable用来开启WebGL汇总的多种功能，disable与之相反。cap的取值不止这些更多可参阅OpenGL Programming Guide一书。为什么说深度缓冲区是个中间对象？答： 想一想，如果要根据顶点的深度坐标对图形进行隐藏面消除，那首先就要知道 每个几何图形的深度信息，深度缓冲区就是用来存储 深度信息 的。 为什么隐藏面消除功能要命名为DEAPTH_TEST？答： 因为该功能的实现原理就是通过检测（Test）物体每个像素的深度（Depth）来决定是否绘制的。 深度缓冲区的清空时机答： 在绘制任意一帧之前都要清除深度缓冲区。同时清除两个缓冲区时，可以使用 按位或操作 进行简化。gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); DepthBuffer Code 开启DEPTH_TEST后，实现了隐藏面消除gl.enable(gl.DEPTH_TEST);gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 深度冲突深度冲突（Z fighting） 指的是物体两个表面极为接近时，绘制出来的表面斑驳不平滑。原因是在表面过于接近时，深度缓冲区有限精度不足以区分前后。 这种问题最容易出现在场景中有多个运动着的物体时。多边形偏移（polygon offset）是WebGL用于解决深度冲突的方式。实现原理： 自动在Z值上加一个偏移量，该值由 物体表面相对于观察者视线的角度 来确定。多边形偏移机制的启用（2步）1.启用多边形偏移gl.enable(gl.POLYGON_OFFSET_FILL);2.绘制之前指定计算偏移量的参数gl.polygonOffset(1.0,1.0);gl.polygonOffset(factor,units) = m * factor + r * units;m 表示顶点所在表面相对于观察者的视线的角度r 表示硬件能够区分两个z值之差的最小值 Zflighting Zflighting CodesetPerspectivelookAtverticesColorspvMatrix.setPerspective( 30, canvas.width / canvas.height, 1.0, 100.0);pvMatrix.lookAt( 3,0,10, 0, 0, -6, 0, 1, 0);let verticesColors = new Float32Array([ // 绿色三角形 0.0, 2.5, -5.0, 1.0, 1.0, 0.0, -2.5, -2.5, -5.0, 0.0, 1.0, 0.0, 2.5, -2.5, -5.0, 0.0, 1.0, 0.0, // 蓝色三角形 0.0, 3.0, -5.0, 0.0, 0.0, 1.0, -3.0, -3.0, -5.0, 0.0, 1.0, 1.0, 3.0, -3.0, -5.0, 0.0, 1.0, 1.0,]);多边形偏移前后对比 多边形偏移前绘制结果gl.enable(gl.POLYGON_OFFSET_FILL);gl.drawArrays(gl.TRIANGLES, 0, n/2); // draw green triangle// gl.polygonOffset(1.0, 1.0); // set polygon offsetgl.drawArrays(gl.TRIANGLES, n/2, n/2); // draw blue triangle 多边形偏移后绘制结果gl.enable(gl.POLYGON_OFFSET_FILL);gl.drawArrays(gl.TRIANGLES, 0, n/2); // draw green trianglegl.polygonOffset(1.0, 1.0); // set polygon offsetgl.drawArrays(gl.TRIANGLES, n/2, n/2); // draw blue triangle"},{"title":"光照原理","path":"/wiki/WebGL/chapter_08_01.html","content":"光线照射时需要注意的两个重要的现象 物体不同表面的 明暗程度 变得不一致 物体向地面投下了 影子 着色器与光照 着色（shading） 真正的含义就是： 根据光照条件重建物体各表面明暗不一的效果。着色器（Shader） 最初被发明出来就是为了： 重建光照产生的明暗现象。 着色过程需要重点考虑的两点： 发出光线的 光源类型物体表面 如何反射光线 光源类型三种基本光源类型 类型描述定义条件类比平行光（directional light）光线相互平行，可以看做无限远处光源发出的光方向，颜色太阳光点光源光（point light）从一个点向周围所有方向发出的光位置，颜色灯泡、火焰环境光（ambient light）从各个角度照射物体，强度一致颜色打开冰箱门的灯光 反射类型影响反射光的2个因素是什么？ 答： 入射光和物体表面的类型。入射光物体表面方向基底色颜色反射特性 物体表面反射光线的方式（2种） 漫反射 diffuse reflection环境反射 enviroment ambient reflection漫反射环境反射漫反射是针对平行光或点光源的。反射方向漫反射反射光 在各个方向上是均匀的 。一般针对表面粗糙的材质，是一种理想的反射模型。反射颜色反射颜色受三个因素的影响：入射光的颜色表面的基底色入射角 入射光与表面发现形成的夹角θ漫反射光颜色的计算公式：漫反射光颜色 = 入射光颜色 * 表面基底色 * cosθ 环境反射是针对环境光的。反射方向反射光方向可以认为就是 入射光的反方向 。 反射颜色环境反射光颜色 = 入射光颜色 * 表面基底色 漫反射和环境反射同时存在时的颜色计算公式 表面的反射光颜色 = 漫反射光颜色 + 环境反射光颜色 入射角的计算矢量点积 如果要对 矢量n 和 矢量l 做点积运算，公式如下：n·l = |n| * |l| * cosθ由此可以推演出入射角cosθ的计算公式：cosθ = n·l/(|n| * |l|)GLSL_ES中内置了点积运算函数，可以直接使用·表示点积运算。cosθ = 光线方向 · 法线方向 内置函数计算点积实际用到的公式n ( nx, ny, nz )l ( lx, ly, lz )n·l = nx*lx + ny*ly + nz*lz 使用点积表示的漫反射光颜色公式 漫反射光颜色 = 入射光颜色 * 表面基底色 * (光线方向 · 法线方向)注意点1：参与计算的矢量需要进行归一化处理。光线方向矢量 和 表面法线矢量 长度必须是1，否则反射光颜色就会过暗或过亮。 归一化（normalization） 指的是将一个矢量 长度调整为1，同时保持方向不变。假设矢量n (nx,ny,nz)设矢量n的长度为m，即 |n| m sqrt(nx^2 + ny^2 + nz^2)n归一化后结果为 (nxm,nym,nzm)如设n (2.0,2.0,1.0)|n| sqrt(2^2 + 2^2 + 1^2) 3n归一化结果 (2.03, 2.03, 1.03)注意点2：光线方向到底是指向哪里？答： 实际上是入射方向的反方向。 法线法线是什么？ 法线 或 法向量，表示物体表面的朝向，即垂直于表面的方向。法向量的相关问题需要考虑下面两点：注意点1：一个表面具有两个法向量就好像奥利奥的夹心两边都有饼干一样。 如 xy平面 的两个法向量分别是： (0,0,1) (0,0,-1) 注意点2：平面的法向量唯一法向量表示的是 方向，和位置无关，因此： 同一平面的任意一点都有相同的法向量 法向量只表示方向，与位置无关 朝向相同的个不同平面的法向量也相同就像同一根签穿起来的糖葫芦球一样。 法向量的写入计算好的法向量和其他attribute类型的属性一样，也需要传给顶点着色器程序，其操作方法类似于 ColoredCube 中 颜色缓冲区 的写入。如立方体的每个顶点对应3个法向量（这是由于立方体表面垂直相交的缘故，但是表面光滑的物体通常每个顶点只对应1个法向量）。"},{"title":"光照实现","path":"/wiki/WebGL/chapter_08_02.html","content":"LightedCubeLightedCube Code LightedCube运行效果shadermaininitVertexBuffersinitArrayBufferlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute vec4 a_Normal; // 法向量 uniform mat4 u_MvpMatrix; uniform vec3 u_LightColor; // 光线颜色 uniform vec3 u_LightDirection; // 归一化的世界坐标 varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; // 对法向量进行归一化 vec4 → vec3 vec3 normal = normalize(vec3(a_Normal)); // 计算cosθ（光线方向·法向量） float nDotL = max(dot(u_LightDirection,normal),0.0); // 计算反射光颜色 （入射光颜色*基底颜色*cosθ ） vec3 diffuse = u_LightColor * vec3(a_Color) * nDotL; v_Color = vec4(diffuse, 1.0); `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let u_LightColor = gl.getUniformLocation(gl.program, u_LightColor); let u_LightDirection = gl.getUniformLocation(gl.program, u_LightDirection); // 设置光线颜色-白色 gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0); // 设置光线方向-世界坐标系下 // 0.25+9+16 = 25.25 let lightDirection = new Vector3([0.5, 3.0, 4.0]); lightDirection.normalize(); // 归一化 gl.uniform3fv(u_LightDirection, lightDirection.elements); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let mvpMatrix = new Matrix4(); mvpMatrix.setPerspective( 30, 1.0, 1.0, 100.0 ).lookAt( 3, 3, 7, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); let n = initVertexBuffers(gl); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function initVertexBuffers(gl) let vertices = new Float32Array([ 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, // v1-v6-v7-v2 left -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // v7-v4-v3-v2 down 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 // v4-v7-v6-v5 back ]); var colors = new Float32Array([ // Colors 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v1-v2-v3 front 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v5-v6-v1 up 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v1-v6-v7-v2 left 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v7-v4-v3-v2 down 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 // v4-v7-v6-v5 back ]); var normals = new Float32Array([ // Normal 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // v7-v4-v3-v2 down 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0 // v4-v7-v6-v5 back ]); var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9, 10, 8, 10, 11, // up 12, 13, 14, 12, 14, 15, // left 16, 17, 18, 16, 18, 19, // down 20, 21, 22, 20, 22, 23 // back ]); initArrayBuffer(gl, a_Position, vertices, 3, gl.FLOAT); initArrayBuffer(gl, a_Color, colors, 3, gl.FLOAT); initArrayBuffer(gl, a_Normal, normals, 3, gl.FLOAT); let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer(gl,attribute,data,num,type) let buffer = gl.createBuffer(); let a_Attribute = gl.getAttribLocation(gl.program, attribute); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Attribute, num, type, false, 0, 0); gl.enableVertexAttribArray(a_Attribute); 一些小问题 入射光方向设置在世界坐标系下是什么意思？答： 表示光照效果是在世界坐标系下计算的。这样做可以使程序更简单，代码比较直观。 为什么在入射光方向归一化处理在Js中，法向量归一化处理在着色器内？答： 入射光方向 u_LightDirection 是 uniform 类型，适用于所有顶点，没有必要在着色器中逐顶点重复归一化操作，因此归一化后传入即可。 法向量 a_Normal 是 attribute 类型，放在缓冲区传入，每个顶点都有对应的法向量值，需要在着色器内逐顶点的处理。 法向量和入射光向量点积值小于0，说明出现了什么情况？答： cosθ0，说明θ90°，即 光线照在了表面的背面上。 Shader和Js中的normalize有什么区别？Shader中 vec3 normal = normalize(vec3(a_Normal));normalize为GLSL ES的内置函数，接受并返回 vec3 类型参数。 Js中 let lightDirection = new Vector3([0.5, 3.0, 4.0]);lightDirection.normalize(); // 归一化gl.uniform3fv(u_LightDirection, lightDirection.elements);Vector3对象的normalize函数返回 Float32Array 类型参数，并存储在Vector对象的 elements 属性中。 LightedCube_animation LightedCube_animation运行效果注意在Cube顶点Position旋转变换时，也需要对顶点的法向量进行旋转变换。Shadermainlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_NormalMatrix; // 法向量变换的模型矩阵 uniform vec3 u_LightColor; uniform vec3 u_LightDirection; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; vec3 normal = vec3(u_NormalMatrix * a_Normal); float nDotL = max(dot(normal,u_LightDirection),0.0); vec3 diffuse = u_LightColor * vec3(a_Color) * nDotL; v_Color = vec4(diffuse,1.0); `;let u_LightColor = gl.getUniformLocation(gl.program, u_LightColor); let u_LightDirection = gl.getUniformLocation(gl.program, u_LightDirection); gl.uniform3f(u_LightColor,1.0, 1.0, 1.0); let lightDirection = new Vector3([0.5, 3.0, 4.0]); lightDirection.normalize(); gl.uniform3fv(u_LightDirection, lightDirection.elements); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); let mvMatrix = new Matrix4(); let normalMatrix = new Matrix4(); mvMatrix.setPerspective( 30, 1.0, 1.0, 100.0 ).lookAt( 3, 3, 7, 0, 0, 0, 0, 1, 0 ); let modelMatrix = new Matrix4(); let mvpMatrix = new Matrix4(); let n = initVertexBuffers(gl); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.enable(gl.DEPTH_TEST); let angle = 0; let tick = function () // p * v * m angle = animation(angle); modelMatrix.setRotate(angle, 0, 1, 0); mvpMatrix.set(mvMatrix).multiply(modelMatrix); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); normalMatrix.setInverseOf(modelMatrix); normalMatrix.transpose(); gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0); requestAnimationFrame(tick); tick(); 环境光下的漫反射LightedCube存在的问题 Cube的右侧面几乎是黑色的 实际光照下物体各面亮度差异不会这么大 LightedCube中使用的是 平行光源 ，没有被直射光照射到的面按理来说应该被 环境光 照亮。由于环境光是由其他物体反射产生的，因此环境光的强度通常比较弱。 LightedCube_ambient 只有平行光的光照效果 添加了环境光的光照效果 Shadermainlet VSHADER_SOURCE = ` ... uniform vec3 u_AmbientLight; //环境光颜色 void main ... // 计算环境光产生的反光颜色 vec3 ambient = u_AmbientLight * a_Color.rbg; v_Color = vec4((diffuse + ambient), 1.0); `;let u_AmbientLight = gl.getUniformLocation(gl.program, u_AmbientLight);gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2); 运动物体的光照效果运动物体的法向量 当对物体进行变换时，需要考虑其法向量的变换情况。平移变换 不会改变法向量旋转变换 会改变法向量缩放变换 有可能会改变法向量，存在一些特殊情况，如：所有轴等比缩放向两个轴的方向等比缩放 魔法矩阵：逆转置矩阵 如何计算变换之后的法向量呢？答： 将变换之前的法向量乘以 ModelMatrix的逆转置矩阵（inverse transpose matrix） 即可。 逆矩阵（inverse matrix）如果矩阵M的逆矩阵是R，则 R*MM*R单位矩阵let modelMatrix = new Matrix4(); //模型矩阵let normalMatrix = new Matrix4(); //法向量变换矩阵...normalMatrix.setInverseOf(normalMatrix); // 求逆矩阵normalMatrix.transpose(); //转置处理 LightedTranslatedRotatedCube 没有对法向量进行变换处理的效果 对法向量进行变换处理的效果 Shadermainlet VSHADER_SOURCE = ` ... uniform mat4 u_NormalMatrix; //法向量的模型矩阵 void main() ... vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal)); ... `;let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); let mvpMatrix = new Matrix4(); let modelMatrix = new Matrix4(); let normalMatrix = new Matrix4(); modelMatrix.setTranslate( 0,0.9,0 ).rotate( 90, 0, 0, 1 ); mvpMatrix.setPerspective( 30, 1.0, 1.0, 100.0 ).lookAt( 3, 3, 7, 0, 0, 0, 0, 1, 0 ).multiply(modelMatrix); normalMatrix.setInverseOf(modelMatrix); normalMatrix.transpose(); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements); 点光源光点光源光的方向 点光源光的方向不是 恒定不变 的，而是 根据每个顶点的位置 逐一计算的。 计算点光源光线方向需要哪些值呢？回顾平行光源方向的获取let VSHADER_SOURCE = ` ... uniform vec3 u_LightDirection; // 直接定义并从外界传入（世界坐标系下） ...`需要两个值： 点光源位置 u_LightPosition顶点位置 a_Position计算顶点的世界坐标的模型矩阵 u_ModelMatrix顶点对应法向量的模型矩阵 u_NormalMatrix如何计算每个顶点的点光源方向呢？为什么要转换到世界坐标系下？答： 你可能已经知道 u_MvpMatrix 是做什么用的了，它会设置一个视点，并计算出传入的坐标 a_Position 相对视点的绘制坐标， 点光源光线是和 点光源和物体顶点的相对位置 有关的，即两个物体的相对位置关系，这个位置关系是 绝对的，与视点坐标系无关， 因此就需要一个 绝对的空间 来为它们做基准，这就是 世界坐标系。 就像冬天你从寒冷的外面进入正常气温的屋子一样，你可能认为屋内气温比实际的要高一些，世界坐标系就像温度计一样，告诉你绝对现实是什么。视点坐标：我相比之前感觉有了很大的进步，我正在逐渐理解一切！世界坐标：哦？你是这样认为的吗？ Step1计算顶点在 世界坐标系 中的坐标，计算 世界顶点 相对应的 法向量。Step2计算顶点处 点光源方向 ：设世界坐标系下，顶点向量为 OA，点光源向量为 OB则顶点处点光源光线向量为 BA OA - OB即 顶点世界矢量 - 点光源世界矢量漫反射光的方向与入射光方向相反，因此最终反射光线 点光源世界矢量 - 顶点世界矢量 PointLightedCube PointLightedCube运行效果Shadermainlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_ModelMatrix; uniform mat4 u_NormalMatrix; uniform vec3 u_LightColor; // 点光源颜色 uniform vec3 u_LightPosition; // 点光源位置 uniform vec3 u_AmbientLight; // 环境光颜色 varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; vec3 normal = vec3(u_NormalMatrix * a_Normal); //计算法向量 vec3 vertexPosition = vec3(u_ModelMatrix * a_Position); //计算世界坐标 vec3 lightDirection = normalize( u_LightPosition - vertexPosition ); //计算光线方向 float nDotl = max(dot(lightDirection,normal),0.0); //计算cosθ vec3 diffuse = u_LightColor * a_Color.rbg * nDotl; //漫反射 vec3 ambient = u_AmbientLight * a_Color.rbg; //环境反射 v_Color = vec4( diffuse + ambient , 1.0); `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); let u_LightColor = gl.getUniformLocation(gl.program, u_LightColor); let u_LightPosition = gl.getUniformLocation(gl.program, u_LightPosition); let u_AmbientLight = gl.getUniformLocation(gl.program, u_AmbientLight); let mvpMatrix = new Matrix4(); let modelMatrix = new Matrix4(); let normalMatrix = new Matrix4(); modelMatrix.setRotate(90, 0, 1, 0); mvpMatrix.setPerspective( 30, 1, 1, 100 ).lookAt( 6, 6, 14, 0, 0, 0, 0, 1, 0 ).multiply(modelMatrix); normalMatrix.setInverseOf(modelMatrix); normalMatrix.transpose(); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements); gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0); gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2); gl.uniform3f(u_LightPosition, 2.3, 4.0, 3.5); let n = initVertexBuffers(gl); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0); 逐片元光照PointLightCube_animation 当物体运动时，会发现 立方体表面上有不自然的线条。这是片元的颜色是 由顶点颜色内插得出的 ，因此不够逼真。 逐片片元操作实际上就是把反射光颜色计算的步骤提取到片元着色器中。 PointLightedCube_perFragment 可以看到逐片元处理的物体表面颜色过渡更加自然。 逐顶点处理 逐片元处理 一些小问题将计算过程提取到片元着色器中，需要准备哪些数据？答： 片元世界坐标 片元处法向量 把顶点坐标在顶点着色器中转换为世界坐标系下的坐标，将法向量进行相应转换，这样通过varying传入的同名变量就已经是内插后的逐片元值了。 法向量传入片元着色器后为什么又要进行归一化处理？答： 因为内插之后的法向量可能不再是1.0了。 Vertex_ShaderFragment_Shaderlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_ModelMatrix; uniform mat4 u_NormalMatrix; varying vec3 v_Position; varying vec3 v_Normal; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; v_Position = vec3(u_ModelMatrix * a_Position); //计算世界坐标 v_Normal = normalize(vec3(u_NormalMatrix * a_Normal)); //计算法向量 v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform vec3 u_LightColor; // 点光源颜色 uniform vec3 u_LightPosition; // 点光源位置 uniform vec3 u_AmbientLight; // 环境光颜色 varying vec3 v_Position; varying vec3 v_Normal; varying vec4 v_Color; void main() // 需要重新对法线进行归一化处理，因为内插之后长度不一定是1.0 vec3 normal = normalize(v_Normal); vec3 lightDirection = normalize( u_LightPosition - v_Position ); //计算光线方向 float nDotl = max(dot(lightDirection,normal),0.0); //计算cosθ vec3 diffuse = u_LightColor * v_Color.rbg * nDotl; //漫反射 vec3 ambient = u_AmbientLight * v_Color.rbg; //环境反射 gl_FragColor = vec4( diffuse + ambient , 1.0); `; 一些小实验 多个点光源逐顶点和逐片元绘制对比 逐顶点绘制球体：表面颜色斑驳 逐片元绘制球体：颜色过渡更自然"},{"title":"层次模型","path":"/wiki/WebGL/chapter_09_01.html","content":"复杂模型听到复杂两个字别害怕，再复杂的大模型都是由简单的小模型组成哒 以机器人手臂为例 就像拼乐高一样，大模型的的单位就是这些小零件，你需要知道的就是 有哪些零件 和 拼接关系。乐高积木说明书要实现这样一个简单的机器人手臂，你需要考虑一下这样几个关节：部位旋转轴带动部位无影响部位上臂肩关节前臂、手掌、手指前臂肘关节手掌、手指上臂手掌腕关节手指上臂、前臂手指上臂、前臂、手掌 层次结构模型 最常用的方法就是按 层次顺序-由高到低 逐一绘制。三维模型各个部件的运动最重要的就是实现： 部件A转动带动部件B转动 单关节模型arm2 前臂joint1 肘关节arm1 上臂垂直交点 肩关节单关节模型变换的核心就是 joint1-肘关节：上臂 以肘关节所在的 y轴旋转前臂 以肘关节所在的 z轴旋转 JointMode JointMode运行结果shadersmainbufferkeydowndrawlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_NormalMatrix; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; vec3 lightDirection = normalize(vec3(0.0,0.5,0.7)); vec4 color = vec4( 0.0, 0.4, 0.4, 1.0); vec3 normal = normalize((u_NormalMatrix * a_Normal).xyz); float nDotL = max(dot(normal,lightDirection ),0.0); v_Color = vec4(color.rgb * nDotL + vec3(0.3),color.a); `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); //set the vertex information gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.enable(gl.DEPTH_TEST); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); let vpMatrix = new Matrix4(); vpMatrix.setPerspective( 50, 1.0, 1.0, 100.0 ).lookAt( 20, 10, 30, 0, 0, 0, 0, 1, 0 ); document.onkeydown = function (ev) keydown(gl,ev,n,u_MvpMatrix,u_NormalMatrix,vpMatrix); draw(gl,n,u_MvpMatrix,u_NormalMatrix,vpMatrix);function initVertexBuffers(gl) var vertices = new Float32Array([ 1.5, 10.0, 1.5, -1.5, 10.0, 1.5, -1.5, 0.0, 1.5, 1.5, 0.0, 1.5, // v0-v1-v2-v3 front 1.5, 10.0, 1.5, 1.5, 0.0, 1.5, 1.5, 0.0,-1.5, 1.5, 10.0,-1.5, // v0-v3-v4-v5 right 1.5, 10.0, 1.5, 1.5, 10.0,-1.5, -1.5, 10.0,-1.5, -1.5, 10.0, 1.5, // v0-v5-v6-v1 up -1.5, 10.0, 1.5, -1.5, 10.0,-1.5, -1.5, 0.0,-1.5, -1.5, 0.0, 1.5, // v1-v6-v7-v2 left -1.5, 0.0,-1.5, 1.5, 0.0,-1.5, 1.5, 0.0, 1.5, -1.5, 0.0, 1.5, // v7-v4-v3-v2 down 1.5, 0.0,-1.5, -1.5, 0.0,-1.5, -1.5, 10.0,-1.5, 1.5, 10.0,-1.5 // v4-v7-v6-v5 back ]); // Normal var normals = new Float32Array([ 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, // v7-v4-v3-v2 down 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0 // v4-v7-v6-v5 back ]); // Indices of the vertices var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]); initArrayBuffer(gl, a_Position, vertices, 3, gl.FLOAT); initArrayBuffer(gl, a_Normal, normals, 3, gl.FLOAT); let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer(gl, attribute, data, num, type) let buffer = gl.createBuffer(); let a_Attribute = gl.getAttribLocation(gl.program, attribute); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Attribute, num, type, false, 0, 0); gl.enableVertexAttribArray(a_Attribute);let ANGLE_STEP = 5.0; // the increments of rotation anglelet g_arm1Angle = -90.0; let g_joint1Angle = 0.0;function keydown(gl, ev, n, u_MvpMatrix, u_NormalMatrix, vpMatrix) // ←→：arm1 ↑↓：arm2 switch (ev.keyCode) case 37: g_arm1Angle = (g_arm1Angle - ANGLE_STEP) % 360; break; //← case 38: if (g_joint1Angle 135.0) g_joint1Angle += ANGLE_STEP; break; //↑ case 39: g_arm1Angle = (g_arm1Angle + ANGLE_STEP) % 360; break; //→ case 40: if (g_joint1Angle -135.0) g_joint1Angle -= ANGLE_STEP; break; //↓ default: break; draw(gl,n,u_MvpMatrix,u_NormalMatrix,vpMatrix); let g_modelMatrix = new Matrix4(); // Model Matrixlet g_mvpMatrix = new Matrix4();// count modelMatrixfunction draw(gl,n,u_MvpMatrix,u_NormalMatrix,vpMatrix) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Arm1 let arm1Length = 10.0; g_modelMatrix.setTranslate(0.0, -12.0, 0.0); g_modelMatrix.rotate(g_arm1Angle, 0.0, 1.0, 0.0); drawBox(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix); // Arm2 g_modelMatrix.translate(0.0, arm1Length, 0.0); g_modelMatrix.rotate(g_joint1Angle, 0.0, 0.0, 1.0); g_modelMatrix.scale(1.3, 1.0, 1.3); drawBox(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix);let g_normalMatrix = new Matrix4();// count mvpMatrix and normalMatrix , then draw the resultfunction drawBox(gl,n,u_MvpMatrix,u_NormalMatrix,vpMatrix) g_mvpMatrix.set( vpMatrix ).multiply( g_modelMatrix ); gl.uniformMatrix4fv(u_MvpMatrix, false, g_mvpMatrix.elements); g_normalMatrix.setInverseOf(g_modelMatrix); g_normalMatrix.transpose(); gl.uniformMatrix4fv(u_NormalMatrix, false, g_normalMatrix.elements); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0); 多节点模型finger1finger2 两根手指palm 手掌arm2 前臂arm1 上臂base 基座变量名对应部位操控键g_arm1Angle上臂←→g_joint1Angle肘关节↑↓g_joint2Angle腕关节xzg_joint3Angle指张角cv MultiJointModel MultiJointModel运行效果keydowndrawdrawBoxfunction keydown(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix, ev) switch (ev.keyCode) case 37: //← arm1 clockwise rotation g_arm1Angle = (g_arm1Angle - ANGLE_STEP) % 360; break; case 38: //↑ joint1 open if (g_joint1Angle joint1_limit) g_joint1Angle += ANGLE_STEP; break; case 39: //→ arm1 anticlockwise rotation g_arm1Angle = (g_arm1Angle + ANGLE_STEP) % 360; break; case 40: //↓ joint1 close if (g_joint1Angle -joint1_limit) g_joint1Angle -= ANGLE_STEP; break; case 67: //c the negative rotation of joint3 if (g_joint3Angle -joint3_limit) g_joint3Angle -= ANGLE_STEP; break; case 86: //v the positive rotation of joint3 if (g_joint3Angle joint3_limit) g_joint3Angle += ANGLE_STEP; break; case 88: //x the position rotattion of joint2 g_joint2Angle = (g_joint2Angle + ANGLE_STEP) % 360; break; case 90: //z the negative rotattion of joint2 g_joint2Angle = (g_joint2Angle - ANGLE_STEP) % 360; break; default: break; draw(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix);let baseHeight = 2.0;let arm1Length = 10.0;let arm2Length = 10.0;let palmLength = 2.0;function draw(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // base g_modelMatrix.setTranslate(0, -12, 0); drawBox(gl, n, 10.0, baseHeight, 10.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // arm1 g_modelMatrix.translate(0, baseHeight, 0); g_modelMatrix.rotate(g_arm1Angle, 0, 1, 0); drawBox(gl, n, 3.0, arm1Length, 3.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // arm2 g_modelMatrix.translate(0, arm1Length, 0); g_modelMatrix.rotate(g_joint1Angle, 0, 0, 1); drawBox(gl, n, 4.0, arm2Length, 4.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // palm g_modelMatrix.translate(0, arm2Length, 0); g_modelMatrix.rotate(g_joint2Angle, 0, 1, 0); drawBox(gl, n, 2.0, palmLength, 6.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // fingers g_modelMatrix.translate(0, palmLength, 0); // finger1 pushMatrix(g_modelMatrix); g_modelMatrix.translate(0, 0, 2.0); g_modelMatrix.rotate(g_joint3Angle, 1, 0, 0); drawBox(gl, n, 1.0, 2.0, 1.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); g_modelMatrix = popMatrix(); // finger2 g_modelMatrix.translate(0.0, 0.0, -2.0); g_modelMatrix.rotate(-g_joint3Angle, 1, 0, 0); drawBox(gl, n, 1.0, 2.0, 1.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); let g_matrixStack = []; //Array for storing matrixfunction pushMatrix(m) let m2 = new Matrix4(m); g_matrixStack.push(m2);function popMatrix() return g_matrixStack.pop();function drawBox(gl, n, width, height, depth, vpMatrix, u_MvpMatrix, u_NormalMatrix) pushMatrix(g_modelMatrix); g_modelMatrix.scale(width, height, depth); g_mvpMatrix.set(vpMatrix).multiply(g_modelMatrix); g_normalMatrix.setInverseOf(g_modelMatrix); g_normalMatrix.transpose(); gl.uniformMatrix4fv(u_MvpMatrix, false, g_mvpMatrix.elements); gl.uniformMatrix4fv(u_NormalMatrix, false, g_normalMatrix.elements); gl.drawElements(gl.TRIANGLES,n,gl.UNSIGNED_BYTE,0); g_modelMatrix = popMatrix(); 绘制部件drawSegments MultiJoinModel方法概括总体来说聚焦于 模型矩阵：一切部件的 缓冲区数据 都一样通过改变 模型矩阵 来绘制出外形不同的部件低层级绘制使用的模型矩阵需要 基于 高层级的模型矩阵需要对多个部件进行缩放变换时，需要使用 矩阵管理栈绘制部件的方法有如下的特性：对每一个部件都定义一个单独的 缓冲区对象 存储对应顶点数据各个部件可以根据部件特性选择性 共享 某些数据 MultiJointModel_segment maindrawdrawBox/SegmentinitBuffers不同点在于segment方法在main中就引入了 a_Position，因为之后需要使用不同部件的 坐标缓冲区数据 。 MultiJoinModelfunction main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); let vpMatrix = new Matrix4(); vpMatrix.setPerspective( 50, 1, 1, 100 ).lookAt( 20, 10, 30, 0, 0, 0, 0, 1, 0 ); document.onkeydown = function (ev) keydown(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix, ev); draw(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix); MultiJointModel_segmentfunction main() ... let a_Position = gl.getAttribLocation(gl.program, a_Position); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_NormalMatrix = gl.getUniformLocation(gl.program, u_NormalMatrix); document.onkeydown = function (ev) keydown(gl, ev, n, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); draw(gl, n, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); 不同点在于：ModelJointModel 使用模型矩阵对同一个模型进行拉伸创建不同的部件ModelJointModel_segment 使用不同的缓冲区数据给a_Position重新赋值以创建不同的部件 ModelJointModelfunction draw(gl, n, u_MvpMatrix, u_NormalMatrix, vpMatrix) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // base g_modelMatrix.setTranslate(0, -12, 0); drawBox(gl, n, 10.0, baseHeight, 10.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // arm1 g_modelMatrix.translate(0, baseHeight, 0); g_modelMatrix.rotate(g_arm1Angle, 0, 1, 0); drawBox(gl, n, 3.0, arm1Length, 3.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // arm2 g_modelMatrix.translate(0, arm1Length, 0); g_modelMatrix.rotate(g_joint1Angle, 0, 0, 1); drawBox(gl, n, 4.0, arm2Length, 4.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // palm g_modelMatrix.translate(0, arm2Length, 0); g_modelMatrix.rotate(g_joint2Angle, 0, 1, 0); drawBox(gl, n, 2.0, palmLength, 6.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); // fingers g_modelMatrix.translate(0, palmLength, 0); // finger1 pushMatrix(g_modelMatrix); g_modelMatrix.translate(0, 0, 2.0); g_modelMatrix.rotate(g_joint3Angle, 1, 0, 0); drawBox(gl, n, 1.0, 2.0, 1.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); g_modelMatrix = popMatrix(); // finger2 g_modelMatrix.translate(0.0, 0.0, -2.0); g_modelMatrix.rotate(-g_joint3Angle, 1, 0, 0); drawBox(gl, n, 1.0, 2.0, 1.0, vpMatrix, u_MvpMatrix, u_NormalMatrix); ModelJointModel_segmentfunction draw(gl, n, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); g_ModelMatrix.setTranslate(0.0, -12.0, 0.0); drawSegment(gl, n, g_baseBuffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); g_ModelMatrix.translate( 0.0, baseHeight, 0.0 ).rotate( g_arm1Angle, 0, 1, 0 ); drawSegment(gl, n, g_arm1Buffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); g_ModelMatrix.translate( 0.0, arm1Length, 0.0 ).rotate( g_joint1Angle, 0, 0, 1 ); drawSegment(gl, n, g_arm2Buffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); g_ModelMatrix.translate( 0.0, arm2Length, 0.0 ).rotate( g_joint2Angle, 0, 1, 0 ); drawSegment(gl, n, g_palmBuffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); g_ModelMatrix.translate( 0.0, palmLength, 0.0 ); pushMatrix(g_ModelMatrix); g_ModelMatrix.translate( 0.0, 0.0, 2.0 ).rotate( g_joint3Angle, 1, 0, 0 ); drawSegment(gl, n, g_fingerBuffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); g_ModelMatrix = popMatrix(); g_ModelMatrix.translate( 0.0, 0.0, -2.0 ).rotate( -g_joint3Angle, 1, 0, 0 ); drawSegment(gl, n, g_fingerBuffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix); drawBox 需要根据尺寸对组件进行拉伸，需要通过栈对未拉伸的矩阵进行保存drawSegment 需要根据缓冲区重新对a_Position赋值 ModelJointModelfunction drawBox(gl, n, width, height, depth, vpMatrix, u_MvpMatrix, u_NormalMatrix) pushMatrix(g_modelMatrix); g_modelMatrix.scale(width, height, depth); ... g_modelMatrix = popMatrix(); ModelJointModel_segmentfunction drawSegment(gl, n, buffer, vpMatrix, a_Position, u_MvpMatrix, u_NormalMatrix) // write segments data gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT,false, 0, 0); gl.enableVertexAttribArray(a_Position); ... segment方法不在这里对 a_Position 进行赋值，这里需要对所有部件的缓冲区进行 数据写入，但是不对a_Position进行赋值。 MultiJoinModelfunction initVertexBuffers(gl) var vertices = new Float32Array([ 0.5, 1.0, 0.5, -0.5, 1.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, 0.5, // v0-v1-v2-v3 front 0.5, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0,-0.5, 0.5, 1.0,-0.5, // v0-v3-v4-v5 right 0.5, 1.0, 0.5, 0.5, 1.0,-0.5, -0.5, 1.0,-0.5, -0.5, 1.0, 0.5, // v0-v5-v6-v1 up -0.5, 1.0, 0.5, -0.5, 1.0,-0.5, -0.5, 0.0,-0.5, -0.5, 0.0, 0.5, // v1-v6-v7-v2 left -0.5, 0.0,-0.5, 0.5, 0.0,-0.5, 0.5, 0.0, 0.5, -0.5, 0.0, 0.5, // v7-v4-v3-v2 down 0.5, 0.0,-0.5, -0.5, 0.0,-0.5, -0.5, 1.0,-0.5, 0.5, 1.0,-0.5 // v4-v7-v6-v5 back ]); // Normal var normals = new Float32Array([ 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, // v7-v4-v3-v2 down 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0 // v4-v7-v6-v5 back ]); // Indices of the vertices var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]); initArrayBuffer(gl, a_Position, vertices, 3, gl.FLOAT); initArrayBuffer(gl, a_Normal, normals, 3, gl.FLOAT); let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer(gl, attribute, data, num, type) let buffer = gl.createBuffer(); let a_Attribute = gl.getAttribLocation(gl.program, attribute); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Attribute, num, type, false, 0, 0); gl.enableVertexAttribArray(a_Attribute); MultiJointModel_segmentfunction initVertexBuffers(gl) var vertices_base = new Float32Array([ // Base(10x2x10) ]); var vertices_arm1 = new Float32Array([ // Arm1(3x10x3) ]); var vertices_arm2 = new Float32Array([ // Arm2(4x10x4) ]); var vertices_palm = new Float32Array([ // Palm(2x2x6) ]); var vertices_finger = new Float32Array([ // Fingers(1x2x1) ]);// Normal var normals = new Float32Array([ ]);// Indices of the vertices var indices = new Uint8Array([ ]); // Write coords to buffer, but dont assign to attribute variables // Just like regist g_baseBuffer = initArrayBufferForLaterUse(gl, vertices_base, 3, gl.FLOAT); g_arm1Buffer = initArrayBufferForLaterUse(gl, vertices_arm1, 3, gl.FLOAT); g_arm2Buffer = initArrayBufferForLaterUse(gl, vertices_arm2, 3, gl.FLOAT); g_palmBuffer = initArrayBufferForLaterUse(gl, vertices_palm, 3, gl.FLOAT); g_fingerBuffer = initArrayBufferForLaterUse(gl, vertices_finger, 3, gl.FLOAT); // write normals to a buffer ,assign it to a_Normal initArrayBuffer(gl, a_Normal, normals, 3, gl.FLOAT); let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;// regist bufferfunction initArrayBufferForLaterUse(gl, data, num, type) let buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // set the num and type in advance // instead of use vertexAttribPointer buffer.num = num; buffer.type = type; return buffer;// regist buffer and assign function initArrayBuffer(gl, attribute, data, num, type) let buffer = gl.createBuffer(); let a_Attribute = gl.getAttribLocation(gl.program, attribute); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Attribute, num, type, false, 0, 0); gl.enableVertexAttribArray(a_Attribute);"},{"title":"鼠标交互","path":"/wiki/WebGL/chapter_10_01.html","content":"鼠标控制物体旋转简单实现思路 一句话：根据鼠标移动情况更新作用于物体顶点旋转矩阵。这是当鼠标左键按下时会发生的一些操作：记录鼠标左键 初始坐标鼠标移动时获取 当前坐标当前坐标减去初始坐标获得 鼠标位移根据位移计算 旋转矩阵根据旋转矩阵 更新顶点位置 RotateObject Code RotateObject运行结果Shadersmaindrawbuffertextureeventlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec2 a_TexCoord; uniform mat4 u_MvpMatrix; varying vec2 v_TexCoord; void main() gl_Position = u_MvpMatrix * a_Position; v_TexCoord = a_TexCoord; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform sampler2D u_Sampler; varying vec2 v_TexCoord; void main() gl_FragColor = texture2D(u_Sampler, v_TexCoord); `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(Failed to init shaders); return; gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); let n = initVertexBuffers(gl); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let vpMatrix = new Matrix4(); vpMatrix.setPerspective( 30, 1, 1, 100 ).lookAt( 3, 7, 7, 0, 0, 0, 0, 1, 0 ); let currentAngle = [0, 0]; if (!initEventHandlers(canvas, currentAngle)) console.log(Failed to init evnet handlers); return; if (!initTextures(gl)) console.log(failed to init texture); return; let tick = function (ev) draw(gl, n, vpMatrix, u_MvpMatrix, currentAngle); requestAnimationFrame(tick); ; tick();let g_MvpMatrix = new Matrix4();function draw(gl, n, vpMatrix, u_MvpMatrix, currentAngle) g_MvpMatrix.set(vpMatrix); g_MvpMatrix.rotate( currentAngle[0], 1, 0, 0 ).rotate( currentAngle[1], 0, 1, 0 ); gl.uniformMatrix4fv(u_MvpMatrix, false, g_MvpMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function initVertexBuffers(gl) var vertices = new Float32Array([ // Vertex coordinates 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, // v1-v6-v7-v2 left -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // v7-v4-v3-v2 down 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 // v4-v7-v6-v5 back ]); var texCoords = new Float32Array([ // Texture coordinates 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v1-v2-v3 front 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // v0-v3-v4-v5 right 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // v0-v5-v6-v1 up 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v1-v6-v7-v2 left 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // v7-v4-v3-v2 down 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 // v4-v7-v6-v5 back ]);// Indices of the vertices var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9, 10, 8, 10, 11, // up 12, 13, 14, 12, 14, 15, // left 16, 17, 18, 16, 18, 19, // down 20, 21, 22, 20, 22, 23 // back ]); initArrayBuffer(gl, a_Position, vertices, 3, gl.FLOAT); initArrayBuffer(gl, a_TexCoord, texCoords, 2, gl.FLOAT); let indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer(gl, attribute, data, num, type) let buffer = gl.createBuffer(); let a_Attribute = gl.getAttribLocation(gl.program, attribute); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Attribute, num, type, false, 0, 0); gl.enableVertexAttribArray(a_Attribute);function initTextures(gl) let texture = gl.createTexture(); let u_Sampler = gl.getUniformLocation(gl.program, u_Sampler); let image = new Image(); image.onload = function () loadTexture(gl, texture, u_Sampler, image); image.src = ../img/blueflower.jpg; return true;function loadTexture(gl, texture, u_Sampler, image) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image); gl.uniform1i(u_Sampler, 0);function initEventHandlers(canvas,currentAngle) let dragging = false; let lastX = -1, lastY = -1; canvas.onmousedown = function (ev) let x = ev.x, y = ev.y; let rect = ev.target.getBoundingClientRect(); if ( (rect.left = x x rect.right) (rect.top = y y rect.bottom) ) dragging = true; lastX = x; lastY = y; canvas.onmouseup = function (ev) dragging = false; canvas.onmousemove = function (ev) let x = ev.x, y = ev.y; if (dragging) let factor = 100 / canvas.height; let dx = factor * (x - lastX); let dy = factor * (y - lastY); // currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 360), -360); // currentAngle[1] = Math.max(Math.min(currentAngle[1] + dx, 360), -360); currentAngle[0] = currentAngle[0] + dy; currentAngle[1] = currentAngle[1] + dx; lastX = x; lastY = y; return true; 选中物体思考一下：如何使用数学过程来计算鼠标是否悬浮在某个图形上？ 简单实现思路 一句话：魔术把戏，利用超出人眼反应速度的刷新帧数来对物体进行切换。鼠标左键按下时：将立方体重绘为 单色 （假设红色）读取鼠标点击处的 像素颜色如果读取的颜色是 红色 ，就判断物体被选中将纯色立方体 复原重绘 成原来的纹理 PickObject Code PickObject运行结果Shadermaincheckdrawbufferlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_MvpMatrix; uniform bool u_Clicked; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; if (u_Clicked) v_Color = vec4(1.0, 0.0, 0.0, 1.0); else v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(Failed to init shaders); return; gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); let n = initVertexBuffers(gl); let u_Clicked = gl.getUniformLocation(gl.program, u_Clicked); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let vpMatrix = new Matrix4(); vpMatrix.setPerspective( 30, 1, 1, 100 ).lookAt( 0, 0, 7, 0, 0, 0, 0, 1, 0 ); // 初始化u_Clicked gl.uniform1i(u_Clicked, 0); let currentAngle = 0.0; canvas.onmousedown = function (ev) let x = ev.x, y = ev.y; let rect = ev.target.getBoundingClientRect(); if ((rect.left = x x rect.right) (rect.top = y y rect.bottom)) // pressed inside canvas // window.position → canvas.position let x_in_canvas = x - rect.left; let y_in_canvas = rect.bottom - y; let picked = check(gl, n, x_in_canvas, y_in_canvas, currentAngle, u_Clicked, vpMatrix, u_MvpMatrix); if (picked) alert(The cube was selected!); // 旋转动画 let tick = function() currentAngle = animate(currentAngle); draw(gl, n, currentAngle, vpMatrix, u_MvpMatrix); requestAnimationFrame(tick); tick();function check(gl, n, x, y, currentAngle, u_Clicked, vpMatrix, u_MvpMatrix) let picked = false; gl.uniform1i(u_Clicked, 1); // Pass true to u_Clicked draw(gl, n, currentAngle, vpMatrix, u_MvpMatrix); // Draw Cube with red let pixels = new Uint8Array(4); //Array for storing the pixel value gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels); if (pixels[0] === 255) //Selected picked = true; // rewrite the cube gl.uniform1i(u_Clicked, 0); draw(gl, n, currentAngle, vpMatrix, u_MvpMatrix); return picked;let g_MvpMatrix = new Matrix4();function draw(gl, n, currentAngle, vpMatrix, u_MvpMatrix) g_MvpMatrix.set(vpMatrix); g_MvpMatrix.rotate( currentAngle, 1, 1, 1 ); gl.uniformMatrix4fv(u_MvpMatrix, false, g_MvpMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);let ANGLE_STEP = 20.0;let g_last = Date.now();function animate(currentAngle) let now = Date.now(); let elapse = now - g_last; g_last = now; return (currentAngle + elapse * ANGLE_STEP / 1000) % 360;function initVertexBuffers(gl) // Create a cube // v6----- v5 // /| /| // v1------v0| // | | | | // | |v7---|-|v4 // |/ |/ // v2------v3 var vertices = new Float32Array([ // Vertex coordinates 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0,-1.0, 1.0, 1.0,-1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0,-1.0, -1.0, 1.0,-1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0,-1.0, -1.0,-1.0,-1.0, -1.0,-1.0, 1.0, // v1-v6-v7-v2 left -1.0,-1.0,-1.0, 1.0,-1.0,-1.0, 1.0,-1.0, 1.0, -1.0,-1.0, 1.0, // v7-v4-v3-v2 down 1.0,-1.0,-1.0, -1.0,-1.0,-1.0, -1.0, 1.0,-1.0, 1.0, 1.0,-1.0 // v4-v7-v6-v5 back ]); var colors = new Float32Array([ // Colors 0.2, 0.58, 0.82, 0.2, 0.58, 0.82, 0.2, 0.58, 0.82, 0.2, 0.58, 0.82, // v0-v1-v2-v3 front 0.5, 0.41, 0.69, 0.5, 0.41, 0.69, 0.5, 0.41, 0.69, 0.5, 0.41, 0.69, // v0-v3-v4-v5 right 0.0, 0.32, 0.61, 0.0, 0.32, 0.61, 0.0, 0.32, 0.61, 0.0, 0.32, 0.61, // v0-v5-v6-v1 up 0.78, 0.69, 0.84, 0.78, 0.69, 0.84, 0.78, 0.69, 0.84, 0.78, 0.69, 0.84, // v1-v6-v7-v2 left 0.32, 0.18, 0.56, 0.32, 0.18, 0.56, 0.32, 0.18, 0.56, 0.32, 0.18, 0.56, // v7-v4-v3-v2 down 0.73, 0.82, 0.93, 0.73, 0.82, 0.93, 0.73, 0.82, 0.93, 0.73, 0.82, 0.93, // v4-v7-v6-v5 back ]); // Indices of the vertices var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]); // Write vertex information to buffer object if (!initArrayBuffer(gl, vertices, gl.FLOAT, 3, a_Position)) return -1; // Coordinate Information if (!initArrayBuffer(gl, colors, gl.FLOAT, 3, a_Color)) return -1; // Color Information // Create a buffer object var indexBuffer = gl.createBuffer(); if (!indexBuffer) return -1; // Write the indices to the buffer object gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer (gl, data, type, num, attribute) // Create a buffer object var buffer = gl.createBuffer(); if (!buffer) console.log(Failed to create the buffer object); return false; // Write date into the buffer object gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // Assign the buffer object to the attribute variable var a_attribute = gl.getAttribLocation(gl.program, attribute); if (a_attribute 0) console.log(Failed to get the storage location of + attribute); return false; gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0); // Enable the assignment to a_attribute variable gl.enableVertexAttribArray(a_attribute); return true; 程序分析 readPixels读取点击处像素颜色 读取来源是 颜色缓冲区 读取位置由 x、y 确定 读取大小由 width、height 确定 读取结果存放在 pixels 中 pixels 必须是 Uint8Array 类型的数组 注意： 对于绑定在 gl.FRAMEBUFFER 上的 帧缓冲区对象，readPixels读取的是 帧缓冲区 ，而非颜色缓冲区。 通过阻塞代码运行观察重绘前的立方体通过指定颜色判断是否选中物体方法的局限如果场景中有很多的物体，可以 为每个物体分配一个唯一的颜色值。颜色缓冲区中：RGBA 每个分量都是8bit。那么RGBA一共就可以表示 32bit，也就是可以区分 2^32 种物体。 其他判断物体选中的方法 使用简化的模型缩小绘图区域使用帧缓冲区对象 选中一个表面实际上使用的是和PickObject同样的方法 与PickObject不同的地方在 用户点击鼠标重绘立方体时，将 每个像素属于哪个面 的信息写入到 颜色缓冲区 的 α分量 中。即鼠标点击事件被触发之后，不是将物体颜色进行重写，而是使用指定值对颜色透明度通道进行重写，当然也可以对其它通道进行与立方体面序号绑定的重写。 PickFace Code PickFaceshadermainlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute float a_Face; // Surface number uniform mat4 u_MvpMatrix; uniform int u_PickedFace; // selected surface number varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; int face = int(a_Face); // Convert to int vec3 color = (face == u_PickedFace) ? vec3(1.0) : a_Color.rgb; if(u_PickedFace == 0) // In case of 0, insert the face number into alpha v_Color = vec4(color, a_Face/255.0); else v_Color = vec4(color, a_Color.a); `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); let n = initVertexBuffers(gl); let currentAngle = 0; let vpMatrix = new Matrix4().setPerspective( 30, 1, 1, 100 ).lookAt( 7, 0, 0, 0, 0, 0, 0, 1, 0 ); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_PickedFace = gl.getUniformLocation(gl.program, u_PickedFace); gl.uniform1i(u_PickedFace, -1); canvas.onmousedown = function (ev) let x = ev.x, y = ev.y; let rect = ev.target.getBoundingClientRect(); if ((rect.left = x x rect.right) (rect.top = y y rect.bottom)) let x_in_canvas = x - rect.left; let y_in_canvas = rect.bottom - y; let face = checkFace(gl, n, vpMatrix, currentAngle, u_MvpMatrix, u_PickedFace, x_in_canvas, y_in_canvas); gl.uniform1i(u_PickedFace, face); draw(gl, n, vpMatrix, currentAngle, u_MvpMatrix); let tick = function () currentAngle = animate(currentAngle); draw(gl, n, vpMatrix, currentAngle, u_MvpMatrix); requestAnimationFrame(tick); tick();function checkFace(gl,n,vpMatrix,currentAngle,u_MvpMatrix,u_PickedFace,x,y) let pixels = new Uint8Array(4); gl.uniform1i(u_PickedFace, 0); draw(gl, n, vpMatrix, currentAngle, u_MvpMatrix); gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels); return pixels[3]; 为什么在着色器中需要对a_Face进行强制转换？ attribute float a_Face;void main() ... int face = int(a_Face); ...答： 因为 attribute 类型的变量不支持 int 类型，并且需要与 int类型 的 u_PickedFace 进行比较。uniform int u_PickedFace;void main() ... vec3 color = (face == u_PickedFace) ? vec3(1.0) : a_Color.rgb; ...注意：在之后计算 α通道数值 的时候使用的是 未经转换的a_Face 。v_Color = vec4( color, a_Face/255.0);"},{"title":"initShaders函数","path":"/wiki/WebGL/chapter_09_02.html","content":"步骤简述一句话说清initShaders函数的功能 编译GLSL ES代码，创建和初始化着色器提供WebGL使用。 7个主要步骤 Step1 gl.createShader()创建着色器对象Step2 gl.shaderSource()向着色器对象中填充着色器程序的源代码Step3 gl.compileShader编译着色器Step4 gl.createProgram()创建程序对象Step5 gl.attachShader()为程序对象分配着色器Step6 gl.linkProgram()连接程序对象Step7 gl.useProgram()使用程序对象两种对象一个程序对象对应两个着色器对象 着色器对象 shader object 管理一个 顶点着色器 或 片元着色器每一个着色器都有一个 着色器对象 程序对象 program object管理 着色器对象 的容器一个程序对象必须包含一个 顶点着色器 和一个 片元着色器 步骤详述Step1 创建着色器对象 createShader 参数指定 着色器类型：gl.VERTEX_SHADER 顶点着色器gl.FRAGMENT_SHADER 片元着色器 deleteShader 如果着色器对象还在使用，deleteShader不会立刻执行，而是等待着色器不再被占用后再将其删除。 Step2 指定着色器对象的代码 Step3 编译着色器 compileShader 关于编译的时机如果调用 shaderSource 重新指定着色器代码，就一定要使用 compileShader 手动重新编译，否则WebGL系统中旧代码部分不会被自动替换。 getShaderParameter 是用来 检查着色器的状态的 ，第二个参数pname和返回值有如下关系：pnamedescriptionreturngl.SHADER_TYPE着色器类型gl.VERTEX_SHADERgl.FRAGMENT_SHADERgl.DELETE_STATUS是否被删除成功truefalsegl.COMPILE_STATUS是否被编译成功truefalse getShaderInfoLog 在 编译失败 的情况下使用，即在 gl.getShaderParameter(shader,gl.COMPILE_STATUS) = false 的情况下。返回值为编译错误时 WebGL写入着色器的 信息日志（information log）。 Step4 创建程序对象 gl.createProgram() 用于 创建程序对象。let a_Position = gl.getAttribLocation(gl.program,a_Position);let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix);gl.getAttribLocation 和 gl.getUniformLocation 的第一个参数 gl.program 就是 程序对象 gl.deleteProgram() 用于 删除程序对象。 Step5 为程序对象分配着色器对象 attachShader 用于 分配着色器，每个程序必须对应 一个顶点着色器 和 一个片元着色器。把空的着色器附给程序对象也可以 detachShader 用于 解除已分配的着色器。 Step6 连接程序对象 linkProgram 用于 连接顶点着色器和片元着色器。连接着色器的目的对顶点片元着色器的 varying变量 进行 同名同类型对应确保顶点着色器的 每个varying都赋了值对顶点片元着色器的 uniform变量 进行 同类型对应确保attribute、uniform、varying变量的个数没有超过 着色器的上限 getProgramParameter 用于检查 着色器是否连接成功。连接成功 向WebGL系统返回一个 二进制可执行模块连接失败 会在 信息日志 中生产成 连接出错信息LINK_STATUS和VALIDATE_STATUS的区别LINK_STATUS 程序是否 成功连接仅检测 连接阶段VALIDATE_STATUS 程序是否 通过验证检测 运行阶段性能开销很大，通常在 调试程序 时这样做 getProgramInfoLog 用于 从信息日志中获取连接出错信息 Step7 告知WebGL系统所使用的程序对象 这也为WebGL提供了一个强大的特性：只需要准备多个 程序对象，绘制时根据需要 切换程序对象。 内部流程initShaders(gl, vshader, fshader) function initShaders(gl, vshader, fshader) // 1. 创建一个连接好的程序对象 let program = createProgram(gl, vshader, fshader); if (!program) console.log(Failed to create program); return false; // 2. 告诉WebGL系统来使用这个程序对象 gl.useProgram(program); // 3. 将程序对象设为gl对象的program属性 gl.program = program; createProgram(gl, vshader, fshader) function createProgram(gl, vshader, fshader) // 1. 创建着色器对象 let vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader); let fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader); if (!vertexShader || !fragmentShader) return null; // 2. 创建程序对象 let program = gl.createProgram(); if (!program) return null; // 3. 分配着色器 gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); // 4. 连接着色器 gl.linkProgram(program); // 5. 检查连接 let linked = gl.getProgramParameter(program, gl.LINK_STATUS); if (!linked) let error = gl.getProgramInfoLog(program); console.log(Failed to link program: + error); // 删除程序和着色器 gl.deleteProgram(program); gl.deleteShader(fragmentShader); gl.deleteShader(vertexShader); return null; return program; loadShader(gl, type, source) function loadShader(gl, type, source) // 1. 创建着色器对象 let shader = gl.createShader(type); if (shader == null) console.log(unable to create shader); return null; // 2. 设置着色器源代码 gl.shaderSource(shader, source); // 3. 编译着色器 gl.compileShader(shader); // 4. 检查着色器的编译状态 if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) let error = gl.getShaderInfoLog(shader); console.log(failed to compile shader: + error); gl.deleteShader(shader); return null; return shader;"},{"title":"HUD","path":"/wiki/WebGL/chapter_10_02.html","content":"HUD平视显示器什么是HUD？ 答： head up display ，即 平视显示器 。之所以是 平视 ， 是因为最初是用于称呼方便飞行员能够平视前方的驾驶舱玻璃就能够看到仪表图形投影的显示器。 本例要实现的HUD即在三维场景前方绘制二维三角形和文本。 简单实现思路 为 三维图形 和 二维图形 各自准备一个 canvas。将两个canvas 重叠放置 （HUD在上）。在三维canvas上使用 WebGL API 绘制三维场景。在二维canvas上使用 canvas 2D API绘制HUD信息。 HUD Code HUD运行效果htmlmaindraw2Dbody onload=main() canvas id=webgl width=400 height=400 style=position:absolute; z-index:0;/canvas canvas id=hud width=400 height=400 style=position:absolute; z-index:1;/canvas/bodyfunction main() let canvas = document.getElementById(webgl); let hud = document.getElementById(hud); let gl = getWebGLContext(canvas); let ctx = hud.getContext(2d); ... let tick = function () currentAngle = animate(currentAngle); draw(gl, n, vpMatrix, currentAngle, u_MvpMatrix); draw2D(ctx, currentAngle); requestAnimationFrame(tick); tick(); hud.onmousedown = function (ev) ... function draw2D(ctx, currentAngle) // Draw triangle ctx.clearRect(0, 0, 400, 400); ctx.beginPath(); ctx.moveTo(120, 10); ctx.lineTo(200, 150); ctx.lineTo(40, 150); ctx.closePath(); ctx.strokeStyle = rgba(0,255,0,1); ctx.stroke(); // Draw letters ctx.font = 18px Times New Roman; ctx.fillStyle = rgba(0,255,0,1); ctx.fillText(HUD: Head Up Display, 40, 180); ctx.fillText(Triangle is drawn by Canvas 2D API,, 40, 200); ctx.fillText(Cube is drawn by WebGL API., 40, 220); ctx.fillText(Current Angle: + Math.floor(currentAngle), 40, 240); 有关程序的一些问题。 HUD.js大部分是基于PickFace.js的，二者的区别在哪里？ 获取的上下文不同 PickFace 只获取三维画布let canavs = document.getElementById(webgl);let gl = getWebGLContext(canvas); HUD 获取二维和三维画布let canavs = document.getElementById(webgl);let hud = document.getElementById(hud);let gl = getWebGLContext(canvas);let ctx = getWebGLContext(hud); 鼠标点击事件注册的画布不同（主要是因为画布层级不同） PickFace 的鼠标事件注册到 三维画布 上canvas.onmousedown = function(ev)... HUD 的鼠标事件注册到 二维画布 上hud.onmousedown = function(ev)... draw2D中绘制使用的函数都具有什么特征？W3C对canvas方法的介绍https://www.w3school.com.cn/tags/html_ref_canvas.asp clearRectctx.clearRect(0,0,400,400)用于清除给定矩形内的像素。beginPathctx.beginPath()用于起始一条路径，或重置当前路径。moveToctx.moveTo(120, 10);用于把路径移动到画布中的指定点，不创建线条。lineToctx.lineTo(200,150);ctx.lineTo(40,150);用于添加一个新点，然后在画布中创建从该点到最后指定点的线条。closePathctx.closePath();用于创建从当前点回到起始点的路径。strokectx.strokeStyle = rgba(0,255,0,1);用于设置或返回用于笔触的颜色、渐变或模式。ctx.stroke();用于绘制已定义的路径。textctx.font = 18px Times New Roman;用于设置或返回文本内容的当前字体属性ctx.fillStye = rgba(0,255,0,1);用于设置或返回用于填充绘画的颜色、渐变或模式。ctx.fillText(HUD: Head Up Display, 40, 180);ctx.fillText(Triangle is drawn by Canvas 2D API,, 40, 200);ctx.fillText(Cube is drawn by WebGL API., 40, 220);ctx.fillText(Current Angle: + Math.floor(currentAngle), 40, 240);用于在画布上绘制被填充的文本。 在网页上方显示三维物体该程序是基于PickFace。 3DoverWeb Code 3DoverWeb运行效果htmljsbody onload=main() canvas id=webgl width=400 height=400 style=position:absolute;/canvas div h119h1 h2Great Designs Come from Great Designers --- Not from Great Design Processes/h2 pThe basic premise underlying the SEIs [Software Engineering Institute] work on software process maturity is that the quality of a software product is largely determined by the quality of the software development and maintenance processes used to build it./p Mark Paulk [1995], The evolution of clothe SEIs capability maturity model for software p...[W]hile some may see them as the crazy ones, we see genius, because the ones who are crazy enough to think that they can change the world, are the ones who do./p Steve Jobs, Apple commercial (1997) /div/body与PickFace唯一的不同就是canvas背景色的设置。...function main() ... gl.clearColor(0,0,0,0); ..."},{"title":"雾化/圆点","path":"/wiki/WebGL/chapter_10_03.html","content":"什么是雾化？ 答： 在三维图形学中，雾化（fog） 指的是远处的物体看上去较为模糊的现象。 如何实现雾化？线性雾化（linear fog） 线性雾化表示 雾化程度与该点与视点的距离呈线性关系。雾化程度取决于 它与视点之间的距离。 雾化起点 开始雾化之处雾化终点 完全雾化之处 雾化因子（fog factor） 某一点雾化的程度可以被定义为 雾化因子（fog factor）雾化因子计算公式雾化因子 （ 终点 - 当前点与视点间的距离 ）（终点 - 起点 ）雾化因子与视点距离线性关系图物体离视点越远，雾化因子越小，物体越模糊。根据雾化因子计算片元颜色公式片元颜色 【物体表面颜色 * 雾化因子】 + 【雾的颜色 * （1 - 雾化因子）】 雾化程序实现思路 注意此程序的雾化因子是在世界坐标系下计算的。顶点着色器计算出当前顶点与视点距离，传入片元着色器。片元着色器根据 片元与视点的距离，计算出 雾化因子。 Fog Code Fog运行效果shadermainkeydownbufferlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_MvpMatrix; uniform mat4 u_ModelMatrix; uniform vec4 u_Eye; // 视点 varying vec4 v_Color; varying float v_Dist; void main() gl_Position = u_MvpMatrix * a_Position; v_Color = a_Color; // Calculate the distance to each vertex from eye point // 计算世界坐标系下，视点和物体之间的距离 v_Dist = distance(u_ModelMatrix * a_Position, u_Eye); `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform vec3 u_FogColor; uniform vec2 u_FogDist; varying vec4 v_Color; varying float v_Dist; void main() float fogFactor = clamp((u_FogDist.y - v_Dist)/(u_FogDist.y-u_FogDist.x),0.0,1.0); vec3 color = mix(u_FogColor,vec3(v_Color),fogFactor); gl_FragColor = vec4(color,v_Color.a); `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl,VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shader); return; let n = initVertexBuffers(gl); let fogColor = new Float32Array([0.137, 0.231, 0.323]); let fogDist = new Float32Array([55, 80]); let eye = new Float32Array([25, 65, 35, 1.0]); let u_MvpMatrix = gl.getUniformLocation(gl.program, u_MvpMatrix); let u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); let u_Eye = gl.getUniformLocation(gl.program, u_Eye); let u_FogColor = gl.getUniformLocation(gl.program, u_FogColor); let u_FogDist = gl.getUniformLocation(gl.program, u_FogDist); gl.uniform3fv(u_FogColor, fogColor); gl.uniform2fv(u_FogDist, fogDist); gl.uniform4fv(u_Eye, eye); gl.clearColor(...fogColor,1.0); gl.enable(gl.DEPTH_TEST); let modelMatrix = new Matrix4(); modelMatrix.setScale(10, 10, 10); //世界坐标转换矩阵 gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); let mvpMatrix = new Matrix4(); mvpMatrix.setPerspective( 30, 1, 1, 1000 ).lookAt( ...eye, 0, 2, 0, 0, 1, 0 ).multiply(modelMatrix); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); document.onkeydown = function (ev) keydown(ev, gl, n, u_FogDist, fogDist); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function keydown(ev, gl, n, u_FogDist, fogDist) switch (ev.keyCode) case 38: fogDist[1] += 1; break; //↑ case 40: if (fogDist[1] fogDist[0]) fogDist[1] -= 1; break; default: return; gl.uniform2fv(u_FogDist, fogDist); //Pass the distance of fog gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);function initVertexBuffers(gl) // Create a cube // v6----- v5 // /| /| // v1------v0| // | | | | // | |v7---|-|v4 // |/ |/ // v2------v3 var vertices = new Float32Array([ // Vertex coordinates 1, 1, 1, -1, 1, 1, -1,-1, 1, 1,-1, 1, // v0-v1-v2-v3 front 1, 1, 1, 1,-1, 1, 1,-1,-1, 1, 1,-1, // v0-v3-v4-v5 right 1, 1, 1, 1, 1,-1, -1, 1,-1, -1, 1, 1, // v0-v5-v6-v1 up -1, 1, 1, -1, 1,-1, -1,-1,-1, -1,-1, 1, // v1-v6-v7-v2 left -1,-1,-1, 1,-1,-1, 1,-1, 1, -1,-1, 1, // v7-v4-v3-v2 down 1,-1,-1, -1,-1,-1, -1, 1,-1, 1, 1,-1 // v4-v7-v6-v5 back ]); var colors = new Float32Array([ // Colors 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, // v0-v1-v2-v3 front 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, // v0-v3-v4-v5 right 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, // v0-v5-v6-v1 up 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, // v1-v6-v7-v2 left 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v7-v4-v3-v2 down 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0 // v4-v7-v6-v5 back ]); var indices = new Uint8Array([ // Indices of the vertices 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]); // Create a buffer object var indexBuffer = gl.createBuffer(); if (!indexBuffer) return -1; // Write the vertex property to buffers (coordinates and normals) if (!initArrayBuffer(gl, vertices, 3, gl.FLOAT, a_Position)) return -1; if (!initArrayBuffer(gl, colors, 3, gl.FLOAT, a_Color)) return -1; // Write the indices to the buffer object gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); return indices.length;function initArrayBuffer (gl, data, num, type, attribute) // Create a buffer object var buffer = gl.createBuffer(); if (!buffer) console.log(Failed to create the buffer object); return false; // Write date into the buffer object gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // Assign the buffer object to the attribute variable var a_attribute = gl.getAttribLocation(gl.program, attribute); if (a_attribute 0) console.log(Failed to get the storage location of + attribute); return false; gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0); // Enable the assignment of the buffer object to the attribute variable gl.enableVertexAttribArray(a_attribute); // Unbind the buffer object gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; 程序解析 如何使用distance()计算顶点与视点间的距离？// 顶点与视点间距 = distance( 顶点坐标, 视点坐标)v_Dist = distance( u_ModelMatrix * a_Position, u_Eye); u_ModelMatrix： 将顶点转换到 世界坐标系 下的模型矩阵 u_ModelMatrix*a_Position： 世界坐标系下的 顶点坐标 u_Eye： 世界坐标系下的 视点坐标 如何使用clamp()计算雾化因子大小？float fogFactor = clamp( (u_FogDist.y - v_Dist) / (u_FogDist.y - u_FogDist.x), 0.0, 1.0 ); u_FogDist 雾的范围 u_FogDist.x 雾的起点 u_FogDist.y 雾的终点 u_FogDist.y - u_FogDist.x 起点与终点之间的距离 v_Dist 顶点与视点间的距离 clamp函数 功能 对计算结果进行区间限制参数参数1 计算出的雾化因子参数2 区间的最小值参数3 区间的最大值 如何使用mix()计算片元颜色？vec3 color = mix(u_FogColor, vec3(v_Color), fogFactor); 在这里我们可以这样设置： x u_FogColor 表示雾的颜色 y vec3(v_Color) 表示物体表面颜色 z fogFactor 表示雾化因子 mix(x,y,z) = x*(1-z) + y*z; x与z成 反比 y与z成 正比 除了线性雾化，还有其他哪些雾化算法？答： 还有指数雾化算法等等。想要使用其他的雾化算法，只需 修改雾化指数的计算方法 。 使用w分量近似估算法 Fog.js中shader程序的缺陷即在 顶点着色器 中计算 顶点与视点的距离 ,会造成较大的开销，影响性能。近似估算法需要为视点和视线设置 特殊条件： 视点 在 原点视线 沿 Z轴负方向由此可以推出几个结论：在观察者坐标系下，物体及视图的 z分量都是负值w分量可以直接看做 顶点与视点的距离w分量是vec4类型的顶点坐标的最后一个分量w分量的值刚好是 z分量值乘以-1 比较两种方法的vertex shader程序 通过distance计算距离void main() gl_Position = u_MvpModel * a_Position; v_Color = a_Color; v_Dist = distance( u_ModelMatrix * a_Position, u_Eye); 通过w分量估算距离void main() gl_Position = u_MvpMatrix * a_Position; v_Color = a_Color; v_Dist = gl_Position.w; 绘制圆形的点如何绘制圆点？ 答： 像做饼干一样，需要将原先的方点 削减 成圆形。 削减的过程就和做饼干一样在做饼干的时候，饼干模具会帮助我们切割甜饼。但是在计算机中没有模具，要借助什么工具判断切割边界呢？答案就是坐标系。 需要切割的片元 以坐标轴作为切割工具 gl_PointCoord步骤1 检查当前片元是否距离点中心 **（0.5,0.5）**距离超过0.5步骤2 如果是，使用 discard 语句放弃此片元 RoundedPoint Code RoundedPoint运行效果shadermainbufferlet VSHADER_SOURCE = ` attribute vec4 a_Position; void main() gl_Position = a_Position; gl_PointSize = 10.0; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif void main() float d = distance(gl_PointCoord, vec2(0.5,0.5)); if(d0.5) gl_FragColor = vec4(0.0,1.0,0.0,1.0); else discard; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; let n = initVertexBuffers(gl); gl.clearColor(0, 0, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n); function initVertexBuffers(gl) let vertices = new Float32Array([ 0, 0.5, -0.5, -0.5, 0.5, -0.5 ]); let n = 3; let a_Position = gl.getAttribLocation(gl.program, a_Position); let vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return n; 绘制逻辑简述 实际上所有的绘制逻辑在 片元着色器 中实现： 计算片元距离所属点中心的距离 float d = distance(gl_PointCoord,vec2(0.5,0.5));如果距离小于0.5就绘制，否则舍弃 if(d0.5) gl_FragColor = vec4(0.0,1.0,0.0,1.0);else discard;"},{"title":"α混合","path":"/wiki/WebGL/chapter_10_04.html","content":"α分量 代表 R G B A 中的 A通过控制A分量来实现半透明效果的方式，被称为 α混合（alpha blending）。 实现α混合教堂半透明的彩色玻璃是宗教美学的典型代表 如何开启α混合 开启混合功能gl.enable(gl.BLEND);指定混合函数gl.blendFunc(gl.SRC.ALPHA,gl.ONE_MINUS_SRC_ALPHA); LookAtBlendedTriangles Code shadermaininitVertexBufferskeydown&&drawlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_ViewMatrix; uniform mat4 u_ProjMatrix; varying vec4 v_Color; void main() gl_Position = u_ProjMatrix * u_ViewMatrix * a_Position; v_Color = a_Color; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders); return; gl.clearColor(0, 0, 0, 1); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); let u_ProjMatrix = gl.getUniformLocation(gl.program, u_ProjMatrix); let u_ViewMatrix = gl.getUniformLocation(gl.program, u_ViewMatrix); let viewMatrix = new Matrix4(); let projMatrix = new Matrix4(); projMatrix.setOrtho( -1, 1, -1, 1, 0, 2 ); gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements); let n = initVertexBuffers(gl); draw(gl, n, u_ViewMatrix, viewMatrix); window.onkeydown = function (ev) keydown(gl, ev, n, u_ViewMatrix, viewMatrix); function initVertexBuffers(gl) let verticesColors = new Float32Array([ 0.0, 0.5, -0.4, 0.4, 1.0, 0.4, 0.4, // The back green one -0.5, -0.5, -0.4, 0.4, 1.0, 0.4, 0.4, 0.5, -0.5, -0.4, 1.0, 0.4, 0.4, 0.4, 0.5, 0.4, -0.2, 1.0, 0.4, 0.4, 0.4, // The middle yerrow one -0.5, 0.4, -0.2, 1.0, 1.0, 0.4, 0.4, 0.0, -0.6, -0.2, 1.0, 1.0, 0.4, 0.4, 0.0, 0.5, 0.0, 0.4, 0.4, 1.0, 0.4, // The front blue one -0.5, -0.5, 0.0, 0.4, 0.4, 1.0, 0.4, 0.5, -0.5, 0.0, 1.0, 0.4, 0.4, 0.4, ]); let n = 9; let FSIZE = verticesColors.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, a_Position); let a_Color = gl.getAttribLocation(gl.program, a_Color); let vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW); gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE*7, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 4, gl.FLOAT, false, FSIZE*7, FSIZE*3); gl.enableVertexAttribArray(a_Color); return n;let g_EyeX = 0.2, g_EyeY = 0.25, g_EyeZ = 0.25;function keydown(gl, ev, n,u_ViewMatrix, viewMatrix) switch (ev.keyCode) case 37: g_EyeX -= 0.01; break; case 39: g_EyeX += 0.01; break; default: break; draw(gl, n, u_ViewMatrix, viewMatrix);function draw(gl, n, u_ViewMatrix, viewMatrix) viewMatrix.setLookAt( g_EyeX, g_EyeY, g_EyeZ, 0, 0, 0, 0, 1, 0 ); gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n); 混合函数gl.blendFunc() 在LookAtBlendedTriangles中有两行涉及α混合的关键代码：gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);α混合涉及两个颜色：源颜色（source color）待混合进去的颜色，也可以说是要叠加的对象的颜色像 加奶咖啡 里的 牛奶（加进去的原料）目标颜色（destination color）待被混合进去的颜色，也可以说是画板上已有的颜色像 加奶咖啡 里的 咖啡（被加的基底）源颜色就像拿铁里调和风味的牛奶，目标颜色则是作为基底的咖啡加法混合（additive blending）加法混合会使被混合的区域更加明亮，所以常常用来实现 爆炸 的光照效果。blendFunc的参数源颜色分量：（Rs，Gs，Bs，As）目标颜色分量：（Rd，Gd，Bd，Ad）镂空效果：gl.blendFunc(gl.ZERO,gl.ZERO) src_factor gl.ZERO 表示忽视源颜色 dst_factor gl.ZERO 表示忽视目标颜色 同时忽视源颜色和目标颜色，就表示镂空处理 gl.blendFunc(gl.ZERO,gl.ZERO)涉及到的计算 镂空效果只取源颜色gl.blendFunc(gl.ONE,gl.ZERO) src_factor gl.ONE 表示完全保留源颜色 dst_factor gl.ZERO 表示忽视目标颜色 完全忽视底色，直接将源颜色绘制在无视canvas背景画布的dom容器之中 gl.blendFunc(gl.ONE,gl.ZERO)涉及到的计算 由于物体是半透明的，直接和body的颜色混合在了一起，无视了canvas背景色只取目标颜色gl.blendFunc(gl.ZERO,gl.ONE) src_factor gl.ONE 表示忽视源颜色 dst_factor gl.ZERO 表示完全保留目标颜色 完全忽视源颜色，保留目标颜色就表示保存画布，什么都不绘制 好像在用透明墨水画画一样 gl.blendFunc(gl.ZERO,gl.ONE)涉及到的计算 物体的确是画了，但只是颜色是透明的（笑） 半透明的三维物体彩虹水晶 在ColoredCube基础之上 还记的ColoredCube运行效果吗？http://localhost:4000/wiki/webgl/chapter_22.html#%E4%B8%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%A1%A8%E9%9D%A2%E6%8C%87%E5%AE%9A%E9%A2%9C%E8%89%B2按照之前介绍的实现 α混合 的方法，我们为颜色缓冲区填入的数据添加上透明度： let colors = new Float32Array([ 0.4, 0.4, 1.0, 0.4, 0.4, 0.4, 1.0,0.4, 0.4, 0.4, 1.0,0.4, 0.4, 0.4, 1.0,0.4, //front 0.4, 1.0, 1.0, 0.4, 0.4, 1.0, 1.0,0.4, 0.4, 1.0, 1.0,0.4, 0.4, 1.0, 1.0,0.4, //back 1.0, 1.0, 0.4, 0.4, 1.0, 1.0, 0.4,0.4, 1.0, 1.0, 0.4,0.4, 1.0, 1.0, 0.4,0.4, //left 0.4, 1.0, 0.4, 0.4, 0.4, 1.0, 0.4,0.4, 0.4, 1.0, 0.4,0.4, 0.4, 1.0, 0.4,0.4, //right 1.0, 0.4, 0.4, 0.4, 1.0, 0.4, 0.4,0.4, 1.0, 0.4, 0.4,0.4, 1.0, 0.4, 0.4,0.4, //up 1.0, 1.0, 1.0, 0.4, 1.0, 1.0, 1.0,0.4, 1.0, 1.0, 1.0,0.4, 1.0, 1.0, 1.0,0.4, //down]);initArrayBuffer(gl, a_Color, colors, 4, gl.FLOAT);再加上开启α混合的配置代码：gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);应该就可以实现了，但是事实上的运行效果却和期望得到的不同：实际上并没有实现透明为什么没有实现透明呢？答： 因为开启了 DEPTH_TEST（隐藏面消除） 。 gl.enable(gl.DEPTH_TEST);开启了隐藏面消除会使得 被隐藏的片元根本不被绘制 ， 自然更不会有混合过程。所以只需要 关闭gl.DEPTH_TEST 即可。 开启DEPTH_TEST隐藏面没有被绘制，因此不存在混合过程 关闭DEPTH_TEST将隐藏面纳入混合过程之中 透明与不透明物体共存如何同时实现隐藏面消除和半透明效果？ BlendedCube直接把DEPTH_TEST关闭了，这种方法太简单粗暴，一点都不优雅。可以通过使用下面这种机制同时实现 隐藏面消除 和 半透明效果。提前剧透： 将透明物体和非透明物体分开绘制1.开启gl.DEPTH_TESTgl.enable(gl.DEPTH_TEST);2.绘制出所有不透明的物体gl.drawElements(非透明物体)3.禁止深度缓冲区的写入操作深度缓冲区是用于进行 隐藏面消除 的，这一步需要禁止接下来深度缓冲区的 写入操作，使之变得 只读。gl.depthMask(false);4.绘制所有半透明物体注意它们应当按照 深度进行排序gl.drawElements(半透明物体)5.释放深度缓冲区重新使深度缓冲区 可读写gl.depthMask(true); BlendedWithDepthMask BlendedWithDepthMask运行效果> 主要绘制逻辑function draw(gl, u_MvpMatrix, mvpMatrix, projMatrix) // 1. 清除缓冲区 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 2. 绘制不透明物体 let n_Solid = initVertexBuffer_Solid(gl); gl.drawElements(gl.TRIANGLES,n_Solid,gl.UNSIGNED_BYTE,0); // 3.禁止深度缓冲区的写入操作 gl.depthMask(false); // 4.绘制透明物体 let n_Blend = initVertexBuffer_Blend(gl); gl.drawElements(gl.TRIANGLES,n_Blend,gl.UNSIGNED_BYTE,0); // 5.解锁深度缓冲区写入操作 gl.depthMask(true);"},{"title":"切换着色器","path":"/wiki/WebGL/chapter_10_05.html","content":"一个着色器够用吗？ 这个问题就好像别人问你：一天一顿饭能吃饱吗？一年一双袜子够穿吗？笔记本4G内存够用吗？答案自然是 可以，但没必要，不同的物体经常需要使用不同的着色器绘制。 如何实现切换着色器切换步骤 说是切换步骤，实际上每个绘制过程的步骤都是完全分离，互不影响的。1.准备阶段A准备用来绘制 A物体 的着色器 ShaderA 的代码2.准备阶段B准备用来绘制 B物体 的着色器 ShaderB 的代码3.创建阶段A调用 createProgram() ，使用 ShaderA 创建出着色器程序对象 ProgramA4.创建阶段B调用 createProgram() ，使用 ShaderB 创建出着色器程序对象 ProgramB5.绘制A①调用 gl.useProgram() 指定 ProgramA6.绘制A②通过缓冲区对象向 ShaderA 传入attribute变量并开启7.绘制A③绘制A8.绘制B①调用 gl.useProgram() 指定 ProgramB9.绘制B②通过缓冲区对象向 ShaderB 传入attribute变量并开启10.绘制B③绘制B ProgramObject Code ProgramObject运行效果shaderstoggle shaderinit buffer&vertexdrawuniform function// 第一步：准备着色器// 纯色立方体-顶点着色器let SOLID_VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_NormalMatrix; varying vec4 v_Color; void main() vec3 lightDirection = vec3(0.0, 0.0, 1.0); vec4 color = vec4(0.0,1.0,0.0,1.0); gl_Position = u_MvpMatrix * a_Position; vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal)); float nDotL = max(dot(normal,lightDirection), 0.0); v_Color = vec4(color.rgb * nDotL, color.a); `// 纯色立方体-片元着色器let SOLID_FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `// 纹理立方体-顶点着色器let TEXTURE_VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Normal; attribute vec2 a_TexCoord; uniform mat4 u_MvpMatrix; uniform mat4 u_NormalMatrix; varying vec2 v_TexCoord; varying float v_NdotL; void main() vec3 lightDirection = vec3(0.0, 0.0, 1.0); gl_Position = u_MvpMatrix * a_Position; v_TexCoord = a_TexCoord; vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal)); v_NdotL = max(dot(normal, lightDirection), 0.0); `// 纹理立方体-片元着色器let TEXTURE_FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform sampler2D u_Sampler; varying vec2 v_TexCoord; varying float v_NdotL; void main() vec4 color = texture2D(u_Sampler, v_TexCoord); gl_FragColor = vec4( color.rgb*v_NdotL, color.a ); `// 纯色立方体着色器 切换与attribute变量初始化function drawSolidCube(gl, program, o, x, angle, viewProjMatrix) gl.useProgram(program); initAttributeVariable(gl, program.a_Position, o.vertexBuffer); initAttributeVariable(gl, program.a_Normal, o.normalBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer); drawCube(gl, program, o, x, angle, viewProjMatrix);// 纹理立方体着色器 切换与attribute变量初始化function drawTexCube(gl,program,o,texture,x,angle,viewProjMatrix) gl.useProgram(program); initAttributeVariable(gl, program.a_Position, o.vertexBuffer); initAttributeVariable(gl, program.a_TexCoord, o.texCoordBuffer); initAttributeVariable(gl, program.a_Normal, o.normalBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); drawCube(gl, program, o, x, angle, viewProjMatrix);// 用来注入attribute buffer的通用函数function initAttributeVariable(gl, a_attribute, buffer) gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.vertexAttribPointer(a_attribute, buffer.num, buffer.type, false, 0, 0); gl.enableVertexAttribArray(a_attribute);// 初始化vertex bufferfunction initVertexBuffers(gl) let vertices = new Float32Array([ // Vertex coordinates 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0,-1.0, 1.0, 1.0,-1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0,-1.0, -1.0, 1.0,-1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0,-1.0, -1.0,-1.0,-1.0, -1.0,-1.0, 1.0, // v1-v6-v7-v2 left -1.0,-1.0,-1.0, 1.0,-1.0,-1.0, 1.0,-1.0, 1.0, -1.0,-1.0, 1.0, // v7-v4-v3-v2 down 1.0,-1.0,-1.0, -1.0,-1.0,-1.0, -1.0, 1.0,-1.0, 1.0, 1.0,-1.0 // v4-v7-v6-v5 back ]); let normals = new Float32Array([ // Normal 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, // v7-v4-v3-v2 down 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0 // v4-v7-v6-v5 back ]); let texCoords = new Float32Array([ // Texture coordinates 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v1-v2-v3 front 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // v0-v3-v4-v5 right 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // v0-v5-v6-v1 up 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v1-v6-v7-v2 left 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // v7-v4-v3-v2 down 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 // v4-v7-v6-v5 back ]); let indices = new Uint8Array([ // Indices of the vertices 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]); let o = new Object(); // 将顶点数据写入buffer o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, 3, gl.FLOAT); o.normalBuffer = initArrayBufferForLaterUse(gl, normals, 3, gl.FLOAT); o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, 2, gl.FLOAT); o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE); o.numIndices = indices.length; gl.bindBuffer(gl.ARRAY_BUFFER, null); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); return o;// 初始化texturefunction initTextures(gl, program) let texture = gl.createTexture(); let image = new Image(); image.onload = function () gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image Y coordinate gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); gl.useProgram(program); gl.uniform1i(program.u_Sampler, 0); gl.bindTexture(gl.TEXTURE_2D, null); ; image.src = ../img/sky.jpg; return texture;// 初始化ARRAY_BUFFER类型buffer内存function initArrayBufferForLaterUse(gl,data,num,type) let buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); buffer.num = num; buffer.type = type; return buffer;// 用于创建ELEMENT_ARRAY_BUFFER的通用函数function initElementArrayBufferForLaterUse(gl,data,type) let buffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); buffer.type = type; return buffer;// 用于进行变换的矩阵let g_modelMatrix = new Matrix4();let g_mvpMatrix = new Matrix4();let g_normalMatrix = new Matrix4();// 绘制立方体的通用函数function drawCube(gl,program,o,x,angle,viewProjMatrix) g_modelMatrix.setTranslate( x, 0, 0 ).rotate( 20, 1, 0, 0 ).rotate( angle, 0, 1, 0 ); // 计算normalMatrix g_normalMatrix.setInverseOf(g_modelMatrix); g_normalMatrix.transpose(); gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements); g_mvpMatrix.set(viewProjMatrix); g_mvpMatrix.multiply(g_modelMatrix); gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements); gl.drawElements(gl.TRIANGLES, o.numIndices, gl.UNSIGNED_BYTE,0);let ANGLE_STEP = 30;let last = Date.now();function animate(angle) let now = Date.now(); let ellapse = now - last; last = now; return ((angle + ANGLE_STEP * ellapse / 1000)) % 360;function main() let canvas = document.getElementById(webgl); let gl = getWebGLContext(canvas); // 创建着色器程序对象 let solidProgram = createProgram(gl, SOLID_VSHADER_SOURCE, SOLID_FSHADER_SOURCE); let texProgram = createProgram(gl, TEXTURE_VSHADER_SOURCE, TEXTURE_FSHADER_SOURCE); // 获取attribute和uniform对象 solidProgram.a_Position = gl.getAttribLocation(solidProgram, a_Position); solidProgram.a_Normal = gl.getAttribLocation(solidProgram, a_Normal); solidProgram.u_MvpMatrix = gl.getUniformLocation(solidProgram, u_MvpMatrix); solidProgram.u_NormalMatrix = gl.getUniformLocation(solidProgram, u_NormalMatrix); texProgram.a_Position = gl.getAttribLocation(texProgram, a_Position); texProgram.a_TexCoord = gl.getAttribLocation(texProgram, a_TexCoord); texProgram.a_Normal = gl.getAttribLocation(texProgram, a_Normal); texProgram.u_MvpMatrix = gl.getUniformLocation(texProgram, u_MvpMatrix); texProgram.u_NormalMatrix = gl.getUniformLocation(texProgram, u_NormalMatrix); texProgram.u_Sampler = gl.getUniformLocation(texProgram, u_Sampler); // 初始化attribute buffer let cube = initVertexBuffers(gl); let texture = initTextures(gl, texProgram); gl.enable(gl.DEPTH_TEST); gl.clearColor(0.0, 0.0, 0.0, 1.0); let viewProjMatrix = new Matrix4(); viewProjMatrix.setPerspective( 30.0, canvas.width / canvas.height, 1.0, 100.0 ).lookAt( 0.0, 0.0, 15.0, 0, 0, 0, 0, 1, 0 ); let currentAngle = 0.0; let tick = function () gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); currentAngle = animate(currentAngle); drawSolidCube(gl, solidProgram, cube, -2.0, currentAngle, viewProjMatrix); drawTexCube(gl, texProgram, cube, texture, 2.0, currentAngle, viewProjMatrix); window.requestAnimationFrame(tick); tick(); 切换着色器可以用来做什么？ 答： 在同一个场景中绘制出各种不同效果组合。案例待补充"},{"title":"阴影","path":"/wiki/WebGL/chapter_10_07.html","content":"阴影贴图 实现阴影的方法有很多，本节介绍的方法叫做 阴影贴图，阴影贴图（shadow map） 也称 深度贴图（depth map） 如何实现阴影阴影贴图的原理 使用两对着色器以实现阴影，设第一对着色器为S1，第二对着色器为S2，光源为O，物体上存在一点P1，P1在阴影上的位置时P2S1计算出OP1使用一张纹理图像将S1的计算结果传入S2中这张纹理图像就是 阴影贴图（shadow map） 阴影映射的实际步骤 即将视点移到光源位置处将每个像素最前面的z值写入到阴影贴图中如p1的z值将视点移回原来的位置计算出每个片元在光源坐标系下的坐标，与阴影贴图中记录的z值比较如p2的z值与p1的z值如果前者大于后者，就说明当前片元处在阴影之中，用较深颜色绘制p2.z p1.z ，因此p2处于阴影之中 ShadowShadow Code Shadow运行效果shadermain&&aniamtedrawbufferframebuffer// 阴影vertex shaderlet SHADOW_VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_MvpMatrix; void main() gl_Position = u_MvpMatrix * a_Position; `// 阴影fragment shaderlet SHADOW_FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif void main() // write the z-value in r gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0); `// vertex shaderlet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_MvpMatrix; uniform mat4 u_MvpMatrixFromLight; // 光源坐标系 varying vec4 v_PositionFromLight; // 光源坐标系下的物体坐标 varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; v_PositionFromLight = u_MvpMatrixFromLight * a_Position; v_Color = a_Color; `// fragment shaderlet FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform sampler2D u_ShadowMap; varying vec4 v_PositionFromLight; varying vec4 v_Color; void main() vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5; vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy); float depth = rgbaDepth.r; float visibility = (shadowCoord.z depth + 0.005) ? 0.7 : 1.0; gl_FragColor = vec4(v_Color.rgb * visibility, v_Color.a); `// 帧缓冲区渲染尺寸let OFFSCREEN_WIDTH = 2048 let OFFSCREEN_HEIGHT = 2048 // 光照点let LIGHT_X = 0let LIGHT_Y = 7let LIGHT_Z = 2function main() let canvas = document.getElementById(webgl) let gl = getWebGLContext(canvas) if (!gl) console.log(failed to get the rendering context for webgl) return; // initialize shaders for generating a shadow map let shadowProgram = createProgram(gl, SHADOW_VSHADER_SOURCE, SHADOW_FSHADER_SOURCE) shadowProgram.a_Position = gl.getAttribLocation(shadowProgram, a_Position) shadowProgram.u_MvpMatrix = gl.getUniformLocation(shadowProgram, u_MvpMatrix) if (shadowProgram.a_Position 0 || !shadowProgram.u_MvpMatrix) console.log(failed to get the storage location of attribute or uniform variable from shadowProgram) return // initialize shaders for regular drawing let normalProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE); normalProgram.a_Position = gl.getAttribLocation(normalProgram, a_Position) normalProgram.a_Color = gl.getAttribLocation(normalProgram, a_Color) normalProgram.u_MvpMatrix = gl.getUniformLocation(normalProgram, u_MvpMatrix) normalProgram.u_MvpMatrixFromLight = gl.getUniformLocation(normalProgram, u_MvpMatrixFromLight) normalProgram.u_ShadowMap = gl.getUniformLocation(normalProgram, u_ShadowMap) if (normalProgram.a_Position 0 || normalProgram.a_Color 0 || !normalProgram.u_MvpMatrix || !normalProgram.u_MvpMatrixFromLight || !normalProgram.u_ShadowMap ) console.log(failed to get the storage location of attribute or uniform varibale fron normalProgram) return // set the vertex information let triangle = initVertexBuffersForTriangle(gl) let plane = initVertexBuffersForPlane(gl) if (!triangle || !plane) console.log(failed to set the vertex information) return // initialize framebuffer object (FBO) let fbo = initFramebufferObject(gl) if (!fbo) console.log(failed to initialize frame buffer object) return gl.activeTexture(gl.TEXTURE0) // set a texture obejct to the texture unit gl.bindTexture(gl.TEXTURE_2D, fbo.texture) // set the clear color and enable the depth tes gl.clearColor(0, 0, 0, 1) gl.enable(gl.DEPTH_TEST) // prepare a view projection matrix for generating a shadow map let viewProjMatrixFromLight = new Matrix4() viewProjMatrixFromLight.setPerspective( 70.0, OFFSCREEN_WIDTH/OFFSCREEN_HEIGHT, 1.0, 100.0 ).lookAt( LIGHT_X, LIGHT_Y, LIGHT_Z, 0, 0, 0, 0, 1, 0 ) // prepare a view projection matrix for regular drawing let viewProjMatrix = new Matrix4() viewProjMatrix.setPerspective( 45, canvas.width/canvas.clientHeight, 1.0, 100.0 ).lookAt( 0.0, 7.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) let currentAngle = 0.0 // a model view projection matrix from light source for triangle let mvpMatrixFromLight_t = new Matrix4() // a model view projection matrix from light source for plant let mvpMatrixFromLight_p = new Matrix4() let tick = function () currentAngle = animate(currentAngle) /** 步骤1 使用阴影着色器计算出阴影贴图 **/ gl.bindFramebuffer(gl.FRAMEBUFFER, fbo) // change the drawing destination to FBO gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT) // set view port for FBO gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // clear FBO gl.useProgram(shadowProgram) // set shaders for generating a shadow map // draw the triangle and the plane for generating a shadow map drawTriangle(gl, shadowProgram, triangle, currentAngle, viewProjMatrixFromLight) mvpMatrixFromLight_t.set(g_mvpMatrix) drawPlane(gl, shadowProgram, plane, viewProjMatrixFromLight) mvpMatrixFromLight_p.set(g_mvpMatrix) /** 步骤2 使用绘图着色器按照阴影映射原理绘图 **/ gl.bindFramebuffer(gl.FRAMEBUFFER, null) gl.viewport(0, 0, canvas.width, canvas.height) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) gl.useProgram(normalProgram) gl.uniform1i(normalProgram.u_ShadowMap, 0) // Pass 0 because gl.TEXTURE0 is enabled gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight_t.elements) drawTriangle(gl, normalProgram, triangle, currentAngle, viewProjMatrix) gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight_p.elements) drawPlane(gl, normalProgram, plane, viewProjMatrix) window.requestAnimationFrame(tick) tick()let ANGLE_STEP = 40let last = Date.now()function animate(angle) let now = Date.now() let elapsed = now - last last = now return (angle + elapsed * ANGLE_STEP / 1000) % 360let g_modelMatrix = new Matrix4()let g_mvpMatrix = new Matrix4()function drawTriangle(gl, program, triangle, angle, viewProjMatrix) // 绘制旋转三角形 g_modelMatrix.setRotate( angle, 0, 1, 0 ) draw(gl, program, triangle, viewProjMatrix)function drawPlane(gl, program, plane, viewProjMatrix) // 绘制投影平面 g_modelMatrix.setRotate( -45, 0, 1, 1 ) draw(gl, program, plane, viewProjMatrix)// 绘制功能函数function draw(gl, program, o, viewProjMatrix) initAttributeVariable(gl, program.a_Position, o.vertexBuffer) if (program.a_Color != undefined) initAttributeVariable(gl, program.a_Color, o.colorBuffer) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer) g_mvpMatrix.set( viewProjMatrix ).multiply( g_modelMatrix ) gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements) gl.drawElements(gl.TRIANGLES, o.numIndices, gl.UNSIGNED_BYTE, 0)// 写入attribute数据function initAttributeVariable(gl, a_attribute, buffer) gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.vertexAttribPointer(a_attribute, buffer.num, buffer.type, false, 0, 0) gl.enableVertexAttribArray(a_attribute)// 填入plane绘制所需缓冲区数据function initVertexBuffersForPlane(gl) let vertices = new Float32Array([ 3.0, -1.7, 2.5, -3.0, -1.7, 2.5, -3.0, -1.7, -2.5, 3.0, -1.7, -2.5 ]) let colors = new Float32Array([ 1.0, 1.0, 0.7, 1.0, 0.7, 1.0, 0.7, 1.0, 1.0, 0.7, 0.7, 0.7 ]) let indices = new Uint8Array([ 0, 1, 2, 0, 2, 3 ]) let o = new Object() o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, 3, gl.FLOAT) o.colorBuffer = initArrayBufferForLaterUse(gl, colors, 3, gl.FLOAT) o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE) if (!o.vertexBuffer || !o.colorBuffer || !o.indexBuffer) return null o.numIndices = indices.length gl.bindBuffer(gl.ARRAY_BUFFER, null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null) return o// 填入triangle绘制所需缓冲区数据function initVertexBuffersForTriangle(gl) let vertices = new Float32Array([ -0.8, 3.5, 0.0, 0.8, 3.5, 0.0, 0.0, 3.5, 1.8 ]) let colors = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 ]) let indices = new Uint8Array([ 0, 1, 2 ]) let o = new Object() o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, 3, gl.FLOAT) o.colorBuffer = initArrayBufferForLaterUse(gl, colors, 3, gl.FLOAT) o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE) if (!o.vertexBuffer || !o.colorBuffer || !o.indexBuffer) return null o.numIndices = indices.length gl.bindBuffer(gl.ARRAY_BUFFER, null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null) return ofunction initArrayBufferForLaterUse(gl, data, num, type) let buffer = gl.createBuffer() if (!buffer) console.log(failed to create the buffer object) return null gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW) buffer.num = num buffer.type = type return bufferfunction initElementArrayBufferForLaterUse(gl, data, type) let buffer = gl.createBuffer() if (!buffer) console.log(failed to create the buffer object) return null gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer) gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW) buffer.type = type return buffer// 创建帧缓冲区对象function initFramebufferObject(gl) let framebuffer, texture, depthBuffer // error handling function let error = function () if (framebuffer) gl.deleteFramebuffer(framebuffer) if (texture) gl.deleteTexture(texture) if (depthBuffer) gl.deleteRenderbuffer(depthBuffer) return null // 创建帧缓冲区对象 framebuffer = gl.createFramebuffer() if (!framebuffer) console.log(failed to create frame buffer object) return error() // 创建纹理缓冲区对象并设置尺寸 texture = gl.createTexture() if (!texture) console.log(failed to create texture object) return error() gl.bindTexture(gl.TEXTURE_2D, texture) gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null ) gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR ) // 创建渲染缓冲区对象并设置尺寸 depthBuffer = gl.createRenderbuffer() if (!depthBuffer) console.log(failed to create depthbuffer object) return error() gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer) gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT ) // 将纹理缓冲区和渲染缓冲区与渲染缓冲区联系起来 gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer) gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0 ) gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer ) // 检查帧缓冲区状态 let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER) if (gl.FRAMEBUFFER_COMPLETE !== e) console.log(Frame buffer object is incomplete: + e.toString()) return error() // 保留所需的数据 framebuffer.texture = texture // 解绑定 gl.bindFramebuffer(gl.FRAMEBUFFER, null) gl.bindTexture(gl.TEXTURE_2D, null) gl.bindRenderbuffer(gl.RENDERBUFFER, null) return framebuffer 步骤分解步骤1：获取阴影贴图 绘制目标： 帧缓冲区对象 绘制视点： 光源 绘制着色器： 顶点着色器：负责将顶点坐标切换到光源坐标系下 片元着色器：将片元的z值写入纹理贴图中 如何使用每个片元的z值制作一张阴影贴图？ 光源视角下计算阴影贴图gl_FragColor = vec4(gl_FragCoord.z. 0.0, 0.0, 0.0);实际上存入阴影贴图的值也就是每个片元的 gl_FragCoord.z 的值gl_FragCoordgl_FragCoord 是 vec4 类型的 gl_FragCoord.xy：片元在屏幕上的坐标 gl_FragCoord.z： 片元的深度值 gl_FragCoord是如何被计算出来的？答： gl_FragCoord是由 gl_Position归一化 得到的。从 [-1.0, 1.0] 归一化到 [0.0, 1.0] gl_FragCoord.z 0.0 表示片元在 近裁剪面 上 gl_FragCoord.z 1.0 表示片元在 远裁剪面 上 归一化公式 gl_FragCoord.xyz = (gl_Position.xyz/gl_Position.w)/2.0+0.5 步骤2：使用阴影贴图 绘制目标： 颜色缓冲区 绘制视点： 原视点 计算出来的阴影贴图要怎么使用呢？ 每一个片元都有两个值：光照坐标系下的z值（v_PositionFromLight.z）该片元对应阴影贴图中存储的z值(shadowMap)需要将这两个值拿来比较，那么问题就来了：问题1：怎么获取片元在光照坐标系下的z值呢？答： 只需要 a_Position 顶点坐标 u_MvpMatrixFromLight 光源模型视图投影矩阵 计算光源MVP矩阵下的顶点坐标即可： v_PositionFromLight = u_MvpMatrixFromLight * a_Position;问题2：怎么获取片元对应shadowMap中存储的对应值呢？需要两步： 根据上一步计算出来的v_PositionFromLight转化为纹素坐标 根据纹素坐标从阴影贴图中抽取对应纹素 步骤1：将光照坐标系下的顶点坐标转化为纹素坐标 同样需要对顶点坐标进行 纹素归一化处理，这是由于顶点坐标和纹素坐标的区间不同：顶点坐标：[-1.0, 1.0]纹素坐标： [0.0, 1.0]归一化处理与gl_Position到gl_FragCoord归一化的过程相似s = (v_PositionFromLight.x/v_PositionFromLight.w)/2.0+0.5;t = (v_PositionFromLight.y/v_PositionFromLight.w)/2.0+0.5;将归一化得到的纹素坐标放到shadowCoord中去vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0+0.5;shadowCoord包含了很多信息：shadowCoord.xy： 该片元对应的shadowMap坐标shadowCoord.z：当前片元在光源坐标系中的归一化z值 步骤2：抽取阴影贴图中的纹素 既然计算出shadowCoord，剩下的工作就比较简单了，可以通过 shadowCoord.xy 从 shadowMap 中抽取纹素，这里别忘了 内插过程depth里最终放着阴影贴图中对应的z值vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);float depth = rgbaDepth.r;从 问题2 中，我们获得了用于比较的两个值：shadowCoord.z 光照坐标系下被归一化的片元的z值depth 同一片元对应的阴影贴图中的值接下来只需要将这两个值拿来比较就可以了：float visibility = (shadowCoord.z depth +0.005)?0.7:1.0;gl_FragColor = vec4(v_Color.rgb * visibility, v_Color.a); 马赫带(Mach band) 为什么在比较z值和阴影贴图值的时候要多给阴影贴图加上 0.005?如果把这0.005拿掉会怎么样？float visibility = (shadowCoord.z depth)?0.7:1.0;马赫带为什么会出现马赫带？答： 由于用于比较的两个值存在 精度偏差 shadowCoord.z 类型：RGBA分量 位数：8位 精度：1256 depth 类型：float 位数：16位 精度：165536 如何消除马赫带答： 给较大精度的值加上一个偏移量。 注意： 偏移量应当略大于精度 如：N M ?N: 8位 精度1256M：16位 精度165536因为M精度值较大，所以应该加上一个略大于1256的值（0.005）∴ N M + 0.005 阴影绘制步骤 Step1 program准备绘制的着色器程序Step2 buffer准备绘制图形的顶点数据Step3 frameBuffer创建帧缓冲区对象Step4 bindTexture将0号纹理绑定到帧缓冲区的纹理对象上Step5 count shadowMap切换光源视角，计算出阴影贴图Step6 draw by shadowMap切换屏幕视角，使用阴影贴图开始绘图 提高精度Shadow.js存在哪些问题？ Shadow.js存在精度缺陷问题： 近距离光源let LIGHT_X = 0let LIGHT_Y= 7let LIGHT_Z= 2近距离光源 远距离光源let LIGHT_X = 0let LIGHT_Y= 40let LIGHT_Z= 2远距离光源 存在精度缺陷的原因是什么？ 随着光源与照射物间距的变大，gl_FragCoord.z的值也会随之变大，最终8位的R分量无法存储下gl_FragCoord.z，导致精度缺陷 Shadow_highp 光源位置：(0, 40, 4) 8位精度Shadow.js绘制效果 提高精度Shadow_highp.js绘制效果 阴影片元着色器绘制片元着色器let SHADOW_FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif void main() const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0); const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0); vec4 rgbaDepth = fract(gl_FragCoord.z * bitShift); rgbaDepth -= rgbaDepth.gbaa * bitMask; gl_FragColor = rgbaDepth; `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; varying vec4 v_PositionFromLight; uniform sampler2D u_ShadowMap; float unpackDepth(const in vec4 rgbaDepth) const vec4 bitShift = vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0)); float depth = dot(rgbaDepth, bitShift); return depth; void main() vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5; vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy); float depth = unpackDepth(rgbaDepth); float visibility = (shadowCoord.z depth + 0.0015)?0.7:1.0; gl_FragColor = vec4(v_Color.rgb * visibility, v_Color.a); `; 提高精度后ShadowMap里都存的什么？ 假设有这样一个片元坐标z值：gl_FragCoord.z 2.135793057816414332378301如果只使用 gl_FragColor.r 来存储它的话实际存储的结果是 gl_FragCoord.z * 2^(-8) * 2^(-8) 2.1328125既然gl_FragColor.r放不下精度这么大的值，那就把gl_FragColor的 rgba 四个8位值全用上R: （2^-8, 2^0)G: （2^-16, 2^-8)B: （2^-24, 2^-16)A: （0, 2^-24)一个位数提取的问题 如何在不破坏一个二进制数的其他位的情况下，将其中需要的位数提取出来？如：有一个二进制数 0b0001_0001_0000_1000我要如何将它的高8位和低8位分别提取出来？ fract函数（模糊）作用： 舍弃参数的整数部分，返回小数部分。 消除马赫带偏移量float visibility = ( shadowCoord.z depth + 0.0015 )?0.7:1.0; 之所以选0.0015作为偏移量是因为： z精度已经提高到了float在mediump精度下，精度为2^-102^-10 0.000976563"},{"title":"三维模型","path":"/wiki/WebGL/chapter_10_08.html","content":"加载三维模型加载三维模型一般流程 OperateDataTypeStep1读入顶点数据verticesFloat32ArrayStep2读入颜色数据colorsFloat32ArrayStep3读入法线数据normalsFloat32ArrayStep4读入顶点索引数据indicesUnit16ArrayUnit8ArrayStep5 数据写入缓冲区Step6 gl.drawElements() OBJ文件格式OBJ文件wiki介绍https://en.wikipedia.org/wiki/Wavefront_.obj_file OBJ文件格式简介 一个简单的绘制了立方体的obj文件cube.obj绘制的立方体# Blender v2.60 (sub 0) OBJ File: # www.blender.orgmtllib cube.mtlo Cubev 1.000000 -1.000000 -1.000000v 1.000000 -1.000000 1.000000v -1.000000 -1.000000 1.000000v -1.000000 -1.000000 -1.000000v 1.000000 1.000000 -1.000000v 1.000000 1.000000 1.000001v -1.000000 1.000000 1.000000v -1.000000 1.000000 -1.000000usemtl Materialf 1 2 3 4f 5 8 7 6f 2 6 7 3f 3 7 8 4f 5 1 4 8usemtl Material.001f 1 5 6 2注释引用命名顶点坐标材质表面# 开头行表示注释# Blender v2.60 (sub 0) OBJ File: # www.blender.orgmtllib 外部材质文件名mtllib cube.mtl # 引用一个外部材质文件模型名称v x y z [w] # w值可选，没有默认为1.0v 1.000000 -1.000000 -1.000000v 1.000000 -1.000000 1.000000v -1.000000 -1.000000 1.000000v -1.000000 -1.000000 -1.000000v 1.000000 1.000000 -1.000000v 1.000000 1.000000 1.000001v -1.000000 1.000000 1.000000v -1.000000 1.000000 -1.000000usemtl 材质名usemtl Materialusemtl Material.001表面是由顶点、纹理坐标和法线的 索引序列 定义的注意： 索引值从1开始f v1 v2 v3 v4usemtl Materialf 1 2 3 4f 5 8 7 6f 2 6 7 3f 3 7 8 4f 5 1 4 8usemtl Material.001f 1 5 6 2包含了法线的表面的定义稍有不同即 顶点索引法线向量索引 的格式法线向量索引也是从1开始f v1//vn1 v2//vn2 v3//vn3 MTL文件格式# Blender MTL File: # Material Count: 2newmtl MaterialKa 0.000000 0.000000 0.000000Kd 1.000000 0.000000 0.000000Ks 0.000000 0.000000 0.000000Ns 96.078431Ni 1.000000d 1.000000illum 0newmtl Material.001Ka 0.000000 0.000000 0.000000Kd 1.000000 0.450000 0.000000Ks 0.000000 0.000000 0.000000Ns 96.078431Ni 1.000000d 1.000000illum 0新材质材质参数newmtl 材质名表示定义一个新材质即obj文件引用的材质名usemtl 材质名newmtl MaterialKa # 环境色Kd # 漫射色Ks # 高光色Ns # 高光色权重Ni # 表面光学密度d # 透明度illum # 光照模型Ka|Kd|Ks都使用了RGB格式定义，每个分量取值区间为 [0.0, 1.0]Ka 0.000000 0.000000 0.000000Kd 1.000000 0.000000 0.000000Ks 0.000000 0.000000 0.000000Ns 96.078431Ni 1.000000d 1.000000illum 0 OBJViewer.js简单步骤 Step1准备一个空缓冲区Step2读取OBJ文件中的内容Step3对读取的内容进行解析Step4将解析出的数据写入缓冲区Step5进行绘制 自定义OBJ文件解析类OBJ文件解析的内部结构 Souce Code //------------------------------------------------------------------------------// OBJParser//------------------------------------------------------------------------------// OBJDoc object// Constructorvar OBJDoc = function(fileName) this.fileName = fileName; this.mtls = new Array(0); // Initialize the property for MTL this.objects = new Array(0); // Initialize the property for Object this.vertices = new Array(0); // Initialize the property for Vertex this.normals = new Array(0); // Initialize the property for Normal// Parsing the OBJ fileOBJDoc.prototype.parse = function(fileString, scale, reverse) var lines = fileString.grid( ); // Break up into lines and store them as array lines.push(null); // Append null var index = 0; // Initialize index of line var currentObject = null; var currentMaterialName = ; // Parse line by line var line; // A string in the line to be parsed var sp = new StringParser(); // Create StringParser while ((line = lines[index++]) != null) sp.init(line); // init StringParser var command = sp.getWord(); // Get command if(command == null) continue; // check null command switch(command) case #: continue; // Skip comments case mtllib: // Read Material chunk var path = this.parseMtllib(sp, this.fileName); var mtl = new MTLDoc(); // Create MTL instance this.mtls.push(mtl); var request = new XMLHttpRequest(); request.onreadystatechange = function() if (request.readyState == 4) if (request.status != 404) onReadMTLFile(request.responseText, mtl); else mtl.complete = true; request.open(GET, path, true); // Create a request to acquire the file request.send(); // Send the request continue; // Go to the next line case o: case g: // Read Object name var object = this.parseObjectName(sp); this.objects.push(object); currentObject = object; continue; // Go to the next line case v: // Read vertex var vertex = this.parseVertex(sp, scale); this.vertices.push(vertex); continue; // Go to the next line case vn: // Read normal var normal = this.parseNormal(sp); this.normals.push(normal); continue; // Go to the next line case usemtl: // Read Material name currentMaterialName = this.parseUsemtl(sp); continue; // Go to the next line case f: // Read face var face = this.parseFace(sp, currentMaterialName, this.vertices, reverse); currentObject.addFace(face); continue; // Go to the next line return true;OBJDoc.prototype.parseMtllib = function(sp, fileName) // Get directory path var i = fileName.lastIndexOf(/); var dirPath = ; if(i 0) dirPath = fileName.substr(0, i+1); return dirPath + sp.getWord(); // Get pathOBJDoc.prototype.parseObjectName = function(sp) var name = sp.getWord(); return (new OBJObject(name));OBJDoc.prototype.parseVertex = function(sp, scale) var x = sp.getFloat() * scale; var y = sp.getFloat() * scale; var z = sp.getFloat() * scale; return (new Vertex(x, y, z));OBJDoc.prototype.parseNormal = function(sp) var x = sp.getFloat(); var y = sp.getFloat(); var z = sp.getFloat(); return (new Normal(x, y, z));OBJDoc.prototype.parseUsemtl = function(sp) return sp.getWord();OBJDoc.prototype.parseFace = function(sp, materialName, vertices, reverse) var face = new Face(materialName); // get indices for(;;) var word = sp.getWord(); if(word == null) break; var subWords = word.grid(/); if(subWords.length = 1) var vi = parseInt(subWords[0]) - 1; face.vIndices.push(vi); if(subWords.length = 3) var ni = parseInt(subWords[2]) - 1; face.nIndices.push(ni); else face.nIndices.push(-1); // calc normal var v0 = [ vertices[face.vIndices[0]].x, vertices[face.vIndices[0]].y, vertices[face.vIndices[0]].z]; var v1 = [ vertices[face.vIndices[1]].x, vertices[face.vIndices[1]].y, vertices[face.vIndices[1]].z]; var v2 = [ vertices[face.vIndices[2]].x, vertices[face.vIndices[2]].y, vertices[face.vIndices[2]].z]; // 面の法線を計算してnormalに設定 var normal = calcNormal(v0, v1, v2); // 法線が正しく求められたか調べる if (normal == null) if (face.vIndices.length = 4) // 面が四角形なら別の3点の組み合わせで法線計算 var v3 = [ vertices[face.vIndices[3]].x, vertices[face.vIndices[3]].y, vertices[face.vIndices[3]].z]; normal = calcNormal(v1, v2, v3); if(normal == null) // 法線が求められなかったのでY軸方向の法線とする normal = [0.0, 1.0, 0.0]; if(reverse) normal[0] = -normal[0]; normal[1] = -normal[1]; normal[2] = -normal[2]; face.normal = new Normal(normal[0], normal[1], normal[2]); // Devide to triangles if face contains over 3 points. if(face.vIndices.length 3) var n = face.vIndices.length - 2; var newVIndices = new Array(n * 3); var newNIndices = new Array(n * 3); for(var i=0; in; i++) newVIndices[i * 3 + 0] = face.vIndices[0]; newVIndices[i * 3 + 1] = face.vIndices[i + 1]; newVIndices[i * 3 + 2] = face.vIndices[i + 2]; newNIndices[i * 3 + 0] = face.nIndices[0]; newNIndices[i * 3 + 1] = face.nIndices[i + 1]; newNIndices[i * 3 + 2] = face.nIndices[i + 2]; face.vIndices = newVIndices; face.nIndices = newNIndices; face.numIndices = face.vIndices.length; return face;// Analyze the material filefunction onReadMTLFile(fileString, mtl) var lines = fileString.grid( ); // Break up into lines and store them as array lines.push(null); // Append null var index = 0; // Initialize index of line // Parse line by line var line; // A string in the line to be parsed var name = ; // Material name var sp = new StringParser(); // Create StringParser while ((line = lines[index++]) != null) sp.init(line); // init StringParser var command = sp.getWord(); // Get command if(command == null) continue; // check null command switch(command) case #: continue; // Skip comments case newmtl: // Read Material chunk name = mtl.parseNewmtl(sp); // Get name continue; // Go to the next line case Kd: // Read normal if(name == ) continue; // Go to the next line because of Error var material = mtl.parseRGB(sp, name); mtl.materials.push(material); name = ; continue; // Go to the next line mtl.complete = true;// Check MaterialsOBJDoc.prototype.isMTLComplete = function() if(this.mtls.length == 0) return true; for(var i = 0; i this.mtls.length; i++) if(!this.mtls[i].complete) return false; return true;// Find color by material nameOBJDoc.prototype.findColor = function(name) for(var i = 0; i this.mtls.length; i++) for(var j = 0; j this.mtls[i].materials.length; j++) if(this.mtls[i].materials[j].name == name) return(this.mtls[i].materials[j].color) return(new Color(0.8, 0.8, 0.8, 1));//------------------------------------------------------------------------------// Retrieve the information for drawing 3D modelOBJDoc.prototype.getDrawingInfo = function() // Create an arrays for vertex coordinates, normals, colors, and indices var numIndices = 0; for(var i = 0; i this.objects.length; i++) numIndices += this.objects[i].numIndices; var numVertices = numIndices; var vertices = new Float32Array(numVertices * 3); var normals = new Float32Array(numVertices * 3); var colors = new Float32Array(numVertices * 4); var indices = new Uint16Array(numIndices); // Set vertex, normal and color var index_indices = 0; for(var i = 0; i this.objects.length; i++) var object = this.objects[i]; for(var j = 0; j object.faces.length; j++) var face = object.faces[j]; var color = this.findColor(face.materialName); var faceNormal = face.normal; for(var k = 0; k face.vIndices.length; k++) // Set index indices[index_indices] = index_indices; // Copy vertex var vIdx = face.vIndices[k]; var vertex = this.vertices[vIdx]; vertices[index_indices * 3 + 0] = vertex.x; vertices[index_indices * 3 + 1] = vertex.y; vertices[index_indices * 3 + 2] = vertex.z; // Copy color colors[index_indices * 4 + 0] = color.r; colors[index_indices * 4 + 1] = color.g; colors[index_indices * 4 + 2] = color.b; colors[index_indices * 4 + 3] = color.a; // Copy normal var nIdx = face.nIndices[k]; if(nIdx = 0) var normal = this.normals[nIdx]; normals[index_indices * 3 + 0] = normal.x; normals[index_indices * 3 + 1] = normal.y; normals[index_indices * 3 + 2] = normal.z; else normals[index_indices * 3 + 0] = faceNormal.x; normals[index_indices * 3 + 1] = faceNormal.y; normals[index_indices * 3 + 2] = faceNormal.z; index_indices ++; return new DrawingInfo(vertices, normals, colors, indices);//------------------------------------------------------------------------------// MTLDoc Object//------------------------------------------------------------------------------var MTLDoc = function() this.complete = false; // MTL is configured correctly this.materials = new Array(0);MTLDoc.prototype.parseNewmtl = function(sp) return sp.getWord(); // Get nameMTLDoc.prototype.parseRGB = function(sp, name) var r = sp.getFloat(); var g = sp.getFloat(); var b = sp.getFloat(); return (new Material(name, r, g, b, 1));//------------------------------------------------------------------------------// Material Object//------------------------------------------------------------------------------var Material = function(name, r, g, b, a) this.name = name; this.color = new Color(r, g, b, a);//------------------------------------------------------------------------------// Vertex Object//------------------------------------------------------------------------------var Vertex = function(x, y, z) this.x = x; this.y = y; this.z = z;//------------------------------------------------------------------------------// Normal Object//------------------------------------------------------------------------------var Normal = function(x, y, z) this.x = x; this.y = y; this.z = z;//------------------------------------------------------------------------------// Color Object//------------------------------------------------------------------------------var Color = function(r, g, b, a) this.r = r; this.g = g; this.b = b; this.a = a;//------------------------------------------------------------------------------// OBJObject Object//------------------------------------------------------------------------------var OBJObject = function(name) this.name = name; this.faces = new Array(0); this.numIndices = 0;OBJObject.prototype.addFace = function(face) this.faces.push(face); this.numIndices += face.numIndices;//------------------------------------------------------------------------------// Face Object//------------------------------------------------------------------------------var Face = function(materialName) this.materialName = materialName; if(materialName == null) this.materialName = ; this.vIndices = new Array(0); this.nIndices = new Array(0);//------------------------------------------------------------------------------// DrawInfo Object//------------------------------------------------------------------------------var DrawingInfo = function(vertices, normals, colors, indices) this.vertices = vertices; this.normals = normals; this.colors = colors; this.indices = indices;//------------------------------------------------------------------------------// Constructorvar StringParser = function(str) this.str; // Store the string specified by the argument this.index; // Position in the string to be processed this.init(str);// Initialize StringParser objectStringParser.prototype.init = function(str) this.str = str; this.index = 0;// Skip delimitersStringParser.prototype.skipDelimiters = function() for(var i = this.index, len = this.str.length; i len; i++) var c = this.str.charAt(i); // Skip TAB, Space, (, ) if (c == \\t|| c == || c == ( || c == ) || c == ) continue; break; this.index = i;// Skip to the next wordStringParser.prototype.skipToNextWord = function() this.skipDelimiters(); var n = getWordLength(this.str, this.index); this.index += (n + 1);// Get wordStringParser.prototype.getWord = function() this.skipDelimiters(); var n = getWordLength(this.str, this.index); if (n == 0) return null; var word = this.str.substr(this.index, n); this.index += (n + 1); return word;// Get integerStringParser.prototype.getInt = function() return parseInt(this.getWord());// Get floating numberStringParser.prototype.getFloat = function() return parseFloat(this.getWord());// Get the length of wordfunction getWordLength(str, start) var n = 0; for(var i = start, len = str.length; i len; i++) var c = str.charAt(i); if (c == \\t|| c == || c == ( || c == ) || c == ) break; return i - start;//------------------------------------------------------------------------------// Common function//------------------------------------------------------------------------------function calcNormal(p0, p1, p2) // v0: a vector from p1 to p0, v1; a vector from p1 to p2 var v0 = new Float32Array(3); var v1 = new Float32Array(3); for (var i = 0; i 3; i++) v0[i] = p0[i] - p1[i]; v1[i] = p2[i] - p1[i]; // The cross product of v0 and v1 var c = new Float32Array(3); c[0] = v0[1] * v1[2] - v0[2] * v1[1]; c[1] = v0[2] * v1[0] - v0[0] * v1[2]; c[2] = v0[0] * v1[1] - v0[1] * v1[0]; // Normalize the result var v = new Vector3(c); v.normalize(); return v.elements; 读入部分程序OBJViewer Code OBJViewer运行结果ShadermainreadonReadonReadCompletedrawbufferanimtelet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; attribute vec4 a_Normal; uniform mat4 u_MvpMatrix; uniform mat4 u_NormalMatrix; varying vec4 v_Color; void main() gl_Position = u_MvpMatrix * a_Position; vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal)); vec3 lightDirection = vec3(-0.35, 0.35, 0.87); float nDotL = max(dot(normal, lightDirection), 0.0); v_Color = vec4(nDotL*a_Color.rgb, a_Color.a); `;let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `function main() let canvas = document.getElementById(webgl) let gl = getWebGLContext(canvas) if (!gl) console.log(failed to get webgl context) return if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders) return gl.clearColor(0.3, 0.3, 0.4, 1) gl.enable(gl.DEPTH_TEST) let program = gl.program program.a_Position = gl.getAttribLocation(program,a_Position) program.a_Color = gl.getAttribLocation(program,a_Color) program.a_Normal = gl.getAttribLocation(program, a_Normal) program.u_MvpMatrix = gl.getUniformLocation(program,u_MvpMatrix) program.u_NormalMatrix = gl.getUniformLocation(program,u_NormalMatrix) if (program.a_Postion 0 || program.a_Color 0 || program.a_Normal 0 || !program.u_MvpMatrix || !program.u_NormalMatrix ) console.log(failed to get attribute or uniform location) return let model = initVertexBuffers(gl, program) if (!model) console.log(failed to init vertex buffers) return let viewProjMatrix = new Matrix4() viewProjMatrix.setPerspective( 30.0, canvas.width/canvas.height,1.0,5000.0 ).lookAt( 0.0, 500.0, 200.0, 0, 0, 0, 0, 1, 0 ) readOBJFile(../img/cube.obj, gl, model, 60, true) let currentAngle = 0.0 let tick = function () currentAngle = animate(currentAngle) draw(gl, program, currentAngle, viewProjMatrix, model) window.requestAnimationFrame(tick) tick()发起读取文件请求let g_objDoc = nulllet g_draingInfo = nullfunction readOBJFile(fileName, gl, model, scale, reverse) let request = new XMLHttpRequest() request.onreadystatechange = function () if (request.readyState === 4 request.status !== 404) onReadOBJFile(request.responseText, fileName, gl, model, scale, reverse) request.open(GET, fileName, true) request.send()文件读取结束function onReadOBJFile(fileString, fileName, gl, o, scale, reverse) let objDoc = new OBJDoc(fileName) let result = objDoc.parse(fileString, scale, reverse) if (!result) g_objDoc = null g_drawingInfo = null console.log(OBJ file parsing error) return g_objDoc = objDoc对读取内容解析并写入缓冲区function onReadComplete(gl, model, objDoc) let drawingInfo = objDoc.getDrawingInfo() gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer) gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.vertices, gl.STATIC_DRAW) gl.bindBuffer(gl.ARRAY_BUFFER, model.colorBuffer) gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.colors, gl.STATIC_DRAW) gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer) gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.normals, gl.STATIC_DRAW) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBUffer) gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, drawingInfo.indices, gl.STATIC_DRAW) return drawingInfolet g_modelMatrix = new Matrix4()let g_mvpMatrix = new Matrix4()let g_normalMatrix = new Matrix4()function draw(gl, program, angle, vpMatrix, model) if (g_objDoc != null g_objDoc.isMTLComplete()) g_drawingInfo = onReadComplete(gl, model, g_objDoc) g_objDoc = null if (!g_drawingInfo) return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) g_modelMatrix.setRotate(angle, 1, 1, 1) g_normalMatrix.setInverseOf(g_modelMatrix) g_normalMatrix.transpose() gl.uniformMatrix4fv(program.u_NormalMatrix,false,g_normalMatrix.elements) g_mvpMatrix.set(vpMatrix).multiply(g_modelMatrix) gl.uniformMatrix4fv(program.u_MvpMatrix,false,g_mvpMatrix.elements) gl.drawElements(gl.TRIANGLES, g_drawingInfo.indices.length, gl.UNSIGNED_SHORT, 0)function initVertexBuffers(gl, program) let o = new Object() o.vertexBuffer = createEmptyArrayBuffer(gl, program.a_Position, 3, gl.FLOAT) o.colorBuffer = createEmptyArrayBuffer(gl, program.a_Color, 4, gl.FLOAT) o.normalBuffer = createEmptyArrayBuffer(gl, program.a_Normal, 3, gl.FLOAT) o.indexBUffer = gl.createBuffer() if (!o.vertexBuffer || !o.colorBuffer || !o.normalBuffer || !o.indexBUffer ) return null gl.bindBuffer(gl.ARRAY_BUFFER, null) return ofunction createEmptyArrayBuffer(gl,a_attribute,num,type) let buffer = gl.createBuffer() if (!buffer) console.log(failed to create buffer) return null gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0) gl.enableVertexAttribArray(a_attribute) return buffer var ANGLE_STEP = 30; // The increments of rotation angle (degrees)var last = Date.now(); // Last time that this function was calledfunction animate(angle) var now = Date.now(); // Calculate the elapsed time var elapsed = now - last; last = now; // Update the current rotation angle (adjusted by the elapsed time) var newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0; return newAngle % 360;"},{"title":"实时渲染","path":"/wiki/WebGL/chapter_10_06.html","content":"本篇博客引用的项目源网址http://www.artvily.com/ 渲染到纹理所谓渲染到纹理 就是将 渲染结果 作为纹理贴到另一个三维物体上去，实际上就是 动态生成图像。 应用场景动态模糊景深效果 帧缓冲区对象和渲染缓冲区对象还记得WebGL的绘制结果存储在哪个缓冲区中吗？ 答： 默认情况下在 颜色缓冲区 中绘图 开启DEPTH_TEST时，还会用到 深度缓冲区 总之，绘制结果存储在 颜色缓冲区 中 帧缓冲区对象帧缓冲区对象（framebuffer object） 可以用来代替 颜色缓冲区 或 深度缓冲区 为什么在帧缓冲区中绘制的过程又称为离屏绘制（offscreen drawing）答： 因为绘制在帧缓冲区的对象不会直接显示在画布上 帧缓冲区的内容一般会做如下处理： 进行一些处理再显示 直接用其中的内容作为 纹理图像 帧缓冲区对象的结构 绘制操作不是直接发生在 帧缓冲区 中的，而是发生在帧缓冲区 所关联的对象（attachment） 上。 帧缓冲区的3个关联对象颜色关联对象 color attachment 代替颜色缓冲区深度关联对象 depth attachment 代替深度缓冲区模板关联对象 stencil attachment 代替模板缓冲区 渲染缓冲区对象渲染缓冲区对象（renderbuffer object） 帧缓冲区的每一个关联对象可以有两种类型：纹理对象存储了纹理图像渲染缓冲区对象 表示一种 更加通用 的绘图区域，可以向其中写入多种类型的数据 如何实现渲染到纹理实现步骤实现目的： 把WebGL渲染出的图像作为纹理使用实现方式： 将纹理对象作为颜色关联对象关联到 帧缓冲区对象上 纹理对象 ← 颜色关联对象 将渲染缓冲区对象作为深度关联对象关联到 帧缓冲区对象上 渲染缓冲区对象 ← 深度关联对象 小比喻：雪媚娘 绘图就像烹饪一样，对应的对象就像是 食材 与 工序 一样。WebGL的缓冲区对应烹饪中的几个要素一样： 颜色缓冲区：食材 深度缓冲区：层次 但是只使用颜色缓冲区和深度缓冲区就好像做一道工序简单的菜，食材 新鲜，层次 直观，就比如要做西红柿炒鸡蛋，食材（颜色缓冲区）有鸡蛋、番茄，工序（深度缓冲区）就是先放鸡蛋再放番茄。 但如果想要做 雪媚娘 这样工序比较繁琐的甜点，你需要考虑 皮料（糯米粉、凉白开），并且皮料的工序已经比较复杂，所以我们可以将准备皮料的工序单独取出来，和其他工序区别开来，这就相当于帧缓冲区的 离屏绘制， 那么上面使用帧缓冲区对象渲染到纹理的目的和方式也可以对应如下的描述：实现目的： 自制雪媚娘实现方式： 将食谱（帧缓冲区对象）中的食材(颜色关联对象)指向糯米皮（纹理对象）至于糯米皮怎么制作的，又是单独的一道工序了（即纹理绘制） 创建步骤 step 1创建 帧缓冲区对象gl.createFramebuffer()step 2创建 纹理对象 并设置其尺寸和参数gl.createTexture()gl.bindTexture()gl.texImage2d()gl.Parameteri()step 3创建 渲染缓冲区对象gl.createRenderbuffer()step 4绑定渲染缓冲区对象 并设置尺寸gl.bindRenderbuffer()gl.renderbufferStorage()step 5分配 纹理对象 到帧缓冲区的 颜色关联对象gl.framebufferRenderbuffer()step 6分配 渲染缓冲区对象 到帧缓冲区的 深度关联对象gl.framebufferRenderbuffer()step 7检查帧缓冲区 是否正确配置gl.checkFramebufferStatus()step 8在帧缓冲区中 进行绘制gl.bindFramebuffer() FramebufferObjectFramebufferObject Code FramebufferObject运行结果shadersmaininit_Buffer&&TextureinitFramedrawattribute&&animatelet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec2 a_TexCoord; uniform mat4 u_MvpMatrix; varying vec2 v_TexCoord; void main() gl_Position = u_MvpMatrix * a_Position; v_TexCoord = a_TexCoord; `let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif uniform sampler2D u_Sampler; varying vec2 v_TexCoord; void main() gl_FragColor = texture2D(u_Sampler, v_TexCoord); `// 离屏绘制尺寸let OFFSCREEN_WIDTH = 256;let OFFSCREEN_HEIGHT = 256;function main() let canvas = document.getElementById(webgl) let gl = getWebGLContext(canvas) if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders) return let program = gl.program program.a_Position = gl.getAttribLocation(program, a_Position) program.a_TexCoord = gl.getAttribLocation(program, a_TexCoord) program.u_MvpMatrix = gl.getUniformLocation(program, u_MvpMatrix) let cube = initVertexBuffersForCube(gl) // 初始化立方体顶点信息 let plane = initVertexBuffersForPlane(gl) // 初始化平面定点信息 let texture = initTextures(gl) // 初始化纹理 let fbo = initFramebufferObject(gl) // 初始化帧缓冲区对象 gl.enable(gl.DEPTH_TEST) // 打开深度缓冲区 let viewProjMatrix = new Matrix4() // 视图透视矩阵 为颜色缓冲区做准备 viewProjMatrix.setPerspective( 30, canvas.width/canvas.height, 1.0, 100.0 ) viewProjMatrix.lookAt( 0.0, 0.0, 7.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) let viewProjMatrixFBO = new Matrix4(); // 帧缓冲器对象使用的透视矩阵 viewProjMatrixFBO.setPerspective( 30.0, OFFSCREEN_WIDTH/OFFSCREEN_HEIGHT, 1.0, 100.0 ) viewProjMatrixFBO.lookAt( 0.0, 2.0, 7.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) let currentAngle = 0.0 let tick = function () currentAngle = animate(currentAngle) draw(gl, canvas, fbo, plane, cube, currentAngle, texture, viewProjMatrix, viewProjMatrixFBO) window.requestAnimationFrame(tick, canvas) tick()// 初始化立方体顶点缓冲区function initVertexBuffersForCube(gl) let vertices = new Float32Array([ // 顶点缓冲区数组 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0,-1.0, 1.0, 1.0,-1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0,-1.0, -1.0, 1.0,-1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0,-1.0, -1.0,-1.0,-1.0, -1.0,-1.0, 1.0, // v1-v6-v7-v2 left -1.0,-1.0,-1.0, 1.0,-1.0,-1.0, 1.0,-1.0, 1.0, -1.0,-1.0, 1.0, // v7-v4-v3-v2 down 1.0,-1.0,-1.0, -1.0,-1.0,-1.0, -1.0, 1.0,-1.0, 1.0, 1.0,-1.0 // v4-v7-v6-v5 back ]) let texCoords = new Float32Array([ // 纹理缓冲区数组 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v1-v2-v3 front 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // v0-v3-v4-v5 right 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // v0-v5-v6-v1 up 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v1-v6-v7-v2 left 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // v7-v4-v3-v2 down 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 // v4-v7-v6-v5 back ]) let indices = new Uint8Array([ // 索引缓冲区数组 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back ]) let o = new Object(); o.vertexBuffer = initArrayBuffersForLaterUse(gl, vertices, 3, gl.FLOAT) o.texCoordBuffer = initArrayBuffersForLaterUse(gl, texCoords, 2, gl.FLOAT) o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE) if (!o.vertexBuffer || !o.texCoordBuffer || !o.indexBuffer) return null o.numIndices = indices.length gl.bindBuffer(gl.ARRAY_BUFFER, null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null) return o// 初始化平面顶点缓冲区function initVertexBuffersForPlane(gl) let vertices = new Float32Array([ 1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0,-1.0, 0.0, 1.0,-1.0, 0.0 // v0-v1-v2-v3 ]) let texCoords = new Float32Array([ 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0 ]) let indices = new Uint8Array([ 0, 1, 2, 0, 2, 3 ]) let o = new Object() o.vertexBuffer = initArrayBuffersForLaterUse(gl, vertices, 3, gl.FLOAT) o.texCoordBuffer = initArrayBuffersForLaterUse(gl, texCoords, 2, gl.FLOAT) o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE) if (!o.vertexBuffer || !o.texCoordBuffer || !o.indexBuffer) return null o.numIndices = indices.length gl.bindBuffer(gl.ARRAY_BUFFER, null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null) return o// 初始化ARRAY_BUFFERfunction initArrayBuffersForLaterUse(gl, data, num, type) let buffer = gl.createBuffer() if (!buffer) console.log(failed to init Array Buffer) return null gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW) buffer.num = num buffer.type = type return buffer// 初始化索引缓冲区function initElementArrayBufferForLaterUse(gl, data, type) let buffer = gl.createBuffer() if (!buffer) console.log(failed to init element array buffer) return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer) gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW) buffer.type = type return buffer // 初始化纹理对象function initTextures(gl) let texture = gl.createTexture() if (!texture) console.log(failed to create the Texture object) return null let u_Sampler = gl.getUniformLocation(gl.program, u_Sampler) if (!u_Sampler) console.log(failed to get the storage location of u_Sampler) return null let image = new Image() image.onload = function () gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) gl.bindTexture(gl.TEXTURE_2D, texture) gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image) gl.uniform1i(u_Sampler, 0) gl.bindTexture(gl.TEXTURE_2D, null) image.src = ../img/sky_cloud.jpg return texture// 初始化帧缓冲区对象function initFramebufferObject(gl) let framebuffer let texture let depthBuffer let error = function () if (framebuffer) gl.deleteFramebuffer(framebuffer) if (texture) gl.deleteTexture(texture) if (depthBuffer) gl.deleteRenderbuffer(depthBuffer) return null framebuffer = gl.createFramebuffer() // 创建帧缓冲区 if (!framebuffer) console.log(failed to create frame buffer object) return error() texture = gl.createTexture() // 创建纹理缓冲区 if (!texture) console.log(failed to create texture object) return error() gl.bindTexture(gl.TEXTURE_2D, texture) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null) gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) framebuffer.texture = texture // 存入纹理对象 depthBuffer = gl.createRenderbuffer() // 创建渲染缓冲区 if (!depthBuffer) console.log(failed to create renderbuffer object) return error() gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer) gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT) // 将纹理对象与渲染对象绑定到帧缓冲区对象上 gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer) gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0 ) gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer ) let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER) if (gl.FRAMEBUFFER_COMPLETE !== e) console.log(frame buffer is incomplete: + e.toString()) return error() gl.bindFramebuffer(gl.FRAMEBUFFER, null) gl.bindTexture(gl.TEXTURE_2D, null) gl.bindRenderbuffer(gl.RENDERBUFFER, null) return framebuffer// 绘制function draw(gl, canvas, fbo, plane, cube, angle, texture, viewProjMatrix, viewProjMatrixFBO) // 先绘制在帧缓冲区上 gl.bindFramebuffer(gl.FRAMEBUFFER, fbo) gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT) gl.clearColor(0.2, 0.2, 0.4, 1.0) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) drawTextureCube(gl, gl.program, cube, angle, texture, viewProjMatrixFBO) // 再绘制在canvas上 gl.bindFramebuffer(gl.FRAMEBUFFER, null) gl.viewport(0, 0, canvas.width, canvas.height) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) drawTexturedPlane(gl, gl.program, plane, angle, fbo.texture, viewProjMatrix)let g_modelMatrix = new Matrix4()let g_mvpMatrix = new Matrix4()// 绘制带纹理的立方体function drawTextureCube(gl, program, o, angle, texture, viewProjMatrix) g_modelMatrix.setRotate( 20.0, 1.0, 0.0, 0.0 ).rotate( angle, 0.0, 1.0, 0.0 ) g_mvpMatrix.set( viewProjMatrix ).multiply( g_modelMatrix ) gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements) drawTexturedObject(gl, program, o, texture)// 绘制平面function drawTexturedPlane(gl, program, o, angle, texture, viewProjMatrix) g_modelMatrix.setTranslate( 0, 0, 1 ).rotate( 20.0, 1.0, 0.0, 0.0 ).rotate( angle, 0.0, 1.0, 0.0 ) g_mvpMatrix.set( viewProjMatrix ).multiply( g_modelMatrix ) gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements) drawTexturedObject(gl, program, o, texture)// 绘制纹理对象function drawTexturedObject(gl, program, o, texture) initAttributeVariable(gl, program.a_Position, o.vertexBuffer) initAttributeVariable(gl, program.a_TexCoord, o.texCoordBuffer) gl.activeTexture(gl.TEXTURE0) gl.bindTexture(gl.TEXTURE_2D, texture) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer) gl.drawElements(gl.TRIANGLES, o.numIndices, o.indexBuffer.type, 0)// 获取attributefunction initAttributeVariable(gl, a_attribute, buffer) gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.vertexAttribPointer(a_attribute, buffer.num, buffer.type, false, 0, 0) gl.enableVertexAttribArray(a_attribute)let ANGLE_STEP = 30let last = Date.now()function animate(angle) let now = Date.now() let elapsed = now - last last = now let newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0; return newAngle % 360 渲染流程详解创建帧冲区对象framebuffer = gl.createFramebuffer() createFramebuffer用于创建帧缓冲区对象 deleteFramebuffer用于删除帧缓冲区对象 创建纹理对象并设置尺寸和参数texture = gl.createTexture() // 创建纹理对象gl.bindTexture(gl.TEXTURE_2D, texture)gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)framebuffer.texture = texture // 存入纹理对象 创建渲染缓冲区对象depthBuffer = gl.createRenderbuffer(); createRenderbuffer创建渲染缓冲区对象 deleteRenderbuffer删除渲染缓冲区对象 绑定渲染缓冲区并设置其尺寸gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer)gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT) bindRenderbuffer绑定渲染缓冲区 renderbufferStorage创建并初始化渲染缓冲区的数据区 深度关联对象的渲染缓冲区宽高必须与纹理缓冲区一致 将纹理对象关联到帧缓冲区对象gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); // 绑定帧缓冲区gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0) bindFramebuffer绑定帧缓冲区对象 framebufferTexture2D指定颜色和渲染关联对象 为什么颜色关联对象存在0后缀？答： 在OpenGL中有很多颜色关联对象，但在WebGL中只有1个，所以就只将序号为0的颜色关联对象分给了WebGL。 将渲染缓冲区对象关联到帧缓冲区对象gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer) framebufferRenderbuffer 检查帧缓冲区的配置let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER)if(gl.FRAMEBUFFER.COMPLETE !== e) console.log(Framebuffer object is incomlete: + e.toString()) return error() checkFramebufferStatus 在帧缓冲区进行绘图function draw(gl, canvas, fbo, plane, cube, angle, texture, viewProjMatrix, viewProjMatrixFBO) // 先绘制在帧缓冲区上 gl.bindFramebuffer(gl.FRAMEBUFFER, fbo) gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT) gl.clearColor(0.2, 0.2, 0.4, 1.0) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) drawTextureCube(gl, gl.program, cube, angle, texture, viewProjMatrixFBO) // 再绘制在canvas上 gl.bindFramebuffer(gl.FRAMEBUFFER, null) gl.viewport(0, 0, canvas.width, canvas.height) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) drawTexturedPlane(gl, gl.program, plane, angle, fbo.texture, viewProjMatrix) viewport定义离线绘图的绘图区域 开启消隐功能gl.CULL_FACE 运行FramebufferObject时，矩形正反两面都被贴上了纹理，这是因为WebGL默认 绘制图形的正反两面。实际上WebGL提供消隐功能（culling function）， gl.enable(gl.CULL_FACE)这样让WebGL不再绘制图形背面，能够提高绘制速度 未开启消隐未开启消隐运行结果 开启了消隐开启了消隐运行结果"},{"title":"响应上下文丢失","path":"/wiki/WebGL/chapter_10_09.html","content":"什么是响应上下文丢失 就是指在WebGL程序运行时，另一个程序接管了图形硬件，或者操作系统进入了休眠状态，总之就是 浏览器失去使用图形硬件资源的权利，会导致存储在硬件中的数据（响应上下文）丢失。ELEL的奇妙比喻这就像你妈（操作系统）分配给你和你兄弟姐妹们各种点心（硬件资源），如果你兄弟把你的点心抢走了（其他程序抢占资源），或者你妈打盹过头忘了分给你了（操作系统长时间休眠导致数据丢失），导致你没有点心吃，只好口头反抗（控制台报错） 可能会报WebGL error CONTEXT_LOST_WEBGL in uniformMatrix4fv([object WebGLUniformLocation, false, [object Float32Array]]) 如何响应上下文丢失通过对上下文事件监听 webglcontextlost 上下文丢失时触发webglcontextrestored 浏览器重置WebGL时触发 RotatingTriangle_contextLostmainstartcontextLostlet ANGLE_STEP = 45.0let g_currentAngle = 0.0let g_requestIDfunction main() let canvas = document.getElementById(webgl) canvas.addEventListener(webglcontextlost, contextLost, false) canvas.addEventListener(webglcontextrestored, function (ev) start(canvas) , false) start(canvas)重绘事件function start(canvas) let gl = getWebGLContext(canvas) if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(Failed to intialize shaders.); return; var n = initVertexBuffers(gl); // Write the positions of vertices to a vertex shader if (n 0) console.log(Failed to set the positions of the vertices); return; gl.clearColor(0.0, 0.0, 0.0, 1.0); // Specify the color for clearing canvas // Get storage location of u_ModelMatrix var u_ModelMatrix = gl.getUniformLocation(gl.program, u_ModelMatrix); if (!u_ModelMatrix) console.log(Failed to get the storage location of u_ModelMatrix); return; var modelMatrix = new Matrix4(); // Create a model matrix let tick = function () g_currentAngle = animate(g_currentAngle) draw(gl, n, g_currentAngle, modelMatrix, u_ModelMatrix) g_requestID = requestAnimationFrame(tick,canvas) tick()上下文丢失事件function contextLost(ev) cancelAnimationFrame(g_requestID) //停止动画 ev.preventDefault() // 阻止默认事件"},{"title":"附录A：WebGL中无需交换缓冲区","path":"/wiki/WebGL/chapter_11_01.html","content":"交换缓冲区交换缓冲区是什么？ OpenGL中实际有两个颜色缓冲区：后台颜色缓冲区实际绘制对象前台颜色缓冲区后台绘制完后，会将内容复制到前台因为直接在前台绘制会导致屏幕上出现一些视觉假象后台绘制完后，将内容复制到前台，就叫做 交换缓冲区，实质上是 交换指针 双缓冲区方法的调用机制 双缓冲区方法主要就是用来 切换前台与后台缓冲区的，不同的系统有不同的调用机制：自动调用显式调用 调用时机：在后台缓冲区绘制完一帧后如glutSwapBuffers()或eglSwapBuffers()void display(void) glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); draw(); glutSwapBuffers(); //显示交换颜色缓冲区 WebGL为什么不用交换缓冲区？因为WebGL只有一个颜色缓冲区 也就是所谓的 单缓冲区，单缓冲区之所以可用对于浏览器来说，JavaScript编写的WebGL程序只是 一次更底层方法的调用经典不用考虑底层调用，浏览器，我的超人 浏览器单缓冲区绘制流程Step1JavaScript执行结束并退出Step2浏览器检查颜色缓冲区是否被修改Step3如果颜色缓冲区被修改过了，将其显示到屏幕上方法优势浏览器可以同时控制颜色缓冲区网页上的其他内容"},{"title":"附录B：GLES ES 1.0内置函数","path":"/wiki/WebGL/chapter_11_02.html","content":"角度和三角函数 指数函数 通用函数 几何函数 矩阵函数 矢量函数 纹理查询函数 角度和三角函数指数函数通用函数几何函数矩阵函数矢量函数纹理查询函数"},{"title":"附录D：左手还是右手坐标系","path":"/wiki/WebGL/chapter_11_04.html","content":"官方回答： The GL does not force left-or right-handedness on of its coordinate systems.翻译：老是问这种钻牛角尖的问题，都说了左右手都行。那为什么之前在WebGL中频频使用右手坐标系呢？这个答案和你问南方人为什么吃肉粽子，和北方人为什么吃甜粽子一样，都是因为传统 CoordinateSystem.jsWebGL的z轴指向屏幕外，也就是说： 越深的物体z值越小 越浅的物体z值越大 CoordinateSystem CoordinateSystem运行结果ShadermaininitVertexBufferslet VSHADER_SOURCE = ` attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; void main() gl_Position = a_Position; v_Color = a_Color; `let FSHADER_SOURCE = ` #ifdef GL_ES precision mediump float; #endif varying vec4 v_Color; void main() gl_FragColor = v_Color; `function main() let canvas = document.getElementById(webgl) let gl = getWebGLContext(canvas) if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders) return gl.clearColor(0, 0, 0, 1) let n = initVertexBuffers(gl) if (n 0) console.log(failed to init vertex buffers) return gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)function initVertexBuffers(gl) let vertices = new Float32Array([ // bluetriangle 0.0, 0.6, -0.1, 0.0, 0.0, 1.0, -0.5, -0.5, -0.1, 0.4, 0.4, 0.4, 0.5, -0.5, -0.1, 0.0, 0.0, 1.0, // green triangle -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.5, 0.5, -0.5, 0.4, 0.4, 0.4, 0.0, -0.6,-0.5, 0.0, 1.0, 0.0 ]) let FSIZE = vertices.BYTES_PER_ELEMENT let n = 6 let a_Position = gl.getAttribLocation(gl.program, a_Position) let a_Color = gl.getAttribLocation(gl.program, a_Color) let buffer = gl.createBuffer() if (!buffer) return -1 gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6*FSIZE, 0) gl.enableVertexAttribArray(a_Position) gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6*FSIZE, 3*FSIZE) gl.enableVertexAttribArray(a_Color) return n 隐藏面消除和裁剪坐标系统为什么结果会是绿色三角形在前？ 蓝色三角形数据0.0, 0.6, -0.1, 0.0, 0.0, 1.0, -0.5, -0.5, -0.1, 0.4, 0.4, 0.4,0.5, -0.5, -0.1, 0.0, 0.0, 1.0,绿色三角形数据 -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,0.5, 0.5, -0.5, 0.4, 0.4, 0.4,0.0, -0.6,-0.5, 0.0, 1.0, 0.0这是因为没有进行隐藏面消除这时WebGL默认是按照绘制顺序来排列深度的 进行隐藏面消除之后的结果 打开隐藏面消除gl.enable(gl.DEPTH_TEST)// ...gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)绘制结果会改变吗？答： 并没有哦 依旧是绿色三角形在上这是因为 WebGL使用的是左手坐标系z轴是指向屏幕内部的左手坐标系 裁剪坐标系和可视空间裁剪坐标系（clip coordinate system） 开启隐藏面消除的时候会用到裁剪坐标系，裁剪坐标系本身就是左手坐标系 到底要怎样才能让WebGL恢复右手坐标系的状态呢？ 先要了解为什么开启消除面隐藏后还是以左手坐标系绘图答：正因为裁剪坐标系是左手坐标系，所以 a_Position 的数值传递给 gl_Position 时，会自动被纳入 左手坐标系 解决方法只有设定可视空间隐藏面消除才能够正常工作关键就是设定可视空间时会指定:近剪裁面 near远剪裁面 far这两者决定了使用的坐标系：near far z轴指向屏幕外右手坐标系near farz轴指向屏幕里左手坐标系给CoordinateSystem.js添加上可视空间的代码：let VSHADER_SOURCE = ` ... uniform mat4 u_MvpMatrix; ... gl_Position = u_MvpMatrix * a_Position; ...`function main() ... let mvpMatrix = new Matrix4() mvpMatrix.setOrtho( -1, 1, // left right -1, 1, // bottom top -1, 1 // near far ) gl.uniformMatrix4fv(u_MvpMatrix,false,mvpMatrix.elements) ... 右手坐标系下的绘制结果 可视空间、投影矩阵、坐标系为什么nearfar时就是右手坐标系绘图呢？ 这里需要考虑一下 setOrtho 对应的投影矩阵，mvpMatrix.setOrtho(-1,1,-1,1,-1,1)left -1right 1bottom -1top 1near -1far 1对应的投影矩阵应该是1, 0, 0, 0,0, 1, 0, 0,0, 0, -1, 0,0, 0, 0, 1,相当于对z轴进行翻转，setScale(1,1,-1)由于裁剪坐标系本身就是左手坐标系，这一操作相当于将左手左边系翻转成右手坐标系。 总结总之这一切的一切都是无中生有 WebGL默认行为规定是 左手坐标系比如裁剪面一类的默认行为大部分WebGL库和程序都采用的是 右手坐标系别问，问就是传统为了解决这个冲突需要将使用 右手坐标系的WebGL库，通过规定 可视空间 的方式翻转z轴，从而能够实现一些规定使用 左手坐标系的默认行为总结总之这个问题告诉我们程序员奇奇怪怪的习惯如何能无中生有出一个深奥晦涩的技术问题，还告诉我们让程序员统一开发规范有多难"},{"title":"附录E：逆转置矩阵","path":"/wiki/WebGL/chapter_11_05.html","content":"一般使用两种变换矩阵对法向量进行变换 模型视图矩阵的 逆转置矩阵模型矩阵具体使用哪种要视物体变换的类型而定。 坐标变换与法向量变换的关系 变换与法向量平移平移变换与法向量变换的关系 变换问题 平移的物体实际上法向量不会改变，但是如果模型视图矩阵中包含平移矩阵的话，原法向量会被当做点平移 解决方法 既然4维模型视图矩阵中与平移相关的只有 第4行 和 第4列，剩下的 3x3子矩阵 都是与旋转和缩放有关的，那就只取其左上角的 3x3子矩阵 对法向量进行变化就好了 旋转旋转变换与法向量变换的关系 较为简单的旋转变换 简单理由1如果只进行旋转变换，则直接对法向量使用相同的旋转矩阵就能直接实现法向量变换。即旋转时时：顶点变换矩阵 法向量变换矩阵简单理由2旋转后无需进行 归一化处理 缩放情况1：缩放因子相同 那么法向量自然不变：顶点缩放矩阵 法向量变换矩阵需要进行 归一化处理 情况2：缩放因子不同 缩放因子不同时的法向量变换这种情况必须使用 模型矩阵的逆转置矩阵变换后法向量必须进行 归一化处理 逆转置矩阵的数学推理假设物体顶点矢量为 s垂直于 s 的法向量为 n对 s 进行变换的模型矩阵为 M对 n 进行变换的矩阵为 M‘变换后的物体顶点矢量为 s’变换后的法向量为 n’已知条件由于 n 与 s 垂直， n’ 与 s’ 垂直所以有：n · s 0n’· s‘ 0s’ M × sn’ M’ × n开始推导∵ n’· s’ 0∴ （M’ × n）·（M × s） 0∵ A · B AT × BT∴ （M’ × n）T ×（M × s）T 0∵ （A × B）T BT × AT∴ nT × M‘T × MT × sT 0∵ nT × sT n · s 0∴ 要满足等式，必须有 M’T × MT I∴ M’ (M^-1)T总结： 法向量的变换矩阵即是模型矩阵的逆转置矩阵"},{"title":"附录F：从文件中加载着色器","path":"/wiki/WebGL/chapter_11_06.html","content":"本案例主要介绍如何将着色器程序从js中提取出来。 LoadShaderFromFiles Code LoadShaderFromFiles运行效果XMLHttpRequestshadermaindrawfunction readShaderFile(gl, fileName, shader) let request = new XMLHttpRequest() request.onreadystatechange = function () if (request.readyState === 4 request !== 404) onReadShader(gl, request.responseText, shader) request.open(GET, fileName, true) request.send()function onReadShader(gl, fileString, shader) if (shader === v) VSHADER_SOURCE = fileString if (shader === f) FSHADER_SOURCE = fileString if(VSHADER_SOURCE FSHADER_SOURCE) start(gl)ColoredTriangle.vertattribute vec4 a_Position;attribute vec4 a_Color;varying vec4 v_Color;void main() gl_Position = a_Position; v_Color = a_Color;ColoredTriangle.frag#ifdef GL_ES precision mediump float;#endifvarying vec4 v_Color;void main() gl_FragColor = v_Color;let VSHADER_SOURCE = nulllet FSHADER_SOURCE = nullfunction main() let canvas = document.getElementById(webgl) let gl = getWebGLContext(canvas) if (!gl) console.log(failed to get webgl context) return readShaderFile(gl, ColoredTriangle.vert, v) readShaderFile(gl, ColoredTriangle.frag, f)function start(gl) if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) console.log(failed to init shaders) return let n = initVertexBuffers(gl) if (n 0) console.log(failed to init vertex buffers) return gl.clearColor(0, 0, 0, 1) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES,0,n)function initVertexBuffers(gl) let verticesColors = new Float32Array([ 0.0, 0.5, 1.0, 0.0, 0.0, -0.5, -0.5, 0.0, 1.0, 0.0, 0.5, -0.5, 0.0, 0.0, 1.0 ]) let n = 3 let FSIZE = verticesColors.BYTES_PER_ELEMENT let a_Position = gl.getAttribLocation(gl.program, a_Position) let a_Color = gl.getAttribLocation(gl.program, a_Color) if (a_Position 0 || a_Color 0) return -1 let vertexBuffer = gl.createBuffer() let colorBuffer = gl.createBuffer() gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW) gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 5 * FSIZE, 0) gl.enableVertexAttribArray(a_Position) gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer) gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW) gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 5 * FSIZE, 2 * FSIZE) gl.enableVertexAttribArray(a_Color) return n"},{"title":"附录C：投影矩阵","path":"/wiki/WebGL/chapter_11_03.html","content":"可视空间 可视空间能够规定WebGL的绘制范围，在第7章中已经介绍过两种常用可视空间：正射投影透视投影 正射投影矩阵Matrix4.setOrtho( left, right, bottom, top, near, far) 透视投影矩阵Matrix4.setPerspective( fov, aspect, near, far)"},{"title":"make a 2D Games","path":"/wiki/Unity/Brackeys_01_make_a_game.html","content":"第一个2D游戏unity中制作2D游戏主要有2种流派：Tile Based 基于网格系统，编辑地图和关卡方便Sprite Based 可控性更强 创建一个Unity2D游戏项目 直接导入Unity Asset Store中的免费素材：https://assetstore.unity.com/packages/2d/environments/free-platform-game-assets-85838https://assetstore.unity.com/packages/2d/environments/free-platform-game-assets-85838导入的素材在Assets目录下，一般素材包中都会包含一个Demo文件夹，其中是用于展示素材的场景 Sorting Layer 图层 将一张瓷砖和背景图同时放入场景中时，会发现后放入物体会被先放入的物体遮挡住，这时需要给物体设置Sorting Layer 添加Animation 添加有动画的物体，需要将一连串连续的动画帧拖拽到目录树下：拖拽进去后，Unity会自动创建Animation和Animator，注意动画物体同样不要忘了设置Sorting Layer 添加物理效果 如何实现一个硬币掉落在草坪上的动画？1、给硬币和草坪添加碰撞体积 Box Collider 2D2、给硬币添加刚体效果 RigidBody 2D3、调整硬币的图层：硬币和草坪因为同样属于foreground图层的元素，因此这里调整的是Order in Layer属性 Tile Pallete 瓦片调色板 要使用Tile Pallete，首先要创建瓦片地图：右键Hierachy - 2D Object - TileMap - Rectangular创建出一个Grid目录下有一个Tilemap对象。Grid对象的Cell尺寸是可以修改的：Grid Cell Size打开调色板界面：Windows 2D Tile Pallete以下两个步骤新建的东西都要存放到对应文件中去新建调色板拖入Tile瓦片接下来就可以用刷子选中瓦片愉快绘制地图。这里使用的是256*256的Tile，Tile的尺寸和Grid的尺寸不一致，因此需要修改每个单位包含的像素值：Pixels Per UnitGrid的Size是2*2，Tile的尺寸是256 * 256单位的大小就应该为：2562 128"},{"title":"附录G：世界坐标系和本地坐标系","path":"/wiki/WebGL/chapter_11_07.html","content":"博主“白玉无冰”关于坐标系的一篇有趣的文章https://lamyoung.com/math/2021/12/10/math-Coordinate/ 使用专用三维建模工具构建模型的优势 之前只要绘制模型就需要在 initVertexBuffers 里手动写入大量的数据：比如MultiJoinModel程序的模型数据全都写在程序里var vertices = new Float32Array([ 0.5, 1.0, 0.5, -0.5, 1.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, 0.5, // v0-v1-v2-v3 front 0.5, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0,-0.5, 0.5, 1.0,-0.5, // v0-v3-v4-v5 right 0.5, 1.0, 0.5, 0.5, 1.0,-0.5, -0.5, 1.0,-0.5, -0.5, 1.0, 0.5, // v0-v5-v6-v1 up -0.5, 1.0, 0.5, -0.5, 1.0,-0.5, -0.5, 0.0,-0.5, -0.5, 0.0, 0.5, // v1-v6-v7-v2 left -0.5, 0.0,-0.5, 0.5, 0.0,-0.5, 0.5, 0.0, 0.5, -0.5, 0.0, 0.5, // v7-v4-v3-v2 down 0.5, 0.0,-0.5, -0.5, 0.0,-0.5, -0.5, 1.0,-0.5, 0.5, 1.0,-0.5 // v4-v7-v6-v5 back]);// Normalvar normals = new Float32Array([ 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, // v7-v4-v3-v2 down 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0, 0.0, 0.0,-1.0 // v4-v7-v6-v5 back]);// Indices of the verticesvar indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // right 8, 9,10, 8,10,11, // up 12,13,14, 12,14,15, // left 16,17,18, 16,18,19, // down 20,21,22, 20,22,23 // back]);而使用建模工具允许对基本三维图形进行各种操作： 组合形变顶点数量调整顶点间隔优化等等 本地坐标系与世界坐标系的关系 本地坐标系本地坐标系（local coordinate system） 创建三维模型需要知道模型原点 *（0.0, 0.0, 0.0）*在哪，比如：立方体的原点就在 中心太阳或月亮等球体的原点在 球心游戏角色模型的原点大部分都位于 脚部，Y轴 垂直向上 穿过身体的中线。这样就可以方便的操纵游戏角色在世界中的位置和动作：y0 时，游戏角色就站立在地面上模型沿y轴旋转，即是角色在 转向沿Z轴或X轴移动角色，即是角色在地面上跑动或滑动育碧教科书式模型坐标bug《刺客信条：罗马之下》 世界坐标系世界坐标系（world coordinate system） 也称 全局坐标系 (global coordinate system)当空间中的物体移动和变化时，不能将世界坐标系或本体坐标系分开考虑，需要将两个坐标系结合起来考虑，即 世界变换世界变换（world transformation）即物体本身仍然是基于 本地坐标系，但物体相对世界的变换需要将 本地坐标系 转换到 世界坐标系，这就是世界变换。 LocalAndWorldCoordinate案例主要介绍的是简单的世界变换 LocalAndWorldCoordinate Code 沿本体坐标系旋转基本原理实际上就是将物体先平移回原点，然后旋转，然后再平移回来，这本书作者也在书里吐槽：”为了企鹅像在跳芭蕾舞一样自旋，你需要先把企鹅移到场景原点，旋转，再移回来，真够麻烦的。“Local World 未经世界变换的三角形围绕世界y轴旋转vertex shader// u_MvpMatrix 为视图模型矩阵，其中模型部分直接进行绕Y轴旋转变换gl_Position = u_MvpMatrix * a_Position 经过世界变换的三角形围绕本体y轴旋转vertex shader// u_vpmatrix 视图矩阵// transbackMatrix 将顶点平移回原点的平移矩阵// u_RotateMatrix 旋转矩阵// translateMatrix 将顶点从原点平移回坐标位置的平移矩阵gl_Position = u_vpMatrix * transbackMatrix * u_RotateMatrix * translateMatrix * a_Position; Buffer DatavpMatrixlet verticesColors = new Float32Array([ 0.0, 0.3, 0.5, 0.3, 0.6, 0.6, -0.3, -0.3, 0.5, 0.3, 0.0, 0.6, 0.3, -0.3, 0.5, 0.3, 0.0, 0.6, 0.0, 0.3, 0.0, 0.3, 0.8, 0.8, -0.3, -0.3, 0.0,0.3, 0.0, 0.8, 0.3, -0.3, 0.0,0.3, 0.0, 0.8, 0.0, 0.3, -0.5,0.3, 1.0, 1.0, -0.3, -0.3, -0.5, 0.3, 0.0, 1.0, 0.3, -0.3, -0.5,0.3, 0.0, 1.0,])let vpMatrix = new Matrix4()vpMatrix.setOrtho( -1.0, 1.0, -1.0, 1.0, -1.0, 1.0).lookAt( -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,1.0,0.0) 变换与坐标系"},{"title":"2D Movement in Unity","path":"/wiki/Unity/Brackeys_02_2d_movement.html","content":"Character Controller原视频资源作者提供的脚本代码：将Character-Controller加入控制角色Player的脚本中： 地面检测 地面检测的两个关键问题：什么是地面？What is Ground属性：除了Player自身以外的Everything检测到地面的条件是什么？Ground Check：脚部坐标点，用于检测和地面之间的碰撞Ceiling Check：头部坐标点，检测和头顶物体的碰撞 Ceiling Check Ground Check 碰撞检测 Rigidbody 2D2点需要注意：Mass比其他物体稍大，跳跃下落的效果更好Collision Detection设置为Continuous，不然在玩家下落时会出现短暂的地面卡顿Z旋转轴锁死，因为会出现下面的情况：Tilemap 碰撞检测Tilemap这里划分成3个模块：前景：不被遮挡无碰撞元素后景：被遮挡的无碰撞元素平台：碰撞元素这里为需要进行碰撞检测的Tilemap添加3个脚本：Rigidbody 2D：开启Static类型Tilemap Collider 2DComposite Collider 2DMulti Collider 混合碰撞检测Tips1: 在Edit Collider的时候，按住alt键可以进行对称编辑Tips2: 鼠标拖动调整属性时，按住alt可以进行细调角色如果只用一个Box Collider或者Circle Collider进行碰撞检测，效果都会有缺点，仅使用Box Collider的时候，斜坡地段会出现卡顿的情况这里作者建议角色上半身用Box Collider，下半身用Circle Collider： MovementCharacterController2D Brackeys提供的CharacterController2D类，其中提供移动的主要方法就是Move，Move需要3个参数：float move：水平移动距离bool crouch：是否下蹲bool jump：是否跳跃 Horizontal Movement 水平移动 为Player添加一个新的脚本PlayerMovement：public class PlayerMovement : MonoBehaviour public CharacterController2D controller2D; // 关联的控制器 public float moveSpeed = 50f; // 移动速度 float horizontalMove = 0f; // 水平移动距离 // Update is called once per frame void Update() // Input.GetAxisRow(Horizontal) 获取水平方向的移动 // 左移：A键 Input.GetAxisRow(Horizontal) = -1 // 右移：D键 Input.GetAxisRow(Horizontal) = 1 horizontalMove = Input.GetAxisRaw(Horizontal) * moveSpeed; void FixedUpdate() // Time.fixedDeltaTime 时间增量 controller2D.Move(horizontalMove * Time.fixedDeltaTime, false, false); 并将之前为玩家添加的Character Controller 2D脚本与controller2D属性关联。 unity input setting Unity提供按键检测的方法：Input.GetButtonDown(Jump); // 检测按键按下Input.GetButtonUp(Crouch); // 检测按键松开这样只要我们按下W键，这个方法就会返回true，W键-Jump的对应关系在Unity内可以修改：Edit - Project Settings - Input Manager Jump 跳跃 在PlayerMovement中添加进行跳跃检测的代码：public class PlayerMovement : MonoBehaviour // ... bool jump = false; void Update() // ... if (Input.GetButtonDown(Jump)) jump = true; void FixedUpdate() controller2D.Move(horizontalMove * Time.fixedDeltaTime, false, jump); jump = false; // 跳跃后重置 这样做是可以进行跳跃，但是可能会出现角色卡在平台边缘的情况，这是因为角色上半身的方形碰撞盒和平台碰撞盒之间存在摩擦力，因此可以为角色的碰撞盒添加新的Physics Material：Fiction 0Bounciness 0这样在平台边缘，角色就会因为缺少摩擦力自动滑下来 Crouch 下蹲 在PlayerMovement中对下蹲进行检测：public class PlayerMovement : MonoBehaviour // ... bool crouch = false; // 下蹲检测 void Update() // ... // 下蹲检测 if (Input.GetButtonDown(Crouch)) crouch = true; else if (Input.GetButtonUp(Crouch)) crouch = false; void FixedUpdate() controller2D.Move(horizontalMove * Time.fixedDeltaTime, crouch, jump); jump = false; 在为Player添加碰撞体时，分别为上半身和下半身添加了一个碰撞体积，下蹲实际实现的是使上半身的碰撞盒失效，这一点需要在Character Controller 2D中对Crouch Disable Collider进行配置在按下下蹲键时，上半身的碰撞盒就会失效： onLanding闪电触发Bug问题描述 角色跳跃时，本应只在角色落地时触发，但现在在角色跳起之前也被触发一次，于是角色动画就因为跳起之前的这一次被关闭了： 解决方式 查看CharacterController2D代码，发现地面检测是在FixedUpdate函数中被调用的，因此应当是因为跳跃之后的第一帧，角色还没有离地，CharacterController2D的FixedUpdate函数就被调用了，于是就判定跳跃结束，因此这里在FixedUpdate函数中使用Invoke进行延时调用： // 地面检测函数private void CollideCheck() bool wasGrounded = m_Grounded; m_Grounded = false; Collider2D[] colliders = Physics2D.OverlapCircleAll(m_GroundCheck.position, k_GroundedRadius, m_WhatIsGround); for (int i = 0; i colliders.Length; i++) if (colliders[i].gameObject != gameObject) m_Grounded = true; if (!wasGrounded) OnLandEvent.Invoke(); // 延时调用0.01sprivate void FixedUpdate() Invoke(CollideCheck, 0.01f);"},{"title":"2D Camera","path":"/wiki/Unity/Brackeys_04_2d_camera.html","content":"Cinemachineunity中使用Cinemachine进行相机追踪效果。Cinemachine手册Cinemachine需要作为包引入，引入位置：WindowPackage ManagerCinemachine → install引入后就可以在Hierarchy中创建2D Camera创建出来的Camera全称CinemachineVirtualCamera，即虚拟相机，和主相机关联绑定在一起，对CinemachineVirtualCamera进行的操作都会反映到主相机上，因为相机要跟随角色的移动而移动，所以需要将角色绑定到Follow属性上： CinemachineVirtualCamera.Body CinemachineVirtualCamera.Body中提供许多可调整的参数：Lookahead 相机朝角色运动方向的偏转Damping 相机跟随阻尼Screen 相机绝对位置Dead Zone 死区"},{"title":"2D Shooting","path":"/wiki/Unity/Brackeys_05_2d_Shooting.html","content":"子弹 射线实现Shooting的两种方式 预制件 prefabs创建Bullet Prefabs，每次射击都创建一个新的子弹实例子弹本体控制射出等动作、伤害、效果等属性射线 raycasts由射击点射出一条射线，检测是否存在碰撞物 开火点 FirePointFirePoint 在Player层级下创建空对象FirePoint，用于对开火点坐标进行标注。需要注意的是，在控制角色移动的脚本CharacterController2D中，实现角色水平移动时翻转的函数是这样的：private void Flip() m_FacingRight = !m_FacingRight; // Multiply the players x local scale by -1. Vector3 theScale = transform.localScale; theScale.x *= -1; // 反转x轴缩放 transform.localScale = theScale;通过反转Player在x轴方向的缩放值进行翻转。这种方式能够在不影响Player坐标系的情况下对它的贴图进行翻转。但是Player下的FirePoint的坐标系是动态的，在Player进行翻转时，FirePoint坐标系也需要跟随翻转，这样才能保证子弹一直朝Player面向的方向进行射击，通过将Player沿y轴方向旋转180°的方式能够实现这一点：private void Flip() m_FacingRight = !m_FacingRight; transform.Rotate(0f, 180f, 0f); Prefab射击Bullet 使用prefab方式，就要做bullet的prefab：BulletPrefab脚本：Bullet 为子弹自定义行为的脚本Circle Collider 2D 碰撞体积isTrigger true 仅用于触发Rigidbody 2DGraivity Scale 0 无重力Collision Detection Continuous 持续检测Freeze Rotation Z true 无z轴旋转将做好的BulletPrefab拖动到Assets目录下，即作为预制件使用。 创建子弹射击创建BulletPrefab 子弹已经做好，那么只要在Player射击的时候创建出子弹即可，因此需要为Player创建新的Weapon脚本，Weapon脚本要实现在用户射击时创建BulletPrefab的功能：using System.Collections;using System.Collections.Generic;using UnityEngine;public class Weapon : MonoBehaviour public Transform firePoint; // 火点 此处赋值Player下的FirePoint public GameObject bulletPrefab; // 子弹预制件 此处赋值Bullet预制件 void Update() if (Input.GetButtonDown(Fire1)) Shoot(); // 射击 private void Shoot() // 创建预制件 Instantiate(bulletPrefab, firePoint.position, firePoint.rotation); 创建实例的方法：// 创建对象 位置 旋转Instantiate(GameObject. position, rotation) 子弹移动子弹移动 通过为Bullet添加初始速度来时其保持移动，这要通过子弹的Rigidbody2D.velocity属性来控制：public class Bullet : MonoBehaviour public float speed = 30f; // 速度 public Rigidbody2D rd; // 使用Rigidbody2D.velocity属性，为物体提供初始速度 void Start() // 速度 = 移动方向 * 移动速度 rd.velocity = transform.right * speed; 子弹伤害子弹伤害 现在子弹已经能射出，接下来要实现的：检测子弹是否碰撞到物体检测到碰撞，产生子弹冲击效果，子弹消失碰撞物是否是敌人使敌人，造成伤害敌人脚本要实现的动作收到伤害生命值为0时，死亡死亡敌人消失出现消失特效Enemy脚本为敌人添加的Enemy脚本如下：public class Enemy : MonoBehaviour public int health = 100; // 生命值 public GameObject DeathEffect; // 死亡效果 public void TakeDamage(int damage) health -= damage; if (health = 0) Death(); private void Death() // Quaternion.identity代表无旋转 Instantiate(DeathEffect, transform.position, Quaternion.identity); Destroy(gameObject); 其中的TakeDamage方法的调用时机是：当子弹碰撞到Enemy时，这一步在Bullet预制件脚本中进行，因此需要用public暴露出来。子弹碰撞检测之前已经打开了Bullet预制件Collider2D的isTrigger选项，因此当子弹碰撞到物体时，会触发Unity提供的OnTriggerEnter2D函数，这个函数提供一个Collider2D类的参数，表示碰撞物信息。public class Bullet : MonoBehaviour public int damage = 40; // 伤害 public GameObject impactEffect; // 子弹冲击效果预制件 // Trigger回调函数 private void OnTriggerEnter2D(Collider2D hitInfo) // 判断碰撞物是否是Enemy Enemy enemy = hitInfo.GetComponentEnemy(); if(enemy != null) enemy.TakeDamage(damage); Instantiate(impactEffect, transform.position, transform.rotation); // 冲击效果 Destroy(gameObject); // 销毁子弹 Raycast射击raycast射线检测raycast raycast和prefab不同的地方是：prefab碰撞的逻辑需要再子弹上实现raycast碰撞的逻辑在Player上就能实现为Player添加WeaponRaycast脚本：public class WeaponRaycast : MonoBehaviour public Transform firePoint; public int damage = 30; public GameObject ImpactEffect; // Update is called once per frame void Update() if (Input.GetButtonDown(Fire1)) Shoot(); private void Shoot() RaycastHit2D hitInfo = Physics2D.Raycast(firePoint.position, firePoint.right); if (hitInfo) Enemy enemy = hitInfo.transform.GetComponentEnemy(); if(enemy != null) enemy.TakeDamage(damage); Instantiate(ImpactEffect,hitInfo.point,Quaternion.identity); 创建raycast并返回射线探测物：RaycastHit2D hitInfo = Physics2D.Raycast(firePoint.position, firePoint.right);原本在Prefab方法里，会在OnTriggerEnter2D方法中提供一个Collider2D类型的参数，这里对应RaycastHit2D中的参数为：Enemy enemy = hitInfo.transform.GetComponentEnemy();而碰撞点的坐标值则从hitInfo.point里取得 射线绘制Line 使用Line（EffectLine）来作为射线效果，在Player下创建Line实例，开启Line的Use World Space属性 Coroutine射线效果 public class WeaponRaycast : MonoBehaviour // ... private void Start() lineRenderer.enabled = false; // 开始时关闭射线可见 void Update() if (Input.GetButtonDown(Fire1)) StartCoroutine(Shoot()); // StartCoroutine调用Shoot IEnumerator Shoot() // IEnumerator声明 // ...碰撞检测略 // 实现射线短暂显示的效果 lineRenderer.enabled = true; // 实现短暂延时 yield return new WaitForSeconds(0.01f); lineRenderer.enabled = false; Top Down Shooting 俯视角射击这里俯视角下玩家的移动涉及到跟随鼠标移动的旋转：public class PlayerMovement : MonoBehaviour public float moveSpeed = 5f; // 移动速度 public Rigidbody2D rb; // rigidbody Vector2 movement; // 位置 public Animator animator; // 动画控制器 public Camera cam; // 相机 Vector2 mousePos; // 鼠标位置 // Update用于获取玩家输入 void Update() movement.x = Input.GetAxisRaw(Horizontal); // 获取横坐标 movement.y = Input.GetAxisRaw(Vertical); // 获取纵坐标 // 动画 float moveDiff = Mathf.Abs(movement.x * moveSpeed) + Mathf.Abs(movement.y * moveSpeed); // 相对移动距离 animator.SetFloat(speed, moveDiff); // 将鼠标相对屏幕的坐标转换为世界点位坐标 mousePos = cam.ScreenToWorldPoint(Input.mousePosition); // FixedUpdate用于对玩家位置更新 private void FixedUpdate() rb.MovePosition(rb.position + movement * moveSpeed * Time.fixedDeltaTime); // 计算z轴旋转角 Vector2 lookDir = mousePos - rb.position; float angle = Mathf.Atan2(lookDir.y, lookDir.x) * Mathf.Rad2Deg + 90f; rb.rotation = angle; Input.GetAxisRaw(“Horizontal|Vertical”) 获取横向纵向移动距离Camera.ScreenToWorldPoiint(Vector2D var) 将鼠标相对屏幕的坐标转换为世界坐标系下的坐标最后需要根据玩家当前坐标和鼠标位置计算旋转的角度：Mathf.Atan2(y,x) 获取正弦值为yx的弧度Mathf.Rad2Deg 将弧度转为角度需要乘上的数Shooting脚本Shooting脚本需要在玩家触发子弹发射行为时，获取开火点创建子弹实例 给子弹一个推动力：public class Shooting : MonoBehaviour public GameObject Bullet; // 子弹prefab public Transform FirePoint; // 开火点 public float bulletForce = 20f; // 子弹速度 private void Update() if (Input.GetButtonDown(Fire1)) Shoot(); private void Shoot() GameObject bullet = Instantiate(Bullet, FirePoint.position, FirePoint.rotation); Rigidbody2D rb = bullet.GetComponentRigidbody2D(); rb.AddForce(-FirePoint.up * bulletForce, ForceMode2D.Impulse); Bullet最后是子弹自身检测到碰撞后的逻辑：public class Bullet : MonoBehaviour public GameObject ImpactEffect; private void OnCollisionEnter2D(Collision2D collision) GameObject impactEffect = Instantiate(ImpactEffect, transform.position, Quaternion.identity); Destroy(impactEffect, 0.5f); // 半秒后销毁特效实例 Destroy(gameObject); // 销毁当前实例"},{"title":"2D Animation","path":"/wiki/Unity/Brackeys_03_2d_animation.html","content":"创建动画新建Animation和Animator 调出Animation面板（WindowAnimationAnimation）Hierarchy选中添加动画的元素（Player）点击Animation中Create创建新的动画创建动画的同时，Animator也创建出来了。 创建帧序列动画 将一组帧序列动画拖入Animation面板即可创建一个新的动画，调整Samples采样值（每秒钟播放的图片数）idle Animator动画控制器Animator设置 Parameter 添加变量Base Layer 编辑状态Setting 迁移设置Condition 迁移条件 脚本中修改Animator的变量 定义animator，定义完后记得在Inspector中赋值public Animator animator; // 动画控制器修改速度Speed变量的值（SetFloat）：horizontalMove = Input.GetAxisRaw(Horizontal“) * moveSpeed;animator.SetFloat(Speed, Mathf.Abs(horizontalMove))// 跳跃检测 if (Input.GetButtonDown(Jump)) jump = true; animator.SetBool(IsJumping, true); 由于跳跃动画并不是在跳跃期间循环播放，而是在跳跃开始到跳跃结束之间只播放一次，因此需要将Any Status → player_jump 之间的转化Setting的Can Transition To Self关闭。我们知道角色何时跳起，如何知道何时落地？同样的，知道角色何时开始蹲下，如何知道角色何时起来？CharacterController2D脚本提供两个回调函数：OnLand 跳跃结束回调函数OnCrouch 蹲下结束回调函数在playerMovement中添加两个函数// 跳跃结束回调函数public void OnLanding() animator.SetBool(IsJumping, false);// 下蹲检测函数public void OnCrouching(bool isCrouching) animator.SetBool(IsCrouching, isCrouching);设置这两个函数与CharacterController2D中对应：注意：OnCrouch函数有一个bool类型参数，代表是否蹲下，因此在关联时，需要选用上面的Dynamic bool"},{"title":"2D Sprite Shape","path":"/wiki/Unity/Brackeys_06_2d_sprite_shape.html","content":"Sprite ShapeSprite Shape 官方文档Unity中两种创建地图的方式：Tile Map 通过在grid上铺满瓦片的方式创建地图，灵活度低Sprite Shape 能够对Sprite图做拉伸、平铺等操作，更加灵活使用Sprite Shape，首先要安装它：WindowPackage ManagerPackages:Unity Registry2D SpriteShapeInstall准备的Sprite精灵图需要进行一些配置：Pixels Per Unit : 16Filter Mode : PointCompression : None Open Sprite Shapeopen sprite shape比较适合用来做平面创建 Sprite Shape ProfileProject菜单Create2DSprite Shape Profile将平面图作为-180°到180°的Sprite图填入，在Hierarchy树下创建Open Sprite Shape：2D ObjectSprite ShapeOpen Sprite Shape将Sprite Shape Controller的Profile设置为刚才创建的Sprite Shape Profile，Edit Spline：这里由于没有对Sprite拉伸的部分进行处理，所以会出现一段一段的情况，需要对Sprite进行Border调整：这样Sprite Shape拉伸部分就会根据调整的部分进行拼接：Sprite Shape ColliderSprite Shape的Collider使用Edge Collider 2D，加入后，需要调整Sprite Shape Controller中的2个属性：Update Collider 为true调整Offset，不然Collider判定在Edge的中间 Close Sprite Shape在Close Sprite Shape中，旋转角度不同的Sprite可以选择不同的贴图，只需要规定好起始角度，和在这个角度范围内展示的贴图即可：注意：闭合的Sprite Shape使用Angle Ranges配置四周的贴图，中心贴图需要对Fill Texture进行配置，中心贴图绘制的模式在选择填入的Sprite贴图Inspector中，有一个Weap Mode属性，可以选择Repeat重复。Coners设置拐角贴图：创建Close Sprite Shape，赋值Profile，最终可以获取到一个可编辑的Close Sprite Shape："},{"title":"2D Lighting","path":"/wiki/Unity/Brackeys_07_2d_light.html","content":"Unity版本:2021 安装URP包使用Package Manager安装Universal RP包安装好之后就能在Assets文件夹中创建URP渲染管线，CreateRenderingURP Asset(with 2d renderer)新建后还会自动创建一个renderer 2d data文件，用来放在URP Asset的Renderer List里的。将Project SettingsGraphicsScriptable Renderer Pipeline Settings设置为刚才创建的URP Asset文件 切换渲染模式 将渲染管线修改成URP Asset之后，还需要将Sprite的材质修改为Sprite-Lit-Default这样Sprite才能受到光照的影响。通过WindowRenderingRender Pipeline Converter对现有场景中的Sprite进行材质替换，选择Convert Built-in to 2D(URP)，勾选 Material and Material Reference Upgrade 进行更新这样所有Sprite的材质都被替换为Sprite-Lit-Default Sprite没有变暗问题 按理来说Sprite的Material修改为Sprite-Lit-Default后，就会受光照影响，如果没有Light的话，会变为全黑，但是如果场景中Sprite没有变黑，是因为没有加任何Light实例，只有存在至少一个全局光照GlobalLight时，光照才能有效。参考视频另外，在Hierarchy直接通过菜单创建的Light有时会自带一个Light配置脚本（导致不起作用），需要额外添加Light 2D脚本才起作用，不知道是什么原因。 Light完成URP的配置后，就能在Hierarchy中创建2D Light，Unity提供很多种类的光源：Point Light 点光源Spot Light 聚光灯可以调整角度Global 全局光照Sprite 贴图光照能够根据提供的光照贴图添加光Freeform 自定义形状光可以自定义光的形状，很好用！这些光源都是可以调整影响图层的（Target Sorting Layers） Normal TextureSprite还支持法线贴图法线贴图通过光照能为2d物体带来3d效果："}]